<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kirai</title>
  
  <subtitle>Keep going</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://vincentxwd.github.io/blog/"/>
  <updated>2018-11-18T13:06:12.916Z</updated>
  <id>https://vincentxwd.github.io/blog/</id>
  
  <author>
    <name>Kirai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[GCJKickstart2018RoundH] C. Let Me Count The Ways（容斥）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/18/GCJK2018HC/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/18/GCJK2018HC/</id>
    <published>2018-11-18T12:40:34.000Z</published>
    <updated>2018-11-18T13:06:12.916Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;a=2" target="_blank" rel="noopener">https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;a=2</a></p><p><strong>一共有$2n$个座位排成一排，现在有m对人去坐，每对人之间有顺序。每对人均不可以相邻，问一共有多少种坐法？</strong></p><a id="more"></a><p>考虑用总的排列数减去每对人都相邻的情况，于是我们发现后者的排列是可以容斥的。</p><p>设$f(k)$表示$k$对人均坐在一起的排列数，那么答案就是：<br>$$<br>\sum_{k=0}^m(-1)^kf(k)<br>$$<br>$f(k)$也比较容易算，可以由下面几个部分组合起来：</p><ol><li>$m$对中任取$k$对：$C(m,k)$</li><li>每对人有顺序，那么所有可能的排列就是$2^k$</li><li>在$2n$个位置里面挑$k$对位置，将两个相邻位置看成一个座位，那么相当于$2n-k$个位置的排列选前$k$个相邻位去坐，一共有$(2n-k)!$种挑法。</li></ol><p>于是$f(k)=C(m,k)2^k(2n-k)!$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod =(LL) <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8100001</span>;</span><br><span class="line">LL f[maxn];</span><br><span class="line">LL n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) f[i] = (f[i<span class="number">-1</span>] * i) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = (ret * x) % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    x = (x * x) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LL ret = exgcd(b, a%b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span> </span>&#123;</span><br><span class="line">  LL x, y;</span><br><span class="line">  exgcd(a, mod, x, y);</span><br><span class="line">  <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f[x] * inv(f[x-y]) % mod * inv(f[y]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL k = <span class="number">0</span>; k &lt;= m; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">ret += (f[<span class="number">2</span>*n-i]*C(m,i)%mod)*mul(<span class="number">2L</span>L,i)%mod;</span><br><span class="line">ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ret -= (f[<span class="number">2</span>*n-i]*C(m,i)%mod)*mul(<span class="number">2L</span>L,i)%mod;</span><br><span class="line">ret += mod;</span><br><span class="line">ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) ret += mod;</span><br><span class="line"><span class="keyword">return</span> ret % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="comment">// freopen("out", "w", stdout);</span></span><br><span class="line">init();</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _ &lt;&lt; <span class="string">" Done."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, gao());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;amp;a=2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;amp;a=2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一共有$2n$个座位排成一排，现在有m对人去坐，每对人之间有顺序。每对人均不可以相邻，问一共有多少种坐法？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="组合数学， 容斥" scheme="https://vincentxwd.github.io/blog/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C-%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces521E] Thematic Contests(贪心)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/17/cf521E/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/17/cf521E/</id>
    <published>2018-11-16T18:05:11.000Z</published>
    <updated>2018-11-16T18:11:45.208Z</updated>
    
    <content type="html"><![CDATA[<p>赛后4min过题的感觉真不爽啊……</p><p>题目链接：<a href="http://codeforces.com/contest/1077/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1077/problem/E</a></p><p><strong>题意：要$n$个题出比赛，每一个题有一个类型$a_i$，要求每一天出的比赛都是同一种类型的题，并且每一种类型在这几天内只出现一次，并且当前一天出题数是前一天的2倍，问这些天最多出多少题。</strong></p><a id="more"></a><p>首先维护一下每一种题出现的次数，我们只需要操作这个次数就可以了。</p><p>对题目出现次数从大到小排个序，接下来我们考虑枚举题目的上界，然后往下枚举就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;LL,LL&gt; vis;</span><br><span class="line">LL n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL a;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n)) &#123;</span><br><span class="line">    vis.clear();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;a);</span><br><span class="line">      vis[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; cnt;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : vis) &#123;</span><br><span class="line">      cnt.emplace_back(x.second);</span><br><span class="line">      ret = max(ret, x.second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cnt.begin(), cnt.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      LL t = i;</span><br><span class="line">      LL tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt.size(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(cnt[j] &gt;= t) tmp += t;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[j] &lt; t) <span class="keyword">break</span>;</span><br><span class="line">        tmp += t;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ret = max(ret, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;赛后4min过题的感觉真不爽啊……&lt;/p&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1077/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1077/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意：要$n$个题出比赛，每一个题有一个类型$a_i$，要求每一天出的比赛都是同一种类型的题，并且每一种类型在这几天内只出现一次，并且当前一天出题数是前一天的2倍，问这些天最多出多少题。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 支持向量机（SVM）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/16/svm/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/16/svm/</id>
    <published>2018-11-16T14:16:23.000Z</published>
    <updated>2018-11-17T09:01:00.923Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第六章（支持向量机）的笔记。支持向量机最根本的想法是利用数据集找到一个超平面，将两类的样本分隔开，并且这个超平面距离两类数据的支持向量最远。支持向量指的是距离超平面最近的几个点。</p><a id="more"></a><hr><p>HEXO特别坑，我的数学公式在typora中编辑正常，但是生成静态页面时就解析错误了，只好上传图片外加附PDF文件了：<a href="http://pcoln8jiu.bkt.clouddn.com/svm.pdf" target="_blank" rel="noopener">http://pcoln8jiu.bkt.clouddn.com/svm.pdf</a></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_1.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_2.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_3.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_4.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_5.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_6.Jpeg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第六章（支持向量机）的笔记。支持向量机最根本的想法是利用数据集找到一个超平面，将两类的样本分隔开，并且这个超平面距离两类数据的支持向量最远。支持向量指的是距离超平面最近的几个点。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces520D] Fun with Integers (规律，并查集)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/16/cf520d/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/16/cf520d/</id>
    <published>2018-11-15T17:16:26.000Z</published>
    <updated>2018-11-15T17:43:12.470Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1062/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/D</a></p><p>给一个$n$，现在允许任意初始一个数$k$并给定一个操作：$ax=b$，$bx=a$当且仅当$a$为$b$的倍数或$b$为$a$的倍数时，可以将$a$变为$b$（可以是负数），同时获得分数$|x|$. 要求不允许有多次$a$到$b$或$b$到$a$的操作（每个$x$仅算一次），问最多能得多少分。</p><a id="more"></a><p>看到第一个样例就明白了：考虑一个数$x$和它的因数$p_i$，我们总可以由$x$转到所有$\pm p_i$的可能（从$x$转到$p_i$，再由$p_i$转到$-x$，然后是$-x$到$-p_i$，接着是$-p_i$到$x$），每一次的贡献是$4p_i$，于是我们考虑维护所有带有整除关系的连通块，然后计算它们的所有倍数和*4就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line">LL s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  pre[find(x)] = find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">        unite(i, i*j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">        s[find(i)] += (LL)j &lt;&lt; <span class="number">2L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = max(ret, s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1062/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1062/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给一个$n$，现在允许任意初始一个数$k$并给定一个操作：$ax=b$，$bx=a$当且仅当$a$为$b$的倍数或$b$为$a$的倍数时，可以将$a$变为$b$（可以是负数），同时获得分数$|x|$. 要求不允许有多次$a$到$b$或$b$到$a$的操作（每个$x$仅算一次），问最多能得多少分。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="规律" scheme="https://vincentxwd.github.io/blog/tags/%E8%A7%84%E5%BE%8B/"/>
    
      <category term="并查集" scheme="https://vincentxwd.github.io/blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] EM算法</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/12/em/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/12/em/</id>
    <published>2018-11-11T17:22:12.000Z</published>
    <updated>2018-11-12T12:08:48.729Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）中EM算法部分的笔记，书上总结得很精炼，有很多细枝末节的东西需要填充。</p><a id="more"></a><hr><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>书中将EM算法总结为估计参数隐变量的方法，它是一种迭代式算法：</p><p>若参数$\Theta$已知，则根据训练数据$D$推断出最优隐变量$Z$；若$Z$的值已知，则可对$\Theta$求极大似然估计。</p><p>步骤简单地可以总结为下面两步：<br>E步：利用当前估计的参数值$\Theta$计算对数似然的期望。</p><p>M步：寻找可以使E步产生的似然期望最大的$\Theta$。</p><p>上面两个步骤交替执行，直至收敛。</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>隐变量指的是“不能被直接观察到，但是对系统的状态和能观察到的输出存在影响的一种东西”[1]，emmm，虽然不知道是什么影响，但是确实有影响。</p><p>[2]给的例子非常生动形象，EM就是在解决一个在不知道是先有鸡还是先有蛋的情况下，求解鸡的进化过程的方法。放到模型里可以理解为我们既不知道模型的参数是什么，也不知道隐变量的值是多少，但是（通常）我们最后希望找到模型的具体参数是多少。</p><p>设存在数据集$D={x_1,x_2,…,x_n}$，已知模型$M$含有隐变量，且样本$x$的似然是$P(x,z;\theta)$. 正常情况我们求解模型参数$\theta$是使用极大似然，也就是求解：<br>$$<br>argmax_\theta\ \prod_{x\in D}P(x,z;\theta)<br>$$<br>取对数得对数似然：<br>$$<br>argmax_\theta \sum_{x\in D}log\ P(x,z;\theta)<br>$$<br>展开隐变量有：<br>$$<br>argmax_\theta \sum_{x\in D}log\ \sum_{i=1}^{n_z}P(x,z_i;\theta)<br>$$<br>希望直接使用求导的方法计算$\theta$和$z$是非常困难的，因为上式中是对一个复合函数的对数求导，非常复杂[2]。</p><p>EM算法的精髓在于使用Jensen不等式对上式进行处理，<br>$$<br>argmax_\theta \sum_{x\in D}log\ \sum_{i=1}^{n_z}P(x,z_i;\theta)<br>$$</p><p>$$<br>=argmax_\theta \sum_{x\in D}log\ \sum_{i=1}^{n_z}Q_i(z_i)\dfrac{P(x,z_i;\theta)}{Q_i(z_i)}<br>$$</p><p>$$<br>\geq argmax_\theta \sum_{x\in D}\sum_{i=1}^{n_z}Q_i(z_i)log\ \dfrac{P(x,z_i;\theta)}{Q_i(z_i)}<br>$$</p><p>于是我们可以把log内的商拆成对数差的形式，把sum套到最外层，会发现这样我们求导非常简单！<br>$$<br>=argmax_\theta \sum_{x\in D}\sum_{i=1}^{n_z}Q_i(z_i)(log\ P(x,z_i;\theta)-log\ Q_i(z_i))<br>$$</p><h5 id="Jensen不等式"><a href="#Jensen不等式" class="headerlink" title="Jensen不等式"></a>Jensen不等式</h5><p>设$f$是定义域为实数的函数，如果对于所有的实数$x$，$f(x)$的二次导数大于等于0，那么$f是$凸函数。当$x$是向量时，如果其Hessian矩阵H是半正定的，那么$f$是凸函数。如果只大于0，不等于0，那么称$f$是严格凸函数。</p><p>Jensen不等式表述如下：</p><p>如果f是凸函数，$X$是随机变量，那么：$E[f(X)]\geq f(E[X])$，特别地，如果$f$是严格凸函数，当且仅当$X$是常量时，上式取等号。</p><p><img src="http://img.my.csdn.net/uploads/201301/24/1359004230_7889.jpg" alt="img"></p><p>图中，实线$f$是凸函数，$X$是随机变量，有0.5的概率是$a$，有0.5的概率是$b$。$X$的期望值就是$a$和$b$的中值了，图中可以看到$E[f(X)]\geq f(E[X])$成立。</p><p><strong>顺便，中国数学界关于函数凹凸性定义和国外很多定义是反的。国内教材中的凹凸，是指曲线，而不是指函数，图像的凹凸与直观感受一致，却与函数的凹凸性相反[3].</strong></p><p>式$\sum_{x\in D}\sum_{i=1}^{n_z}Q_i(z_i)log\ \dfrac{P(x,z_i;\theta)}{Q_i(z_i)}$中$log(·)$是凹函数，那么Jensen不等式符号取反。使用一下Jensen不等式：<br>$$<br>f(E(·)) \geq E[f(·)]<br>$$<br>于是我们知道如何计算带有隐变量分布的极大似然了，我们也就会了EM算法中的M。</p><p>E步骤就简单了，利用初始值或M求出的参数计算隐变量的期望。</p><hr><p>Reference：</p><p>[1]. <a href="https://www.zhihu.com/question/43216440/answer/156368711" target="_blank" rel="noopener">https://www.zhihu.com/question/43216440/answer/156368711</a></p><p>[2]. <a href="https://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8537620</a></p><p>[3]. <a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7/4583322?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7/4583322?fr=aladdin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）中EM算法部分的笔记，书上总结得很精炼，有很多细枝末节的东西需要填充。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] Bayes分类器</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/10/bayes/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/10/bayes/</id>
    <published>2018-11-10T14:08:12.000Z</published>
    <updated>2018-11-12T03:34:44.015Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）的笔记。</p><a id="more"></a><hr><h2 id="贝叶斯决策论"><a href="#贝叶斯决策论" class="headerlink" title="贝叶斯决策论"></a>贝叶斯决策论</h2><p>使用贝叶斯决策论解决问题时的目标实际上是“最小化总体风险”，可以形式化表示成下式：<br>$$<br>R(c_i|x)=\sum_{j=1}^{n}\lambda_{ij}P(c_j|x)<br>$$<br>$\lambda_{ij}$：$i$类误分类成$j$类的代价。</p><p>$P(c_i|x)$：样本$x$分类成$c_i$的概率。</p><p>贝叶斯决策论希望找到一个最小化总体风险的判别准则$h(x)$，对于分类任务则是一个分类准则（$h(x)$表示将$x$归类为$h(x)$类），使得上述总体风险最小：<br>$$<br>h(x)=\mbox{argmin}\ R(c|x)<br>$$</p><hr><h2 id="贝叶斯准则"><a href="#贝叶斯准则" class="headerlink" title="贝叶斯准则"></a>贝叶斯准则</h2><p>贝叶斯准则可以简单理解为“整体风险最小化=每个样本的风险最小化”，风险指的是（比如在分类问题中）被分成错误类的期望。</p><p>能够使用贝叶斯准则的前提是获得后验概率$P(c|x)$，贝叶斯分类器此类生成模型则会考虑使用贝叶斯定理来求解这个后验概率：<br>$$<br>P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}<br>$$<br>解释一下公式中的每一个量的意义：</p><p>$P(c|x)$：<strong>后验概率</strong>，认为$x$分类成$c$的概率。</p><p>$P(c)$：<strong>先验概率</strong>，从公式上直观上看就是“偏见”、“第一眼看到这个人就觉得他是坏人”这样的概率。</p><p>$P(x|c)$：$x$相对于$c$的类条件概率，也称<strong>似然</strong>。指的是已知某些观测所得到结果（类别是$c$）时，对有关事物的性质（恰好是样本$x$）的参数进行估计[1]。</p><p>$P(x)$：用于归一化的因子，$P(x)=\sum_{i=1}^{n}P(x|c=i)P(c=i)$.</p><p>贝叶斯定理实际上就是希望通过已知相当数量的训练数据集合$D$，我们希望找到一个合理的方法来估计$D$中的$P(c)$和$P(x|c)$：</p><p>我们假设训练集中的训练数据独立同分布，那么根据大数定律，$P(c)$可以用每一类样本的<strong>频率</strong>来估计。</p><p>$P(x|c)$很难使用频率估计，因为$D$中的样本$x$通常无法完全覆盖所有情况：未被数据集覆盖$\not=$出现概率为0。于是需要使用<strong>极大似然估计</strong>.</p><hr><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计(MLE)"></a>极大似然估计(MLE)</h2><p>书中首先在介绍Logistic回归的时候使用了MLE（对数似然），但是没有仔细介绍。</p><p>首先假设数据集符合某种概率分布$D(\theta_c)$，被分成不同类完全取决于参数向量$\theta_c$.训练模型的过程就是参数估计的过程。</p><p>极大似然估计（MLE）就是一种参数估计方法，估计方法完全写在名字里了：似然（$P(x|c)$）极大化。由于分类结果完全取决于$\theta_c$，因此这个似然可以表示成$P(x|\theta_c)$.介绍贝叶斯准则的时候也讲了，“整体风险最小化=每个样本的风险最小化”。因此$\theta_c$对于整个数据集$D​$的似然就是：<br>$$<br>P(D|\theta_c)=\prod_{x\in D}P(x|\theta_c)<br>$$<br>我们给它取对数（因为小数连乘会导致精度损失）：<br>$$<br>L(\theta_c)=logP(D|\theta_c)=\sum_{x\in D}\mbox{log}P(x|\theta_c)<br>$$<br>我们对$\theta_c$的估计为：<br>$$<br>\hat{\theta_c}=\mbox{argmax}_{\theta_c}L(\theta_c)<br>$$<br>分析到这里这个式子已经展不开了，因为每个样本具体的似然取决于<strong>我们假设的是哪个分布</strong>，比如概率密度函数服从正态分布$\N(\mu_c,\sigma^2_c)$，那么对于它的参数$\mu_c$和$\sigma_c^2$的极大似然估计分别为数据集的均值$\dfrac{\sum_{x\in D}x}{|D|}$和方差$\dfrac{\sum_{x\in D}(x-\hat{\mu_c})^2}{|D|}$。</p><p>（然而我认为通常这么随意假设数据分布是不科学的= =）</p><hr><h2 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h2><p>由于$P(x|c)$是所有属性的联合概率，难以估计属性之间的关系，为了避免计算上的问题，引入属性条件独立性假设。</p><p>属性条件独立性假设：假设所有属性（理解：样本$x$中的每一维）相互独立。</p><p>于是$P(c|x)$重写为：<br>$$<br>P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}=\dfrac{P(c)}{P(x)}\sum_{i=1}^dP(x_i|c)<br>$$<br>$d$为属性数，$x_i$为样本$x$在第$i$个属性的取值。对于每个类$c$，$P(x)$都一样。在计算过程中可以忽略，于是：<br>$$<br>h(x)=\mbox{argmin}\ R(c|x)<br>$$</p><p>$$<br>=\mbox{argmax}\ P(c|x)<br>$$</p><p>$$<br>=\mbox{argmax}\ P(c)\prod_{i=1}^dP(x_i|c)<br>$$</p><p>$P(c)$：可以由每类的样本出现<strong>频率</strong>获得。</p><p>$P(x_i|c)$：针对离散的情况，可以根据类别是$c$并且含有属性$x_i$的出现<strong>频率</strong>获得；针对连续的情况，用密度函数。</p><p>一句话：于是计算贝叶斯实际上就是算两个量：$P(c)$和$P(x_i|c)$，按照两个量对应样本的<strong>频率</strong>获得一个概率，然后再用$h(x)$的计算方法乘出不同属性对应不同分类的极大似然估计即可。</p><hr><h2 id="缺省值处理"><a href="#缺省值处理" class="headerlink" title="缺省值处理"></a>缺省值处理</h2><p>有时会遇到某个样本某个属性缺失的情况，但是又不至于将该样本删除，于是需要进行平滑处理。拉普拉斯修正。</p><hr><h2 id="半朴素贝叶斯"><a href="#半朴素贝叶斯" class="headerlink" title="半朴素贝叶斯"></a>半朴素贝叶斯</h2><p>适当考虑部分属性的相互依赖信息，半朴素贝叶斯使用<strong>“独依赖估计”</strong>，即每个属性至多依赖于一个其他属性。<br>$$<br>P(c|x) \propto P(c)\prod_{i=1}^dP(x_i|c_,pa_i)<br>$$<br>$pa_i$：$x_i$所依赖的属性（$x_i$的父属性），计算过程就是将任意两个属性之间的依赖信息$I(x_i,x_j)$为边权建图，跑最大生成树。</p><hr><h2 id="贝叶斯网"><a href="#贝叶斯网" class="headerlink" title="贝叶斯网"></a>贝叶斯网</h2><p>贝叶斯网是个有向无环图，用点表示属性，权值为属性发生的概率，边表示依赖关系，边权为条件概率。例如$A$有一条指向$B$的边，点权描述的是$P(A)$、$P(B)$，这条边的权描述的就是$P(B|A)$. 没有边相连的两个点之间是相互独立的。</p><p>有一个笔记[2]中的例子非常形象地描述了相互独立的性质：</p><p>一个聪明人，在一场很难的考试里拿了高分，却得到了一封很烂的推荐信，同时他SAT考试却是高分的概率是多少？</p><p>我们再隐藏一些细节，一个人推荐信很烂，他SAT高分的概率是多少？或者，一个人SAT低分，却手握牛推的概率是多少？</p><p>如果不考虑随机变量之间的依赖关系，上述内容是很难计算的。但是如果有一个构建好的概率图，上面的问题则可以转化为条件概率问题。</p><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>已知网络结构的话，那么贝叶斯网上的各种信息是很容易统计的，按照网络要求和训练数据统计不同<strong>频率</strong>即可。</p><p>若网络结构未知，将贝叶斯网的学习看作是一个数据压缩任务，目标是<strong>学习到一个能以最短编码长度描述训练数据的模型</strong>。定义评分函数：<br>$$<br>s(B|D)=f(\theta)|B|-L(B|D)<br>$$<br>s(B|D)：在数据集$D$条件下的贝叶斯网$B$的评分函数。</p><p>$|B|$：贝叶斯网的参数个数。</p><p>$f(\theta)$：描述每个参数$\theta$所需字节数</p><p>$L(B|D)$：贝叶斯网的对数似然。</p><p>我们最终的目的是寻找一个$B$使$s$(B|D)最小，$f(\theta)$可以取1或者$\dfrac{1}{2}\mbox{log}\ m$，分别称为AIC和BIC。</p><h4 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h4><p>不能直接根据贝叶斯网定义的联合概率分布来计算后验概率，因为网络节点多的稠密图推理是NP-hard的。于是可以借助<strong>近似推断</strong>，常用Gibbs采样完成，先跳过了= =、</p><hr><p>Reference：</p><p>[1]. <a href="https://blog.csdn.net/lwq1026/article/details/70161857" target="_blank" rel="noopener">https://blog.csdn.net/lwq1026/article/details/70161857</a></p><p>[2].  <a href="https://www.cnblogs.com/ironstark/p/5087081.html" target="_blank" rel="noopener">https://www.cnblogs.com/ironstark/p/5087081.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] Bias-Variance Dilemma</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/05/BiasVarianceTradeoff/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/05/BiasVarianceTradeoff/</id>
    <published>2018-11-05T04:08:12.000Z</published>
    <updated>2018-11-08T14:26:18.237Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Deliberate Practice$\ ^{[1]}$：to identify your weakest areas and direct a massive effort on improving those areas without worrying about areas in which you are already good.</strong></p><p>这是我在阅读西瓜书第二章时的一个遗留问题，是关于偏差-方差窘境（Bias-Variance Dilemma）的内容。</p><a id="more"></a><p>首先要解释Bias-Variance Tradeoff，也就是偏差-方差权衡，譬如当前有一个拟合任务，需要构造一个多项式函数去拟合它，函数可以构造成这样：<br>$$<br>y=a_0+a_1x+a_2x^2+…+a_nx^n<br>$$<br>如何确定$n$的大小就是一个偏差-方差的权衡问题，。图像上直观地看则是为了确定这条曲线的“弯曲程度”。</p><p>曲线拟合和机器学习：前者是利用数据尽可能地拟合出一条完美的曲线；后者则是在有限的数据规模内进行学习，目的是遇到未知数据时能够做出最好的判断。</p><p>模型的泛化能力可以由泛化误差来描述，泛化误差越小，模型的期望泛化能力越强。模型$f$在数据集$D$上的泛化误差可以分解为偏差$bias$、方差$var$、噪声$\epsilon$之和：<br>$$<br>E(f;D)=\mbox{bias}^2(x)+\mbox{var}(x)+\epsilon^2<br>$$<br>递推可以在西瓜书P45翻到。</p><p>噪声指的是学习算法本身固有的误差（系统误差）和数据集的噪声。当保证数据集十分纯净的时候，人为可控的部分就只有偏差和方差了。于是机器学习中存在偏差-方差窘境：<strong>偏差(bias)描述的是模型的拟合能力，偏差过大可以认为是欠拟合；方差(variance)则描述的是数据集的情况，方差过大可以认为是在数据集上过拟合。</strong>二者无法同时达到最小，只能取一个平衡点。    </p><p>总结一下特点：</p><ul><li>高偏差的模型：训练集的错误率高，验证集和训练集的错误率类似。</li><li>高方差的模型：训练集错误率低，验证集高。</li></ul><p>下图描述了一些简单的处理方法：<br><img src="https://www.learnopencv.com/wp-content/uploads/2017/02/Machine-Learning-Workflow.png" alt="img"></p><hr><p><strong>Reference</strong></p><p>[1]. <a href="https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/" target="_blank" rel="noopener">https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Deliberate Practice$\ ^{[1]}$：to identify your weakest areas and direct a massive effort on improving those areas without worrying about areas in which you are already good.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是我在阅读西瓜书第二章时的一个遗留问题，是关于偏差-方差窘境（Bias-Variance Dilemma）的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 决策树</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/04/decision_tree/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/04/decision_tree/</id>
    <published>2018-11-04T07:08:12.000Z</published>
    <updated>2018-11-04T16:25:40.294Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第四章（决策树）的笔记，因为决策树是比较简单的算法，没有什么数学公式的推导，书中也是简单介绍了下信息熵的定义。</p><p>简单总结一下这一章的要点：</p><p>这一章介绍决策树，决策树的特点就是每一个节点作为一个选择分支，用于判断某一个样本是否含有这个属性。</p><p>决策树是递归定义的，因此属性个数理论上讲可以是无限多个。</p><p>在选择某个节点的代表属性时，引入利用信息增益为准则的ID3、C4.5和CART算法，这是三种较为类似的决策树的学习算法。</p><p>为了防止过拟合，还对决策树使用了剪枝操作。</p><p>处理连续值的方法是离散化后设定划分点。</p><p>遇到缺失值时利用无缺失的值进行估计，计算对应的信息增益再进行划分。</p><p>决策树的每一个节点还可以考虑不止一个属性，譬如使用多个属性值的线性组合的形式（多变量决策树），即允许存在斜的划分边界。甚至可以在每一个节点放一个感知机（感知机树）。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第四章（决策树）的笔记，因为决策树是比较简单的算法，没有什么数学公式的推导，书中也是简单介绍了下信息熵的定义。&lt;/p&gt;
&lt;p&gt;简单总结一下这一章的要点：&lt;/p&gt;
&lt;p&gt;这一章介绍决策树，决策树的特点就是每一个节点作为一个选择分支，用于判断某一个样本是否含有这个属性。&lt;/p&gt;
&lt;p&gt;决策树是递归定义的，因此属性个数理论上讲可以是无限多个。&lt;/p&gt;
&lt;p&gt;在选择某个节点的代表属性时，引入利用信息增益为准则的ID3、C4.5和CART算法，这是三种较为类似的决策树的学习算法。&lt;/p&gt;
&lt;p&gt;为了防止过拟合，还对决策树使用了剪枝操作。&lt;/p&gt;
&lt;p&gt;处理连续值的方法是离散化后设定划分点。&lt;/p&gt;
&lt;p&gt;遇到缺失值时利用无缺失的值进行估计，计算对应的信息增益再进行划分。&lt;/p&gt;
&lt;p&gt;决策树的每一个节点还可以考虑不止一个属性，譬如使用多个属性值的线性组合的形式（多变量决策树），即允许存在斜的划分边界。甚至可以在每一个节点放一个感知机（感知机树）。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 线性判别分析：LDA</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/04/lda/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/04/lda/</id>
    <published>2018-11-03T16:50:10.000Z</published>
    <updated>2018-11-03T17:57:44.442Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线性判别分析（Linear Discriminant Analysis, LDA）又称Fisher判别分析，是一种数据降维的方法，主要思想是使属于同一类的投影点距离尽可能地接近（类内方差小），不同类的中心点距离尽可能地远（类间中点距离大）。</strong></p><a id="more"></a><p>LDA就是模识课上黄老板讲的Fisher判别，名字不同而已。思想也很简单，计算也不复杂。首先定义一些变量：<br>$$<br>x_i：i类数据的训练样本<br>$$</p><p>$$<br>\mu_i：i类数据的均值向量<br>$$</p><p>$$<br>\Sigma_i：i类数据的协方差矩阵<br>$$</p><p>投影到直线$w$上后，样本中心（均值）所在的投影就变为$w^T\mu_i$，协方差变为$w^T\Sigma_i w$，推一下协方差：</p><p>展开协方差的定义：$\Sigma_i=\sum_{j=1}^n(x_j-u_i)^2$</p><p>变换后的协方差定义：$\Sigma’<em>i=\sum</em>{j=1}^n(w^Tx_j-w^Tu_i)^2$</p><p>则有：<br>$$<br>\Sigma’<em>i=\sum</em>{j=1}^n(w^Tx_j-w^Tu_i)^2=\sum_{j=1}^n(w^T(x_j-u_i))^2<br>$$</p><p>$$<br>=\sum_{j=1}^nw^T(x_j-u_i)(w^T(x_j-u_i))^T<br>$$</p><p>$$<br>=\sum_{j=1}^nw^T(x_j-u_i)(x_j-u_i)^Tw<br>$$</p><p>$$<br>=w^T\sum_{j=1}^n(x_j-u_i)^2w<br>$$</p><p>$$<br>=w^T\Sigma_iw<br>$$</p><p>用变换后的协方差作为衡量类内点的“集中”程度，我们尽可能想让这个值小。于是第一个目标可以用这个值逼近。</p><p>为了叙述方便，现在假设分类任务是二分类，分别是0、1类。第二个目标类间距离可以直接比较类内中点之间的距离测度，定义类间距为中点的Euclidean Distance平方：$Dis(0,1)=|w^T\mu_0-w^T\mu_1|^2$来衡量。我们希望这个值尽可能大</p><p>定义：$S_w’=\Sigma’_0+\Sigma’_1$，$S_b’=Dis(0,1)$。</p><p>同时考虑上述两个指标，于是做商合成一个目标函数（突然想起自己的paper里也搞过这种设计）：<br>$$<br>J=\dfrac{S_b’}{S_w’}=\dfrac{|w^T\mu_0w-w^T\mu_1|^2}{w^T\Sigma_0w+w^T\Sigma_1w}<br>$$</p><p>$$<br>=\dfrac{w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w}<br>$$</p><p>目标即为通过调整$w$最大化$J$，$S’_b$和$S’_w$的比值称为“广义瑞利商”。由于分子和分布都是关于$w$的二次项，因此解只与$w$的方向有关。方程等价于优化下式：<br>$$<br>\min_w -w^TS’_bw<br>$$</p><p>$$<br>st.\ w^TS’_ww=1<br>$$</p><p>这是个带约束的极值求解问题，可以用高数中学过的拉格朗日乘数法解决，构造拉格朗日函数：<br>$$<br>L(w)=-w^TS’_bw+\lambda(w^TS’_ww-1)<br>$$<br>令上式的导数得0，即可得：<br>$$<br>w=S_w’^{-1}(\mu_0-\mu_1)<br>$$<br>问题转换成求解$S’_w$的逆。注意该阵通常情况下不可逆，原因是数据维数和数据条目数通常是不匹配，就是说数据集并不能确定地体现数据的分布情况。</p><p>书上介绍的实际是PCA方法，直接给$S’_w$进行SVD分解，得到$S’_w=U\Sigma V^T$，于是$S_w’^{-1}=(U\Sigma V^T)^{-1}=V\Sigma^{-1}U^T$。</p><p>最终我们可推得：<br>$$<br>w=V\Sigma^{-1}U^T(\mu_0-\mu_1)<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线性判别分析（Linear Discriminant Analysis, LDA）又称Fisher判别分析，是一种数据降维的方法，主要思想是使属于同一类的投影点距离尽可能地接近（类内方差小），不同类的中心点距离尽可能地远（类间中点距离大）。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 线性模型、Logistic回归</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/03/logistic/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/03/logistic/</id>
    <published>2018-11-03T15:39:00.000Z</published>
    <updated>2018-11-03T17:56:27.818Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授的《机器学习》中关于Logistic回归部分的笔记（在模识老师的安利下，最终还是买了西瓜书）。</p><p><strong>Logistic回归音译为“逻辑回归”实在是太蠢了。</strong></p><a id="more"></a><p>Logistic回归是西瓜书第三章“线性模型”中的内容，首先总结一下在logistic回归之前的知识点。</p><p>所谓线性回归就是定义一个线性函数$f(x)=w^Tx+b$，经过在一个特定数据集上学习后获得参数$w$和$b$的过程。通常需要搭配优化算法使用，例如最小二乘法、梯度下降法、牛顿法、拟牛顿法$^{[1,2]}$等，我将它们的特点总结如下：</p><p>最小二乘法：希望找到一条n维空间上的直线，使得所有数据点到这条线上的欧几里德距离最短（均方差误差最小），因为均方误差损失函数是凸的，所以最小二乘法直接对该损失函数关于$w$和$b$进行求导。</p><p>梯度下降法：这是一种迭代求解最优的算法，方法就是将参数沿着梯度负方向更新。这种算法经常陷入局部最优，而且速度未必快。有很多延伸的优化，比如随机梯度下降、带惯性的梯度下降等。</p><p>牛顿法：对拟合目标函数泰勒展开后求导后迭代，需要计算任意两个变量的二阶偏导的逆（海森矩阵的逆）所以计算复杂度高，但是收敛快。过程一图以蔽之：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif" alt="img"></p><p>拟牛顿法：添加了步长的牛顿法。</p><p>但是通常的拟合任务并非是线性的，数据可能是符合某种非线性函数的变化（例如指数），因此有了对数线性回归（log-linear regression）。由于自变量的变化还是$w^Tx+b$，因此还属于线性回归模型。更一般的形式如下：<br>$$<br>g(y)=w^Tx+b<br>$$<br>$$<br>y=g^{-1}(w^Tx+b)<br>$$</p><p>此处$g(\cdot)$是一个非线性函数，这个函数需要“<strong>连续且充分光滑</strong>”。</p><p>分类任务和回归任务最大的区别是，分类需要一个hard-label，而回归通常是一个实数值的soft-label（hard-label和soft-label是我自己起的）。想用回归的方法进行分类，则需要有一个soft-&gt;hard的映射函数。</p><p>可以手动设阈值（阶跃，就是分段函数），但是不满足作为$g(\cdot)$需要的充分条件。于是有人构造了更加光滑的logistic function（对数几率函数）：<br>$$<br>y=\dfrac{1}{1+e^{-z}}<br>$$<br>这是一种sigmoid函数：形似S的函数。我们想表示成$g(y)=w^Tx+b$的形式，可以推：<br>$$<br>y=\dfrac{1}{1+e^{-z}}<br>$$<br>$$<br>y+ye^{-z}=1<br>$$</p><p>$$<br>\dfrac{1-y}{y}=e^{-z}<br>$$</p><p>$$<br>\ln\dfrac{1-y}{y}=-z<br>$$</p><p>$$<br>\ln\dfrac{y}{1-y}=z<br>$$</p><p>其中$z=w^Tx+b$，$y$和$1-y$分别可看作是正反例的可能性（logits），二者的比值取对数称为“对数几率 ”。通常写作：<br>$$<br>\ln\dfrac{p(y=1|x)}{p(y=0|x)}=z<br>$$<br>有：<br>$$<br>p(y=1|x)=\dfrac{e^{z}}{1+e^z}<br>$$<br>由于$p(y=0|x)=1-p(y=1|x)$，则：<br>$$<br>p(y=0|x)=\dfrac{1}{1+e^z}<br>$$<br>使用极大似然估计$w$和$b$，构造损失函数$l(w,b)=\sum_{i=1}^{m}\ln p(y_i|x_i;w,b)$，最大化该函数，整理一下就能得到loss函数的形式，之后就能用上述的最优化算法求它的最优解了。</p><p><strong>Reference</strong></p><p>[1]. <a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixiangwan/p/7532830.html</a></p><p>[2]. <a href="https://www.cnblogs.com/xiaohuahua108/p/6011105.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuahua108/p/6011105.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授的《机器学习》中关于Logistic回归部分的笔记（在模识老师的安利下，最终还是买了西瓜书）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Logistic回归音译为“逻辑回归”实在是太蠢了。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] Neural Networks and Deep Learning Chapter 2</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/29/nndl_ch2/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/29/nndl_ch2/</id>
    <published>2018-10-29T14:28:00.000Z</published>
    <updated>2018-11-04T15:03:58.621Z</updated>
    
    <content type="html"><![CDATA[<p>这是我阅读在线书籍《Neural Networks and Deep Learning》第二章的笔记。</p><p>手残不小心把整个笔记的文件夹误删了，原来这种事是真的会发生的啊，还好对第一章笔记做了备份= =、</p><p>章节链接： <a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap2.html</a></p><a id="more"></a><p>尽力恢复车祸现场。。</p><p>先给出一堆变量定义（图来自知乎<a href="https://zhuanlan.zhihu.com/p/26765585）：" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26765585）：</a></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/gsddyyyy.png" alt="img"></p><hr><p>在”The four fundamental equations behind backpropagation”之前，主要介绍了一个化简前馈表示的方法：$a^{l} = \sigma(w^l a^{l-1}+b^l)$。</p><p>还有两个一个函数允许作为损失函数的两个条件：1. 必须是以网络输出作为参数；2. 损失函数必须写成多个独立样本的损失的和的形式。</p><p>以及介绍了哈达玛积（Hadamard product）：$(s \odot t)_j = s_j t_j$，就是对应项相乘，例：<br>$$<br>\left[\begin{array}{c} 1 \ 2 \end{array}\right]<br>  \odot \left[\begin{array}{c} 3 \ 4\end{array} \right]<br>= \left[ \begin{array}{c} 1 <em> 3 \ 2 </em> 4 \end{array} \right]<br>= \left[ \begin{array}{c} 3 \ 8 \end{array} \right]<br>$$</p><hr><h3 id="The-four-fundamental-equations-behind-backpropagation"><a href="#The-four-fundamental-equations-behind-backpropagation" class="headerlink" title="The four fundamental equations behind backpropagation"></a><strong>The four fundamental equations behind backpropagation</strong></h3><p>反向传播会计算出$\delta_j^l$，表示为第$l$层的第$j$个神经元的误差。</p><p>定义：$\delta^l_j = \frac{\partial  C}{\partial z^l_j}$，$z_j^l$为第$l$层的第$j$个神经元的加权输入结果。反向传播的目标就是计算每一层的$\delta^l$，称之为measure of error。反向传播总的来说是4个方程。</p><p><strong>words</strong></p><ol><li>intermediate：中间的</li><li>messes with：由于……而迷糊</li><li>perturb：扰乱</li></ol><hr><p>首先看看最后一层的损失如何计算：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)<br>$$<br>$\partial C/\partial a_j^L$用于描述作为第$j$个激活函数的输出变化有多快，如果$C$不依赖于这个神经元，那么$\delta_j^L$会比较小（接近收敛）。后面的$\sigma$的导数表示激活函数在这个点的变化有多快。</p><p>这个式子的计算瓶颈在于这个偏导数，于是转换成了下面的形式：<br>$$<br>\delta^L = (a^L-y) \odot \sigma’(z^L)<br>$$<br>$a^L-y$是$C$的变化率，就是个$\Delta$，拆开后就写成上面哈达玛积的形式了。</p><p>再次重申，$\delta^L$表示的是第$L$层（也就是最后一层）的传播误差。<strong>for the error in the output layer</strong>。</p><p>接着看看隐层的传播如何计算：<br>$$<br>\delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l)<br>$$<br>式子中很明显，$l$层的误差就是由下一层（$l+1$层）反传回去的。</p><p>关于对$w^{l+1}$参数矩阵求转置：我是这么理解的，因为输出的时候$l$层用的是$n \times m$的矩阵，想要传回去的话，下层的size就不能是$n\times m$了，而是$m\times n$。转置和下一层的误差相乘，可以把误差传回对应的神经元。</p><p>网络中偏差（bias）的损失的计算：<br>$$<br>\frac{\partial C}{\partial b^l_j} =  \delta^l_j<br>$$<br>模型直接可以用该层的损失来更新某个神经元的bias，于是可以简写：$\partial C / \partial b=\delta$。</p><p>网络中权重的损失的计算：<br>$$<br>\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j<br>$$<br>某层某个神经元的输入乘以该神经元的偏差可以认为是这个神经元对于最终损失的影响值。简写为：$\frac{\partial<br>​    C}{\partial w} = a_{\rm in} \delta_{\rm out}$。</p><p>总结四个BP的关键等式：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz21.png" alt="img"></p><p>下面对每一个等式进行证明，加深理解。</p><hr><p>证明主要分两个部分：</p><p>第一部分是推导出反向传播损失函数和输出之间的关系（BP1 BP2）</p><p>第二部分是推导出损失函数与权重weight和偏差bias的关系（BP3 BP4）</p><p><strong>BP1：</strong><br>$$<br>\delta^L = \nabla_aC \odot \sigma’(z^L)<br>$$<br>证：对于第$j$个激活函数，有定义：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial z^L_j}<br>$$<br>展开：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)=\dfrac{\part C}{\part a_j^L}\dfrac{\part a_j^L}{\part z_j^L}<br>$$<br>由于$a_j^L=\sigma(z_j^L)$，那么$\sigma’(z_j^L)=\dfrac{\partial a_j^L}{\partial z_j^L}$，即：$\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)$</p><p>推广至$L$层，公式可简写为：<br>$$<br>\delta^L = \frac{\partial C}{\partial a^L} \sigma’(z^L)<br>$$</p><p><strong>BP2：</strong><br>$$<br>\delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l)<br>$$<br>证：由定义展开$\delta^l$：<br>$$<br>\delta^l = \frac{\partial C}{\partial z^l}<br>$$<br>利用导数的链式法则，对拆成对$z^{l+1}$求导的形式：<br>$$<br>\delta^l = \dfrac{\partial C}{\partial z^{l+1}}\dfrac{\part z^{l+1}}{\part z^{l}}=\dfrac{\partial z^{l+1}}{\partial z^{l}}\delta^{l+1}<br>$$<br>由于$z^{l+1}=\sum_jw_{j}^{l+1}\delta^l(z_{j}^{l+1})+b^{l+1}$，带入上式即证。</p><p><strong>BP3：</strong><br>$$<br>\frac{\partial C}{\partial b^l_j} =  \delta^l_j<br>$$<br>证：<br>$$<br>\frac{\partial C}{\partial b^l_j} =  \frac{\part C}{\part z^{l+1}_j}\frac{\part z^{l+1}_j}{\part b_j^l}=\delta_j^l\frac{\part(w^l_jz^l+b^l_j)}{\part b_j^l}=\delta_j^l<br>$$<br><strong>BP4：</strong></p><p>和上面一样，把$b$换成$w$就行。</p><hr><h3 id="The-backpropagation-algorithm"><a href="#The-backpropagation-algorithm" class="headerlink" title="The backpropagation algorithm"></a><strong>The backpropagation algorithm</strong></h3><p>利用上面证明过的4个结论，就可以推导出反向传播算法，算法可以递归形式地定义成这样：</p><ol><li>输入$x$</li><li>前馈：$z^l=w^la^{l-1}+b^l，夏日难a^l=\sigma(z^l)$</li><li>输出误差：$\delta^L = \nabla_aC \odot \sigma’(z^L)$</li><li>反向传播误差：对于每一层$l,l=L-1,L-2…,2$，于是$\delta^l=((w^{l+1})^T\delta^{l+1})\odot \sigma’(z^l)$</li><li>输出：$w,b$的损失函数定义为$\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j$和$\frac{\partial C}{\partial b^l_j} = \delta^l_j$。</li><li>$\frac{\partial  C}{\partial  b^l_j} = \delta^l_j$。</li></ol><hr><h3 id="The-code-for-backpropagation"><a href="#The-code-for-backpropagation" class="headerlink" title="The code for backpropagation"></a><strong>The code for backpropagation</strong></h3><p>这章实现了用SGD训练的的BP：每次叠小批量的训练集，再计算损失后反传。</p><p>介绍了一个可以同时计算多个mini-batch的trick：把多个mini-batch放到一个矩阵里，利用矩阵计算库对矩阵计算的优化来加速训练。</p><hr><h3 id="In-what-sense-is-backpropagation-a-fast-algorithm"><a href="#In-what-sense-is-backpropagation-a-fast-algorithm" class="headerlink" title="In what sense is backpropagation a fast algorithm?"></a><strong>In what sense is backpropagation a fast algorithm?</strong></h3><p>想在求偏导这一步加速梯度下降的计算，考虑利用$\dfrac{\partial C}{\partial w_j}\approx \dfrac{C(w+\epsilon e_j)-C(w)}{\epsilon}$这样近的似来代替计算偏导，当$\epsilon$很小的时候，起码GD方向是不会变的（$\epsilon$很小的话，多叠几次就可以近似等价于梯度方向走步长步）。但是实际上这样做的计算开销仍然会非常大。</p><p>而反向传播可以<strong>DP</strong>地把损失传回去。</p><hr><h3 id="Backpropagation-the-big-picture"><a href="#Backpropagation-the-big-picture" class="headerlink" title="Backpropagation: the big picture"></a><strong>Backpropagation: the big picture</strong></h3><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz25.png" alt="img"></p><p>对于每层输出产生的误差$\Delta a_j^l$，可以用下式做近似：<br>$$<br>\Delta a^l_j \approx \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>那么对于这层而言其中一条由输出反传回来的结果则是：<br>$$<br>\Delta C \approx \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>于是考虑所有连通的情况：<br>$$<br>\Delta C \approx \sum_{mnp\ldots q} \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>这就是反向传播对于某一条边更新时需要的计算：<br>$$<br>\frac{\partial C}{\partial w^l_{jk}} = \sum_{mnp\ldots q} \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我阅读在线书籍《Neural Networks and Deep Learning》第二章的笔记。&lt;/p&gt;
&lt;p&gt;手残不小心把整个笔记的文件夹误删了，原来这种事是真的会发生的啊，还好对第一章笔记做了备份= =、&lt;/p&gt;
&lt;p&gt;章节链接： &lt;a href=&quot;http://neuralnetworksanddeeplearning.com/chap2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://neuralnetworksanddeeplearning.com/chap2.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Deep Learning" scheme="https://vincentxwd.github.io/blog/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>The Last Samurai</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/28/the-last-samurai/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/28/the-last-samurai/</id>
    <published>2018-10-28T14:23:05.000Z</published>
    <updated>2018-10-28T16:29:17.022Z</updated>
    
    <content type="html"><![CDATA[<p>I watched a movie named “the last samurai” today: almost after some paper’s deadline. Actually I have watched it when I graduated from my high school. I was impressed by their fearless spirit and extremely focusing.</p><a id="more"></a><p>The story happened at the end of the 19th century, during the Southwest War and the Meiji Restoration of Japan. A drunken hero who participated in the American Civil War was invited by Japanese Reformers to train the new recruits of the Shogunate（幕府）Army. However, he was captured by the anti-Shogunate（倒幕派）to a small village in a battle. He was influenced by their really Bushido spirit and become a warrior of old and new ways(今古有神奉志士，就是融汇古今的武士).</p><p>There are many places worth roasting. For instance, samurais have a tradition of using firearms. But this movie shows they are just using samurai swords and bows. So many examples like this, but they don’t hinder this masterpiece to become one of my favorite movies.</p><p>I love Japanese anime so much and I’m also interested in Japanese traditional culture (in spite of I only know about it in some films). I’m yearning for the life with peace and warm. People in that time can focus on something in a long period, enjoy the process of doing only one thing to the extreme. That maybe is called Craftsmanship(工匠精神). Aside from the historical factors of Japan at that time, this spirit is also worth learning.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai1.png" alt="img"></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai2.png" alt="img"></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai3.png" alt="img"></p><p>The film section that I love the best is in the village, Algren saw the villagers were doing their own things with their heart and soul as if there was a discipline that cannot be seen. When Algren was learning how to battle with Samurai sword but always beaten by Ujio. Then he was told by Higen that he had “too many minds”. That means Algren shouldn’t think too much except defeating his enemy.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai4.png" alt="img"></p><p>I think the essence of Craftsmanship spirit is “no mind”, means without too many distracting thoughts and just focus on the moment now.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai5.png" alt="img"></p><p>I’m very lacking in this spirit. I was always disturbed by many things. Maybe that is the reason why I cannot do anything better. Although there is a huge contrast between that time and the times I am in now and the requirements for people are getting higher,  it cannot become the reason of inattention. I should learn how to abandon distracting thoughts and focus on one thing. For me, I think the main source of disturbing is from the Internet. Maybe I should close my QQ and WeChat when I’m doing something that needs “no mind”.</p><p>I talked about some small things above. But what if some big things. I was always hearing something interesting and turning to explore that thing. Then I’ll do nothing at the end. That is called “ to put away the cup after taking a tiny sip”(浅尝辄止).  The reason for this phenomenon is having too many minds. I always want to grasp anything but it is not realistic because human has limited energy.</p><p>I’m sure I have to throw away so many minds and focus on something I think is the most worthy.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I watched a movie named “the last samurai” today: almost after some paper’s deadline. Actually I have watched it when I graduated from my high school. I was impressed by their fearless spirit and extremely focusing.&lt;/p&gt;
    
    </summary>
    
      <category term="只言片语" scheme="https://vincentxwd.github.io/blog/categories/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>[Codeforces517D] Minimum path (DP, 贪心, 搜索)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/28/CF1072D/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/28/CF1072D/</id>
    <published>2018-10-28T06:06:16.000Z</published>
    <updated>2018-10-28T06:21:59.927Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1072/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1072/problem/D</a></p><p>给一个$n\times n$的字母阵，允许修改其中的$k$个字符，问从$(1,1)$走到$(n,n)$字典序最小的字符串。</p><a id="more"></a><p>如果不考虑替换的话，字典序最小的字符串可以由BFS得到。</p><p>如果考虑替换的话，首先知道替换掉的字符肯定都会把不是’a’的换成’a’。</p><p>接下来考虑DP，维护$dp(i,j)$为走到$(i,j)$处最多的’a’数量，这里不考虑$k$次替换。</p><p>由于是字典序最小，那么我们知道越早替换成’a’字典序一定是最小的，因此我们就确定了贪心地替换前面扫描的非’a’字符这样一个转移的无后效性。</p><p>DP转移可以这样：<br>$$<br>dp(i,j)=max(dp(i-1,j),dp(i,j-1))+(G(i,j)==’a’)<br>$$<br>接着考虑是否有足够的替换次数，于是存在$i+j-1-dp(i,j)$个待替换的非’a’字符，显然都替换掉字典序是最小的，于是我们拿这个和$k$比一下就可以确定当前字符$G(i,j)$是否需要替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> G[maxn][maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;pii&gt; pq;</span><br><span class="line"><span class="keyword">int</span> p[maxn][maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ret;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">    reverse(ret.begin(), ret.end());</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ok(x<span class="number">-1</span>,y)&amp;&amp;p[x<span class="number">-1</span>][y]) &#123;</span><br><span class="line">    ret.push_back(G[x<span class="number">-1</span>][y]);</span><br><span class="line">    dfs(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">    ret.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ok(x,y<span class="number">-1</span>)&amp;&amp;p[x][y<span class="number">-1</span>]) &#123;</span><br><span class="line">    ret.push_back(G[x][y<span class="number">-1</span>]);</span><br><span class="line">    dfs(x,y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">    ret.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="built_in">memset</span>(dp ,<span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + (G[i][j] == <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">if</span>(i + j - <span class="number">1</span> - dp[i][j] &lt;= k) G[i][j] = <span class="string">'a'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.push(pii(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    p[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;pii&gt; tmp;</span><br><span class="line">      <span class="keyword">int</span> cur = <span class="number">200</span>;</span><br><span class="line">      <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        tmp.push_back(pq.front());</span><br><span class="line">        cur = min(cur, (<span class="keyword">int</span>)G[pq.front().first][pq.front().second]);</span><br><span class="line">        pq.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = tmp[i].first, y = tmp[i].second;</span><br><span class="line">        <span class="keyword">if</span>(cur == (<span class="keyword">int</span>)G[x][y]) &#123;</span><br><span class="line">          p[x][y] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(ok(x+<span class="number">1</span>, y)&amp;&amp;!vis[x+<span class="number">1</span>][y]) &#123;</span><br><span class="line">            vis[x+<span class="number">1</span>][y] = <span class="number">1</span>;</span><br><span class="line">            pq.push(pii(x+<span class="number">1</span>, y));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(ok(x, y+<span class="number">1</span>)&amp;&amp;!vis[x][y+<span class="number">1</span>]) &#123;</span><br><span class="line">            vis[x][y+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            pq.push(pii(x, y+<span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.clear();</span><br><span class="line">    ret.push_back(G[n][n]);</span><br><span class="line">    dfs(n,n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1072/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1072/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给一个$n\times n$的字母阵，允许修改其中的$k$个字符，问从$(1,1)$走到$(n,n)$字典序最小的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces Mail.Ru Cup 2018 Round 1] D. Changing Array (异或和，贪心)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/19/CF1054D/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/19/CF1054D/</id>
    <published>2018-10-19T09:18:08.000Z</published>
    <updated>2018-10-19T09:33:05.418Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1054/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1054/problem/D</a></p><p><strong>一个人有$n$个二进制最高位$1%不超过$k$位的数，现在允许每一个数按位取反，统计这个数列中最多有多少个区间异或和不是0。</strong></p><a id="more"></a><p>发现一个重要的性质是，每一个区间内有两个数进行取反操作的话，实际就是没有进行取反操作。因为取反操作可以看做是一个数对$2^k-1$异或，两个数进行取反的话，那么就是异或$2^k-1$两次，就被抵消了。</p><p>假设前缀和为$sum$的点有$k$个，那么一定有$C_{k-1}^2$种构成区间异或和为0的方式，现在的问题就是尽量减少每一种$sum$出现的次数了。</p><p>于是我们可以贪心地去比每一个数和它翻转后与前缀和异或后的次数，每次往出现少的异或和上加。总的贡献是$\sum_i C^2_{cnt_i-1}$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL a[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">auto</span> rev = [=](LL x) &#123; <span class="keyword">return</span> x ^ ((<span class="number">1L</span>L &lt;&lt; (LL)k) - <span class="number">1</span>); &#125;;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    LL ret = <span class="number">1L</span>L * (n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    cnt.clear();</span><br><span class="line">    cnt[sum]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">      <span class="keyword">if</span>(cnt[sum^a[i]] &gt; cnt[sum^rev(a[i])]) sum ^= rev(a[i]);</span><br><span class="line">      <span class="keyword">else</span> sum ^= a[i];</span><br><span class="line">      cnt[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : cnt) &#123;</span><br><span class="line">      ret -=  <span class="number">1L</span>L * (p.second - <span class="number">1</span>) * p.second / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1054/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1054/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个人有$n$个二进制最高位$1%不超过$k$位的数，现在允许每一个数按位取反，统计这个数列中最多有多少个区间异或和不是0。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="异或" scheme="https://vincentxwd.github.io/blog/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>[C++] 闭包的capture（捕获）方式</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/19/Cpp-capture/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/19/Cpp-capture/</id>
    <published>2018-10-19T05:01:40.000Z</published>
    <updated>2018-10-19T05:08:39.573Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷题喜欢用闭包把函数全部写到main中，通常一个函数可以这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; f = [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x; &#125;;</span><br></pre></td></tr></table></figure><p>但是在闭包[]中可以添加=或&amp;两个运算符，查过cpp reference后，这个叫capture（捕获），即<strong>使用闭包外的变量的方式</strong>。讨论这两个运算符：</p><p>[=](){}：这是对闭包外变量进行const引用的形式，即不允许修改闭包外的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> p = [=]()&#123;</span><br><span class="line">  x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这段代码编译会报错，因为=捕获不允许修改外变量。</p><p>[&amp;](){}：这是对闭包外变量进行引用的形式，可以修改闭包外的变量，并且保留为修改后的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> p = [&amp;]()&#123;</span><br><span class="line">  x = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>而这段代码会输出4，因为闭包捕获到外部变量后将其修改并保留。</p><p>除此之外，还可以声明特定变量使用特定的捕获方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a,&amp;b]。将a按值进行传递，b按引用进行传递。</span><br><span class="line">[=,&amp;a,&amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</span><br><span class="line">[&amp;,a,b]。除a和b按值进行传递外，其他参数都按引用进行传递。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近刷题喜欢用闭包把函数全部写到main中，通常一个函数可以这样：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/p
      
    
    </summary>
    
      <category term="编程语言" scheme="https://vincentxwd.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="https://vincentxwd.github.io/blog/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundB] B. Sherlock and the Bit Strings</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-B-Sherlock-and-the-Bit-Strings/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-B-Sherlock-and-the-Bit-Strings/</id>
    <published>2018-10-18T14:37:59.000Z</published>
    <updated>2018-10-18T14:40:26.732Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.google.com/codejam/contest/10284486/dashboard#s=p1" target="_blank" rel="noopener">https://code.google.com/codejam/contest/10284486/dashboard#s=p1</a></p><p>给一个长为n的01串，现在规定在串的一些区间$[A_i,B_i]$中至少存在$C_i$个1，求满足条件的字典序为第$p$大的串。</p><a id="more"></a><p>小数据可以直接暴力，记下空位和$p$的二进制形式，然后从低到高扫01串就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL p;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="built_in">string</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span> ,&amp;n,&amp;k,&amp;p);</span><br><span class="line">    p--;</span><br><span class="line">    pos.clear();</span><br><span class="line">    ret.resize(n); fill(ret.begin(), ret.end(), <span class="string">'#'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">      <span class="keyword">if</span>(c[i]) ret[a[i]<span class="number">-1</span>] = <span class="string">'1'</span>;</span><br><span class="line">      <span class="keyword">else</span> ret[a[i]<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">      pos.emplace_back(p&amp;<span class="number">1</span>);</span><br><span class="line">      p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ret[j] == <span class="string">'1'</span> || ret[j] == <span class="string">'0'</span>) j--;</span><br><span class="line">        ret[j--] = <span class="string">'1'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(pos[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ret[j] == <span class="string">'1'</span> || ret[j] == <span class="string">'0'</span>) j--;</span><br><span class="line">        ret[j--] = <span class="string">'0'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ret[i] == <span class="string">'#'</span>) ret[i] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _++ &lt;&lt; <span class="string">": "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://code.google.com/codejam/contest/10284486/dashboard#s=p1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/10284486/dashboard#s=p1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给一个长为n的01串，现在规定在串的一些区间$[A_i,B_i]$中至少存在$C_i$个1，求满足条件的字典序为第$p$大的串。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="暴力" scheme="https://vincentxwd.github.io/blog/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundB] A. No Nine</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-A-No-Nine/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-A-No-Nine/</id>
    <published>2018-10-18T12:17:33.000Z</published>
    <updated>2018-10-18T12:20:40.764Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/10284486/dashboard#s=p0" target="_blank" rel="noopener">https://code.google.com/codejam/contest/10284486/dashboard#s=p0</a></p><p>求$[L,R]$内不被9整除且每一位都不是9的数的个数。</p><a id="more"></a><p>经典数位dp，根据$(x+y)\%m=(x\%m+y\%m)\%m$，直接维护前$l$位对9取模的值，向后dfs到最后一位发现模数不是0就计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> digit[maxn];</span><br><span class="line">LL dp[maxn][maxn];</span><br><span class="line">LL L, R;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mod, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!flag &amp;&amp; ~dp[l][mod]) <span class="keyword">return</span> dp[l][mod];</span><br><span class="line">  <span class="keyword">if</span>(l == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(mod % <span class="number">9</span> == <span class="number">0</span>) <span class="keyword">return</span> dp[l][mod] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[l][mod] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> pos = flag ? digit[l] : <span class="number">9</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pos; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">    ret += dfs(l<span class="number">-1</span>, (mod*<span class="number">10</span>+i)%<span class="number">9</span>, flag&amp;&amp;(i==pos));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!flag) dp[l][mod] = ret;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x) &#123;</span><br><span class="line">    digit[++tot] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(tot, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;L,&amp;R);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, f(R)-f(L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://code.google.com/codejam/contest/10284486/dashboard#s=p0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/10284486/dashboard#s=p0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求$[L,R]$内不被9整除且每一位都不是9的数的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="数位DP" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundA] B. Lucky Dip</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundA-B-Lucky-Dip/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundA-B-Lucky-Dip/</id>
    <published>2018-10-18T06:36:31.000Z</published>
    <updated>2018-10-18T06:45:28.769Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/9234486/dashboard#s=p1" target="_blank" rel="noopener">https://code.google.com/codejam/contest/9234486/dashboard#s=p1</a></p><p><strong>有n个数，允许k次“取一个数再放回重新取”的操作，一个人希望拿到最大的那个数字。求取到数字最大的期望。</strong></p><a id="more"></a><p>$k=0$时，期望就是均值，即$E_0=\frac{1}{n}\sum_{i=0}^nv_i$。</p><p>$k=1$时，每取到一个数可以有一次机会选择是否放回，但是期望拿到数字最大，因此要选取比$k=0$时期望大的数，$E_1=\frac{1}{n}\sum_{i=1}^n\mbox{max}(v_i,E_0)$。</p><p>可以推广：$E_k=\frac{1}{n}\sum_{i=1}^n\mbox{max}(v_i,E_{k-1})$。</p><p>假设计算$E_k$时，有$t$个数字使得$E_{k-1}$比$v_i$大，那么就有$n-t$个数使$E_{k-1}$比$v_i$小，他们的对$E_k$的贡献分别是$tE_{k-1}$和$\sum_{v&lt;E_{k-1}}v$。我们可以对$v$排序，前者的$t$可以二分得到，后者可以维护一个前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20020</span>;</span><br><span class="line"><span class="keyword">double</span> v[maxn], sum[maxn];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> E)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[mid] &lt;= E) &#123;</span><br><span class="line">      ret = mid;</span><br><span class="line">      lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">    <span class="keyword">double</span> E = <span class="number">.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v+<span class="number">1</span>, v+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i<span class="number">-1</span>] + v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> t = bs(E);</span><br><span class="line">      E = (sum[n]-sum[t]) + t * E;</span><br><span class="line">      E /= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %.8f\n"</span>, _++, E);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://code.google.com/codejam/contest/9234486/dashboard#s=p1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/9234486/dashboard#s=p1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有n个数，允许k次“取一个数再放回重新取”的操作，一个人希望拿到最大的那个数字。求取到数字最大的期望。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="期望, 二分" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%9F%E6%9C%9B-%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundA] A. Even Digits</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundA-A-Even-Digits/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundA-A-Even-Digits/</id>
    <published>2018-10-18T04:13:47.000Z</published>
    <updated>2018-10-18T04:21:52.088Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/9234486/dashboard#s=p0" target="_blank" rel="noopener">https://code.google.com/codejam/contest/9234486/dashboard#s=p0</a></p><p><strong>给一个数，这个数每次只能+1或-1，问把这个数变成每一位都是偶数的最少步数。</strong></p><a id="more"></a><p>其实就是说，求和这个数的差的绝对值最小的每位都是偶数的数。</p><p>考虑比这个数小的数，要最大化这个数就是把这个数最高位的奇数-1后面的数都是8；</p><p>考虑比这个数大的数，要最小化这个数就是把这个数最高位的奇数+1后面的数都是0，但是要考虑当前最高位是9的时候，再+1是不可能的了，所以这一个情况就不需要++。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span> maxn = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">down</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> y = x;</span><br><span class="line">  LL a = stoull(x);</span><br><span class="line">  y[<span class="number">0</span>]--;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; y.length(); i++) y[i] = <span class="string">'8'</span>;</span><br><span class="line">  LL b = stoull(y);</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">up</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> y = x;</span><br><span class="line">  LL a = stoull(x);</span><br><span class="line">  <span class="keyword">if</span>(y[<span class="number">0</span>] != <span class="string">'9'</span>) &#123;</span><br><span class="line">    y[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; y.length(); i++) y[i] = <span class="string">'0'</span>;</span><br><span class="line">    LL b = stoull(y);</span><br><span class="line">    <span class="keyword">return</span> b - a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>((s[i] - <span class="string">'0'</span>) % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      ret = min(down(s.substr(i, n-i)), up(s.substr(i, n-i)));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://code.google.com/codejam/contest/9234486/dashboard#s=p0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/9234486/dashboard#s=p0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给一个数，这个数每次只能+1或-1，问把这个数变成每一位都是偶数的最少步数。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="构造, 模拟" scheme="https://vincentxwd.github.io/blog/tags/%E6%9E%84%E9%80%A0-%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] Neural Networks and Deep Learning Chapter 1</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/08/nndl_ch1/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/08/nndl_ch1/</id>
    <published>2018-10-08T01:28:00.000Z</published>
    <updated>2018-10-12T02:34:38.044Z</updated>
    
    <content type="html"><![CDATA[<p>这是我阅读在线书籍《Neural Networks and Deep Learning》的笔记，这篇博文是第一章的。没什么营养，因为大部分都知道了，于是草草略过。</p><p>章节链接： <a href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html</a></p><a id="more"></a><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h3><p>科普。</p><h3 id="words"><a href="#words" class="headerlink" title="words"></a><strong>words</strong></h3><ol><li>effortlessly：毫不费力地</li><li>deceptive：欺骗性的</li><li>superbly：雄伟地（文中表程度大）</li><li>astoundingly：令人惊讶地</li><li>stupendously：（同上）</li></ol><hr><p>科普。。</p><p><strong>words</strong></p><ol><li>morass：沼泽、困境</li><li>caveats：警告</li></ol><hr><p>科普。。。讲下NN可以从一堆数据中学习到一些特征，然后去预测一些没见过的数据。并且数据越多效果越好。</p><hr><p>介绍第一章要搞什么（手撸一个NN，用来识别手写数字，就74行），随后的章节要搞什么（想一些trick提升NN的acc之类）。</p><p><strong>words</strong></p><ol><li>intervention：介入、调停</li></ol><hr><p>手写数字识别这个问题简单，非常适合用来举例（大概这样可以把注意力更多地集中到NN本身之类？）。<em>it’s challenging - it’s no small feat to recognize handwritten digits - but it’s not so difficult as to require an extremely complicated solution, or tremendous computational power.</em><br>(这是一项具有挑战性的工作——识别手写的数字绝非易事——但是拥有一个极其复杂的解决方案，或者是巨大的计算能力的话就不难了)，之后会讲一些扩展。</p><p><strong>words</strong></p><ol><li>throughout：自始至终</li></ol><hr><p>这章的重点：</p><p>两类神经元：<strong>感知机（Perceptrons）</strong>和<strong>sigmoid函数</strong>。</p><p>神经网络的标准训练方法：<strong>随机梯度下降（Stochastic gradient descent, SGD）</strong></p><p><em>Amongst the payoffs, by the end of the chapter we’ll be in position to understand what deep learning is, and why it matters.</em>最后会讨论一下DL为什么会matters。</p><hr><h3 id="Perceptrons"><a href="#Perceptrons" class="headerlink" title="Perceptrons"></a><strong>Perceptrons</strong></h3><p>感知机（<a href="http://books.google.ca/books/about/Principles_of_neurodynamics.html?id=7FhRAAAAMAAJ）是一类人工神经元，由科学家Frank" target="_blank" rel="noopener">http://books.google.ca/books/about/Principles_of_neurodynamics.html?id=7FhRAAAAMAAJ）是一类人工神经元，由科学家Frank</a> Rosenblatt在上世纪50到60年代间完成。</p><p>不过目前非常流行的一类模型是神经网络（Neural Network），最重要的一部分是sigmoid（就个非线性函数）。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz0.png" alt="img"></p><p>上图是个最原始感知机的神经元，嗯。</p><p>假设这个perceptron有三个输入$x_1,x_2,x_3$，中间的圈里一系列权重$w_1,w_2,w_3$。输入来的时候，我们首先做向量乘法$sum=\sum_i w_ix_i$，然后要和一个阈值$threshold$比较得到$output$：<br>$$<br>output=<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ sum \leq threshold \<br>1, \ \ otherwise.<br>\end{array}<br>\right.<br>$$</p><hr><p>举个例子。</p><p><strong>words</strong></p><ol><li>transit：公共交通</li><li>adore：崇拜、爱慕</li><li>loathe：讨厌</li></ol><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz1.png" alt="img"></p><p>每一列称之为<strong>层（Layer）</strong>，第一层的三个神经元对输入分别以自己的权重进行处理（每层的处理就是向量乘积，最后获得<strong>一个值</strong>），得到的输出（可能不用threshold判断）再分别给第二层的每一个神经元，第二层的决策会更加复杂，因为第二层的输入是通过第一层抽象过的结果。</p><p>实际上每个神经元的输入可以有很多，但是输出都是一个。这么画是为了说明层与层之间是如何联系起来的。</p><p><strong>words</strong></p><ol><li>plausible：可信的</li><li>subtle：微妙的</li><li>engage：从事，参与</li><li>sophisticated：复杂的</li><li>incidentally：顺便，附带地</li></ol><hr><p>把上述神经元的计算过程简化下：<br>$$<br>output=<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ \omega\cdot x+b \leq 0 \<br>1, \ \ otherwise.<br>\end{array}<br>\right.<br>$$<br>$b$就是bias，也是threshold。表示一种“输出1”的测量(<em>the bias as a measure of how easy it is to get the perceptron to output a 1.</em> )。</p><p><strong>words</strong></p><ol><li>cumbersome：冗杂的，累赘的</li><li>notation：标志、符号、记号</li><li>reminder：剩下的</li></ol><hr><p>举了个简单的例子，说明感知机可以做与、或、非之类的逻辑操作：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz2.png" alt="img"></p><p>上图就是一个与非门，实际上感知机能做任何逻辑操作（因为这东西可以实现一切基本逻辑操作，那么就像连电路一样把那些门都连起来就行了）。</p><p>这是为了说明，感知机可以和其他计算设备一样强大。然而并非仅此而已，我们还可以在这个简单的模型上使用学习算法，使这个模型可以自己调整每一个神经元中的weights和bias，这种调节来自外部刺激（external stimuli），而非手动调整。</p><p><strong>words</strong></p><ol><li>equivalent：等价物</li><li>notable：值得注意的</li></ol><hr><p><strong>Sigmoid Neurons</strong></p><p>先介绍更新权重的时候，可以表示成$\omega+\Delta\omega$的形式，这样就可以学习了（当然都是向量）。也就是，我们希望每次output反过头过来传个值，然后更新这个网络。</p><p>但是上述的naïve perceptron在输出的时候都会经过一个突变函数（非零即一），通过这个门以后后面的神经元就完全没法恒量差别了（就像雅思）。</p><p>引出sigmoid：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz9.png" alt="img"></p><p>这里output为$\sigma(z) \equiv\dfrac{1}{1+e^{-z}}=\dfrac{1}{1+exp(-\sum_jw_jx_j-b)}$。</p><p>这样做的好处是对之前用的step function做了平滑处理，使得变化看起来不会过于激烈。看看原文是如何解释的：</p><p><em>The smoothness of $\sigma$ means that small changes $\Delta w_j$ in the weights and $\Delta b$ in the bias will produce a small change $\Delta output$ in the output from the neuron.</em></p><p>就是说变化后的w和b在处理完输入接着输出到output的时候，使得output的变化不至于太剧烈，output可以近似为下面的值：<br>$$<br>  \Delta \mbox{output} \approx \sum_j \frac{\partial \, \mbox{output}}{\partial w_j}<br>  \Delta w_j + \frac{\partial \, \mbox{output}}{\partial b} \Delta b<br>$$<br>确实可以用微分来解释，因为$\mbox{output}$是一个n元一次线性方程，那么对它微分就是各项偏导之和，而微分的几何意义就是表示偏移量（变化量）的。</p><p>我们需要有一个平滑函数$\sigma$来简化运算，由于指数在微分时的性质（无限可微），所以构造了sigmoid函数作为激活函数（sigmoid还有一个著名性质就是导数可以用自身表达）。</p><p>如何解释经过sigmoid的输出？</p><p>最大的不同是：经过sigmoid平滑后，输出由原来的0或1变为[0,1]中任意实数（希望变成0 1的话直接设阈值max一下就ok）。</p><p><strong>words</strong></p><ol><li>terrific：可怕的</li><li>property：性质、性能</li><li>occasionally：偶尔、偶然地、不定期地</li><li>legitimate：合法的</li><li>convention：约定</li></ol><hr><p><strong>Exercises</strong></p><p>part I：证明感知机中所有w、b都乘一个大于0的常数c，这个网络的输出不会改变。</p><p>证：$<br>\mbox{output}=<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ \omega\cdot x+b \leq 0 \<br>1, \ \ otherwise.<br>\end{array}<br>\right.$，乘一个整数不会影响。</p><p>part II：给一个感知机，对于任意输入$x$，都有$\omega\cdot x+b \not=0$。现在把所有神经元都替换成sigmoid神经元，再乘一个大于0的常数c，证明假如c趋于无穷大的时候，有sigmoid神经元的模型就会退化成没有sigmoid的网络。假如$\omega\cdot x+b =0$的时候又会有什么不同？</p><p>(1). 证：$c \to +\infty,c&gt;0$时，可以分别将$lim$带入上述$\sigma$函数中求极限，发现分别收敛于0和1。</p><p>(2). 结果会输出0，而sigmoid会输出0.5，是不一样的。</p><hr><h3 id="The-architecture-of-neural-networks"><a href="#The-architecture-of-neural-networks" class="headerlink" title="The architecture of neural networks"></a><strong>The architecture of neural networks</strong></h3><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz10.png" alt="img"></p><p>上图是一个网络，从左到右开始，第1层叫输入层（input layer），每个元素叫输入神经元；第2层叫隐层（hidden layer），未必只有一层；第3层叫输出层（output layer）。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz11.png" alt="img"></p><p>有多层的网络有时候也被称作“多层感知机”，这是有历史原因的。所以现在完全可以认为NN=MLP（MLP里的感知层（简单的线性操作）换成sigmoid）。</p><p>然后介绍识别手写数字的任务，提到最简单的构建NN的方法就是把一张图片（例如$64\times 64$）的灰度信息直接保存（输入直接是$4096$维，当然要把灰度归一化到[0,1]内），然后走一遍网络取argmax。同时，hidden layer的设计会非常多样。</p><p>前馈神经网络：通常定义只允许前面的层向后面的层输出，不允许反过来（不允许有环）。但是现在已经有一些可以带环的网络（RNN）。</p><p><strong>words</strong></p><ol><li>terminology：术语</li><li>philosophical：哲学的</li><li>rules of thumb：经验法则（大拇指规则）</li><li>heuristics：启发、尝试（法）</li></ol><hr><h3 id="A-simple-network-to-classify-handwritten-digits"><a href="#A-simple-network-to-classify-handwritten-digits" class="headerlink" title="A simple network to classify handwritten digits"></a><strong>A simple network to classify handwritten digits</strong></h3><p>本科做过了这段懒得读了。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz12.png" alt="img"></p><p>这个图挺帅，意思就是用一层hidden，然后输入是$28\times 28=784$维，然后最后输出10个分类的logits。</p><p>这里讨论了一个很有趣的问题：为什么输出是10个而不是4个（因为$2^4=16&gt;10$可以表示所有我们希望的数字情况）？</p><p>个人认为隐层中每次处理后都会提取图像中的某一部分的特征，预测的时候被激活与否的影响因素为某部分是不是有这个特征，有某种特征对应0-9这十个数是很容易的，然而要对应二进制编码则很难表示。</p><p><strong>words</strong></p><ol><li>sake：利益、理由</li></ol><p>Exercise懒得做了，只要对应好四个位置给权值就行了。</p><hr><h3 id="Learning-with-gradient-descent"><a href="#Learning-with-gradient-descent" class="headerlink" title="Learning with gradient descent"></a><strong>Learning with gradient descent</strong></h3><p>介绍mnist数据集，同时设计一些必要的环节：</p><p>$\mbox{cost function}$：$\begin{eqnarray}  C(w,b) \equiv \frac{1}{2n} \sum_x | y(x) - a|^2\end{eqnarray}.$（均方误差），训练过程中的目标是最小化$\mbox{cost function}$。</p><p>然后讲梯度下降：</p><p>$\begin{eqnarray}    \Delta C \approx \frac{\partial C}{\partial v_1} \Delta v_1 +   \frac{\partial C}{\partial v_2} \Delta v_2. \end{eqnarray}$ 我们的目标是希望使$\Delta C$变负，$\Delta v_1,\Delta v_2$分别是两个不同方向的偏移量。因此可以说$\Delta C$是两个方向偏移量的叠加。</p><p>定义梯度向量：$\begin{eqnarray}    \nabla C \equiv \left( \frac{\partial C}{\partial v_1},    \frac{\partial C}{\partial v_2} \right)^T. \end{eqnarray}$</p><p>所以化简后，变化量可以表示成：$\begin{eqnarray}    \Delta C \approx \nabla C \cdot \Delta v. \end{eqnarray}$</p><p>定义$\begin{eqnarray}    \Delta v = -\eta \nabla C\end{eqnarray}$，$\eta$是一个极小的正数（学习率），$\Delta C \approx -\eta \nabla C \cdot \nabla C = -\eta |\nabla C|^2$，$\Delta C \leq0$恒成立知，$C$是一个只减不增的值，于是我们在算出的$\Delta C$（我们希望让$\Delta C$一直是负数，也就是$C$一直下降）的同时，算出$v$移动后的位置$v’=v-\eta \nabla C$。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/valley_with_ball.png" alt="img"></p><p>就像这个绿球一直往地势低的地方滚，直到最低点（极低点）为止。</p><p>到$m$维的向量空间，$\nabla C$的定义会得到扩展：<br>$$<br>\begin{eqnarray}<br>  \nabla C \equiv \left(\frac{\partial C}{\partial v_1}, \ldots,<br>  \frac{\partial C}{\partial v_m}\right)^T<br>\end{eqnarray}<br>$$<br>（对于$\Delta v$中的每维变量，都会有一个对应的梯度去更新它。）</p><p>通常训练神经网络的工作都是面对这样一个最优化问题，梯度下降算法可以看做是一个采用最少步骤使得$C$下降的一个方法。</p><p><strong>words</strong></p><ol><li>quadratic：二次的</li><li>ah-doc：特别的</li><li>recap：翻造、重申</li><li>distract：转移、分心</li><li>lurk：潜伏、埋伏、隐藏</li></ol><hr><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a><strong>Exercise</strong></h3><p><a href="http://neuralnetworksanddeeplearning.com/chap1.html#exercises_647181" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html#exercises_647181</a></p><p>Part I. 证明上述的假设，即：当$\left|v\right| = \epsilon, \Delta v =-\eta \nabla C​$时，其中$\epsilon &gt;0​$为很小的一个数，且当$\eta =\dfrac{\epsilon}{\left| \nabla C\right|}​$时，$\Delta C=\nabla C \cdot \Delta v​$可以取到最小值。（也就是要证给定步长，我们沿着梯度的方向总能找到最小值）</p><p>证明：当$\Delta C = \nabla C \cdot \Delta v$且$\left|v\right|=\epsilon$时，令$\Delta v=-\eta \nabla C=(-\epsilon/\left|\Delta C\right|)\nabla C$，则有：<br>$$<br>\begin{align}<br>\Delta C &amp;= \nabla C \cdot \Delta v \<br>&amp;=  \nabla C \cdot  ( -\epsilon/\left|\nabla C\right| ) \nabla C \<br>&amp;= \nabla C ^2 ( -\epsilon/\left|\nabla C\right| ) \<br>&amp;= \left|\nabla C\right| ^2 ( -\epsilon/\left|\nabla C\right| ) \<br>&amp;= -\epsilon \left|\nabla C\right| \<br>&amp;= -\left|\Delta v\right|\left|\nabla C\right|<br>\end{align}<br>$$<br>由柯西-施瓦兹不等式，$\left|u\right|\left|v\right| \ge \left|u \cdot v\right|$得，$\left|\Delta v\right|\left|\nabla C\right|\ge \left| \Delta v \cdot \nabla C \right|$，$-\left|\Delta v\right|\left|\nabla C\right|$必为最小值。</p><p>Part II. 给出一个在多维和一维情况下梯度下降的几何解释。</p><p>答：一维的话就退化成函数求导问题了，就是在一个曲线上找极小值，也就是一个圆点往地势低的地方滚。</p><hr><p>接近物理学球下滚模拟的变种算法不可避免地需要求二阶偏微分，十分复杂。因此书中会引出一些方法来避免这个问题（梯度下降）。</p><p>梯度下降的目标是最小化$\mbox{cost function}\begin{eqnarray}  C(w,b) \equiv   \frac{1}{2n} \sum_x | y(x) - a|^2 \nonumber\end{eqnarray}$.</p><p>反向更新的时候，这样来更新weights和biases：<br>$$<br>\begin{eqnarray}<br>  w_k &amp; \rightarrow &amp; w_k’ = w_k-\eta \frac{\partial C}{\partial w_k} \<br>  b_l &amp; \rightarrow &amp; b_l’ = b_l-\eta \frac{\partial C}{\partial b_l}.<br>\end{eqnarray}<br>$$<br>但是有一个问题，原始的梯度下降里，这个目标函数实际上是在求$C​$在不同$x​$取值时的均值，也就是要把整个dataset都迭代一遍后再去反向传播。</p><p>随机梯度下降（Stochastic gradient descent，SGD）每次选取指定规模的mini-batch去做梯度下降，在mini-batch的大小$m$满足：<br>$$<br>\begin{eqnarray}<br>  \frac{\sum_{j=1}^m \nabla C_{X_{j}}}{m} \approx \frac{\sum_x \nabla C_x}{n} = \nabla C,<br>\end{eqnarray}<br>$$<br>即$m$个输入的平均值要接近于全体输入的平均值，SGD才可近似于naïve GD。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/1539092769209.png" alt="1539092769209"></p><p>带入权值和偏移更新中，公式变成这样：<br>$$<br>\begin{eqnarray}<br>  w_k &amp; \rightarrow &amp; w_k’ = w_k-\frac{\eta}{m}<br>  \sum_j \frac{\partial C_{X_j}}{\partial w_k} \<br>  b_l &amp; \rightarrow &amp; b_l’ = b_l-\frac{\eta}{m}<br>  \sum_j \frac{\partial C_{X_j}}{\partial b_l},<br>\end{eqnarray}<br>$$<br>在SGD时，称把整个数据集经过mini-batch训练一遍为一个epoch，通常要来好几个epoch。</p><p>在算目标函数的时候不要忘记$\frac{1}{n}$（用mini-batch的时候是$\frac{1}{m}$），做一下平均（因为有可能后来添加数据，就是说数据规模不一定的时候会影响到）。</p><p><strong>words</strong></p><ol><li>incidentally：顺便地，偶然一提地</li><li>convention：惯例，约定</li><li>omit：省略、疏忽</li></ol><hr><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a><strong>Exercise</strong></h3><p>提到了mini-batch size=1的时候的一种极限情况。</p><hr><h3 id="Implementing-our-network-to-classify-digits"><a href="#Implementing-our-network-to-classify-digits" class="headerlink" title="Implementing our network to classify digits"></a><strong>Implementing our network to classify digits</strong></h3><p>介绍数据集，和要实现的神经网络。稍微读下代码，其他没什么好看的。</p><hr><h3 id="Toward-deep-learning"><a href="#Toward-deep-learning" class="headerlink" title="Toward deep learning"></a><strong>Toward deep learning</strong></h3><p>又是一些废话。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我阅读在线书籍《Neural Networks and Deep Learning》的笔记，这篇博文是第一章的。没什么营养，因为大部分都知道了，于是草草略过。&lt;/p&gt;
&lt;p&gt;章节链接： &lt;a href=&quot;http://neuralnetworksanddeeplearning.com/chap1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://neuralnetworksanddeeplearning.com/chap1.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Deep Learning" scheme="https://vincentxwd.github.io/blog/tags/Deep-Learning/"/>
    
  </entry>
  
</feed>
