<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kirai</title>
  
  <subtitle>Keep going</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://vincentxwd.github.io/blog/"/>
  <updated>2019-06-06T17:38:28.189Z</updated>
  <id>https://vincentxwd.github.io/blog/</id>
  
  <author>
    <name>Kirai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[CodeForces1169E] And Reachability（思维，DP）</title>
    <link href="https://vincentxwd.github.io/blog/2019/06/07/CF1169E%EF%BC%88%E6%80%9D%E7%BB%B4%EF%BC%8CDP%EF%BC%89/"/>
    <id>https://vincentxwd.github.io/blog/2019/06/07/CF1169E（思维，DP）/</id>
    <published>2019-06-06T17:24:01.000Z</published>
    <updated>2019-06-06T17:38:28.189Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="https://codeforces.com/contest/1169/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1169/problem/E</a></p><p>题意：给$n$个数$a_i$，$m$次询问，要求每次询问下标$x$的数能否一直与到下标为$y$的数，从$x$出发$a_x$与的每一个中间数$a_k$不能为$0$，问是否存在这样一个序列，能一直与到下标为$y$的数。</p><a id="more"></a><p>考虑DP，$f(i,j)$表示从$i$出发能走到$i$之后的最近的一个数的下标$p$，并且这两个数都有数位$j$. 于是我们可以枚举另一个数位$k$作为桥梁，看看是否可以连接$i$到$p$.</p><p>显然，我们需要维护一个$last_k$，表示第$i$个数后边的最近的数，并且这个数包括$k$位的下标。于是递推式为：<br>$$<br>f(i,j)=min(f(i,j),f(last(k),j))<br>$$<br>更新的时候实际上枚举的是是否可以做桥梁的$i$，并且倒序更新，这样才能保证之前的状态都已经计算过。</p><p>查询的时候可以询问$a_y$是否存在数位$i$，并且$f(x,i)$这个下标是否在$x$和$y$之间，如果在的话，这个数可以作为桥梁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300300</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxm], last[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxm; j++) &#123;</span><br><span class="line">        f[i][j] = n + <span class="number">1</span>;</span><br><span class="line">        last[j] = n + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxm; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; j) &amp; a[i]) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxm; k++) &#123;</span><br><span class="line">            f[i][k] = min(f[i][k], f[last[j]][k]);</span><br><span class="line">          &#125;</span><br><span class="line">          last[j] = i;</span><br><span class="line">          f[i][j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxm; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &amp; a[y]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (f[x][i] &lt;= y) &#123;</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ok) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Shi"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Fou"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;https://codeforces.com/contest/1169/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1169/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意：给$n$个数$a_i$，$m$次询问，要求每次询问下标$x$的数能否一直与到下标为$y$的数，从$x$出发$a_x$与的每一个中间数$a_k$不能为$0$，问是否存在这样一个序列，能一直与到下标为$y$的数。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="思维, DP" scheme="https://vincentxwd.github.io/blog/tags/%E6%80%9D%E7%BB%B4-DP/"/>
    
  </entry>
  
  <entry>
    <title>[CodeForces1175E] Minimal Segment Cover（倍增）</title>
    <link href="https://vincentxwd.github.io/blog/2019/06/07/CF1175E%EF%BC%88%E5%80%8D%E5%A2%9E%EF%BC%89/"/>
    <id>https://vincentxwd.github.io/blog/2019/06/07/CF1175E（倍增）/</id>
    <published>2019-06-06T16:24:46.000Z</published>
    <updated>2019-06-06T17:38:22.303Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接</strong>：<a href="https://codeforces.com/contest/1175/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1175/problem/E</a></p><p>给你n条线段，m次询问。每次询问至少需要n条线段中的多少条线段能把本次询问中的线段覆盖？n条线段必须相交才算可以连起来（也就是$r_1&gt;l_2$）。</p><a id="more"></a><p>考虑倍增预处理$n$条线段：$f(l,j)$表示从$l$出发连$2^j$条线段最远可以到达的点是多少，于是得到更新方式：<br>$$<br>f(l,j)=f(f(l,j-1),j-1)<br>$$<br>查询的时候$j$单调递减，每次查询$l$出发是否可以经过$j$次到达$r$，如果不可以那么更新$l$为$l$走$2^j$最远到达的点，下次从这个点出发查看是否可以到达$r$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500500</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> l, r;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">int</span> hi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">      l++; r++;</span><br><span class="line">      hi = max(hi, r);</span><br><span class="line">      f[l][<span class="number">0</span>] = max(f[l][<span class="number">0</span>], r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">      f[i][<span class="number">0</span>] = max(f[i][<span class="number">0</span>], max(i, f[i - <span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">24</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= hi; l++) &#123;</span><br><span class="line">        f[l][j] = f[f[l][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">      l++; r++;</span><br><span class="line">      <span class="keyword">if</span> (f[l][<span class="number">23</span>] &lt; r) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[l][i] &lt; r) &#123;</span><br><span class="line">          l = f[l][i];</span><br><span class="line">          ret += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; ret + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接&lt;/strong&gt;：&lt;a href=&quot;https://codeforces.com/contest/1175/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1175/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给你n条线段，m次询问。每次询问至少需要n条线段中的多少条线段能把本次询问中的线段覆盖？n条线段必须相交才算可以连起来（也就是$r_1&amp;gt;l_2$）。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/CodeForces/"/>
    
    
      <category term="倍增" scheme="https://vincentxwd.github.io/blog/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>[HDOJ6494] 球赛（DP）</title>
    <link href="https://vincentxwd.github.io/blog/2019/04/17/HDOJ6494-%E7%90%83%E8%B5%9B%EF%BC%88DP%EF%BC%89/"/>
    <id>https://vincentxwd.github.io/blog/2019/04/17/HDOJ6494-球赛（DP）/</id>
    <published>2019-04-17T15:57:23.000Z</published>
    <updated>2019-04-17T16:00:10.128Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6494" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6494</a></p><p>中文题面。</p><a id="more"></a><p>先得11分的为赢，则10平后，先多得2分的赢。那么遇到这两种情况后面的场次都是随意的。于是就可以设计状态了：f(i,j,k)表示前i场A赢j局，B赢k局时的方案数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⣿⣿⣿⣿⣿⣿⢟⣡⣴⣶⣶⣦⣌⡛⠟⣋⣩⣬⣭⣭⡛⢿⣿⣿⣿⣿</span></span><br><span class="line"><span class="comment">// ⣿⣿⣿⣿⠋⢰⣿⣿⠿⣛⣛⣙⣛⠻⢆⢻⣿⠿⠿⠿⣿⡄⠻⣿⣿⣿ </span></span><br><span class="line"><span class="comment">// ⣿⣿⣿⠃⢠⣿⣿⣶⣿⣿⡿⠿⢟⣛⣒⠐⠲⣶⡶⠿⠶⠶⠦⠄⠙⢿ </span></span><br><span class="line"><span class="comment">// ⣿⠋⣠⠄⣿⣿⣿⠟⡛⢅⣠⡵⡐⠲⣶⣶⣥⡠⣤⣵⠆⠄⠰⣦⣤⡀ </span></span><br><span class="line"><span class="comment">// ⠇⣰⣿⣼⣿⣿⣧⣤⡸⢿⣿⡀⠂⠁⣸⣿⣿⣿⣿⣇⠄⠈⢀⣿⣿⠿ </span></span><br><span class="line"><span class="comment">// ⣰⣿⣿⣿⣿⣿⣿⣿⣷⣤⣈⣙⠶⢾⠭⢉⣁⣴⢯⣭⣵⣶⠾⠓⢀⣴</span></span><br><span class="line"><span class="comment">// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣉⣤⣴⣾⣿⣿⣦⣄⣤⣤⣄⠄⢿⣿</span></span><br><span class="line"><span class="comment">// ⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠈⢿</span></span><br><span class="line"><span class="comment">// ⣿⣿⣿⣿⣿⣿⡟⣰⣞⣛⡒⢒⠤⠦⢬⣉⣉⣉⣉⣉⣉⣉⡥⠴⠂⢸</span></span><br><span class="line"><span class="comment">// ⠻⣿⣿⣿⣿⣏⠻⢌⣉⣉⣩⣉⡛⣛⠒⠶⠶⠶⠶⠶⠶⠶⠶⠂⣸⣿</span></span><br><span class="line"><span class="comment">// ⣥⣈⠙⡻⠿⠿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⠿⠛⢉⣠⣶⣶⣿⣿</span></span><br><span class="line"><span class="comment">// ⣿⣿⣿⣶⣬⣅⣒⣒⡂⠈⠭⠭⠭⠭⠭⢉⣁⣄⡀⢾⣿⣿⣿⣿⣿⣿</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10100</span>;</span><br><span class="line">LL f[<span class="number">2</span>][<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Next(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> flag) &#123;</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">    x++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= <span class="number">10</span> &amp;&amp; y &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(x - y) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="number">11</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">10</span> || y &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T, x, y;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> l = !(i &amp; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">11</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">11</span>; k++) &#123;</span><br><span class="line">          f[l][j][k] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">11</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">11</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (f[!l][j][k] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (s[i] != <span class="string">'B'</span>) &#123;</span><br><span class="line">            tie(x, y) = Next(j, k, <span class="number">0</span>);</span><br><span class="line">            f[l][x][y] = max(f[l][x][y], f[!l][j][k] + (x + y == <span class="number">0</span>));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (s[i] != <span class="string">'A'</span>) &#123;</span><br><span class="line">            tie(x, y) = Next(j, k, <span class="number">1</span>);</span><br><span class="line">            f[l][x][y] = max(f[l][x][y], f[!l][j][k] + (x + y == <span class="number">0</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">11</span>; j++) &#123;</span><br><span class="line">        ret = max(ret, f[n &amp; <span class="number">1</span>][i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6494&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=6494&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文题面。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>[HDOJ1055] Color a Tree (贪心)</title>
    <link href="https://vincentxwd.github.io/blog/2019/04/13/HDOJ1055-Color-a-Tree-%E8%B4%AA%E5%BF%83/"/>
    <id>https://vincentxwd.github.io/blog/2019/04/13/HDOJ1055-Color-a-Tree-贪心/</id>
    <published>2019-04-13T05:43:39.000Z</published>
    <updated>2019-04-13T06:00:53.411Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1055" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1055</a></p><p>题意：一棵n个点的树，每个点有权重$w_i$，现在要求给树上的点从1~n打标记$id_i$， 使得$\sum_{i=1}^nw_i\times id_i$最小。</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1055" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1055</a></p><a id="more"></a><p>贪心，从树根开始，每次合并当前权重最大的点和它的父亲，合并之后的节点权重为总权重/子节点数。</p><p>由于每次合并都会导致当前父亲节点的子孙们权重+1，所以我们可以每次都加上当前点的子孙与其父亲包含的点数*当前点权重和的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, rt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tot, pre;</span><br><span class="line">  <span class="keyword">double</span> val, contain;</span><br><span class="line">&#125; f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;rt) &amp;&amp; n + rt) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[i].tot);</span><br><span class="line">      ret += f[i].tot;</span><br><span class="line">      f[i].val = f[i].tot;</span><br><span class="line">      f[i].contain = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">      f[v].pre = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">double</span> hi = <span class="number">-1e9</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt; f[j].val &amp;&amp; j != rt) &#123;</span><br><span class="line">          id = j;</span><br><span class="line">          hi = f[j].val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> pre = f[id].pre;</span><br><span class="line">      f[id].val = <span class="number">-1E9</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[j].pre == id) &#123;</span><br><span class="line">          f[j].pre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ret += f[id].tot * f[pre].contain;</span><br><span class="line">      f[pre].contain += f[id].contain;</span><br><span class="line">      f[pre].tot += f[id].tot;</span><br><span class="line">      f[pre].val = f[pre].tot / f[pre].contain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1055&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=1055&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意：一棵n个点的树，每个点有权重$w_i$，现在要求给树上的点从1~n打标记$id_i$， 使得$\sum_{i=1}^nw_i\times id_i$最小。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1055&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=1055&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>[Hihocoder1384] Genius ACM(倍增，贪心)</title>
    <link href="https://vincentxwd.github.io/blog/2019/04/11/hihocoder1384/"/>
    <id>https://vincentxwd.github.io/blog/2019/04/11/hihocoder1384/</id>
    <published>2019-04-11T15:04:07.000Z</published>
    <updated>2019-04-11T15:36:53.487Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://hihocoder.com/problemset/problem/1384" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1384</a></p><p><strong>n个数分成至少多少段，使得每段中最大和最小的m对数之差不大于k？</strong></p><a id="more"></a><p>这是一道很nice的题目，来自《算法竞赛进阶指南》P38.</p><p>考虑区间长度L，当然希望L越大越好，因为每段中最大和最小的m对数之差随着L递增，因此可以这样贪心。</p><p>于是倍增L，每次暴力check区间是否满足条件，复杂度是$Nlog^2N$，成功被卡。</p><p>考虑区间[l, r]和(r, r+p]的关系，我们每次必然会给(r, r+p]排序，但是[l, r]没有影响，只是最后判断[l, r+p]是否满足会影响到区间的长度，一旦判断可以继续扩大那么这个区间就不会再动了，因此这段区间是可以有序的。因此拆成[l, r]和(r, r+p]两段，每次对(r, r+p]排序，判断ok再与之前的区间merge即可。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500500</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL k, a[maxn], b[maxn], c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = r; i &lt; j &amp;&amp; cnt &lt; m; i++, j--, cnt++) &#123;</span><br><span class="line">    ret += (c[j] - c[i]) * (c[j] - c[i]);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; k) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(LL &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = l, j = mid;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; r || (i &lt; mid &amp;&amp; b[i] &lt; b[j])) &#123;</span><br><span class="line">      c[k] = b[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      c[k] = b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %lld"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      scan_d(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= n) &#123;</span><br><span class="line">      <span class="keyword">int</span> r = l, p = <span class="number">1</span>;</span><br><span class="line">      ret++;</span><br><span class="line">      b[l] = a[l];</span><br><span class="line">      <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r + p &gt; n) &#123;</span><br><span class="line">          p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// a[r+1, r+p]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt;= r + p; i++) &#123;</span><br><span class="line">          b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [l, r]</span></span><br><span class="line">        <span class="comment">// [r+1, r+p]</span></span><br><span class="line">        sort(b + r + <span class="number">1</span>, b + r + p + <span class="number">1</span>);</span><br><span class="line">        merge(l, r + p, r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ok(l, r + p)) &#123;</span><br><span class="line">          p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r += p;</span><br><span class="line">          p &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            b[i] = c[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      l = r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://hihocoder.com/problemset/problem/1384&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hihocoder.com/problemset/problem/1384&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n个数分成至少多少段，使得每段中最大和最小的m对数之差不大于k？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Hihocoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Hihocoder/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="倍增" scheme="https://vincentxwd.github.io/blog/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>再见2018</title>
    <link href="https://vincentxwd.github.io/blog/2019/01/20/goodbye-2018/"/>
    <id>https://vincentxwd.github.io/blog/2019/01/20/goodbye-2018/</id>
    <published>2019-01-19T17:13:59.000Z</published>
    <updated>2019-01-19T18:28:18.105Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这里只是很普通的个人2018年终总结，写在期末后，过年前。对于我来说，2018年绝对是我的一生中最不平凡的一年，是我人生轨迹发生重大转变的一年。</strong></p><a id="more"></a><p>我从来没有写过这样的回忆录，但是18年过得很不平常，不平常的事情总是希望自己永远记住，而把它们写下来是最好的方法。</p><h1 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h1><p>在2017年末，我同上百万人一样参加了全国硕士研究生统一招生考试，也就是俗称的考研。</p><p>虽然已经过去一年多了，但是我至今仍然很不愿意和别人讨论考研这个话题，每当有人跟我聊起考研，我总喜欢敷衍地打趣几句然后再玩几个自己觉得很有趣但是别人听不懂的梗，企图规避这个话题。因为我总是觉得自己很强，觉得考研那段时间自己和周围的人总是格格不入，于是产生了许多奇怪的不友好的想法，伤害了很多很多人包括我曾经的挚爱。</p><p>这一年来我从来没有认真地回忆过这三个月的考研经历（虽然现在也不想），不是因为复习多么单调多么辛苦不愿多提，而是在逃避自己那时候的不成熟对他人造成伤害的心理谴责。我把这段简短的总结写在最前面希望让自己永远不要再像以前一样急躁和爱迁怒于人。</p><h1 id="从北信科到计算所"><a href="#从北信科到计算所" class="headerlink" title="从北信科到计算所"></a>从北信科到计算所</h1><p>上半年考完研后开始忙毕业和所里的工作，算是从本科生到硕士生的一个过渡。我在所里认识了无论性格人品还是学术技术都超棒的师兄师姐，我不得不承认在计算所的这段时间对我的个人成长帮助非常大，我学会了如何做科研，如何去分析一个问题，以及面对一个问题应该怎么样去尝试解决。</p><p>我在这里完成了我的本科毕业论文。说来惭愧，我花了接近半年的时间才做完我的毕设，虽然时间很长，但是我真实觉得自己学到了很多东西。从一开始对图像处理和ML&amp;DL的一窍不通，到能够独立完成一个project和一篇论文，让我感觉自己几乎是恰好有了踏入科研的资格：我明白了在开始一个领域的研究之前一定要做足够多的调研，确保自己的工作不会重蹈覆辙；在分析问题时一定要考虑清楚这个问题的难点在什么地方，现在都有什么样的方法去克服这些难点，如果发现了没有人考虑到的问题或者是未曾有人解决过的难题，这或许就可能成为自己工作中的创新点；在做实验的时候一定要详细记录每一个实验的意义是什么（目的是为了解决什么问题、印证什么假设），并且要写清楚这个实验在整体系统上做了什么变动，期望的结果是什么，结果说明了什么，还要写清楚自己对结果的思考以及下一步的工作计划。实验中失败是非常常见的，只有在重复的试错中才有可能发现正确的结论（前提是自己的每一步都是经过深思熟虑的）。</p><p>同时这段时间我开始思考自己真正想要做的事情是什么，我意识到弄清楚自己的努力方向是多么重要，而要找到自己的目标不是一件容易的事情，最好的方法就是根据自己的兴趣一件又一件地去尝试。</p><h1 id="雁栖湖"><a href="#雁栖湖" class="headerlink" title="雁栖湖"></a>雁栖湖</h1><p>在雁栖湖的学习节奏很快，每一节课都会有很多很多听不懂的东西，所以在课后要下很多功夫。我的同学们都非常优秀，让我体会最深的还是大家对知识的一丝不苟的态度，对于一个问题或知识点，我的同学会思考很久并且确保自己完全弄明白以后才肯罢休。作为工程选手的我养成了许多的陋习，拿到一个东西很喜欢只了解它的IO，不关心它的机理，这对于做科研是很致命的缺点，而且我的性格是很急躁的，面对成片的公式很不愿意去推导。后来我尝试静下心来去推导一些公式时，发现在推导过程中也能学到很多东西。我现在才真正意识到自己应该静下心来做每一件事，好好磨一磨自己的急性子，遇到问题不要想当然。哎，明明都是小时候都应该知道的道理，结果到现在才真正意识到，果然以前是真的又菜又跳。</p><p>十月份完成了自己毕设相关的一篇论文，花了一个月的时间改了接近30稿才提交上去。这篇paper现在来看真的很水，但是毕竟花了时间写，也算是磨了自己的性格。</p><p>）PS：抱住了阳神的大腿完成了两门课的课设。</p><h1 id="新朋友"><a href="#新朋友" class="headerlink" title="新朋友"></a>新朋友</h1><p>国科大部分所的研一新生是在雁栖湖校区参加集中教学的，能认识来自353的舍友、计控704班等很多很多小伙伴们我真的感到非常开心。我感受到大家都是非常聪明的人，每个人真的都非常努力而且有自己的优势。我为能和大家成为同学而感到由衷的荣幸和自豪。</p><h1 id="ACM"><a href="#ACM" class="headerlink" title="ACM"></a>ACM</h1><p>ACM这个事情是很遗憾的，我本希望18年下半年能有机会继续打区域赛拿一块银牌，结果连资格都没有拿，后来发现硕士只有阳神他们队还有UCAS本科时的金牌爷去参赛，于是我释然了…</p><p>所以这一年没有什么成就，似乎顶多也就是kickstart拿到了a day with google还有google ai camp的入场券？</p><p>这一年依然没有拿到GCJ的T-shirt，依然没有上紫，依然有很多很多的知识点不懂和很多很多的题不会做…但是不知不觉算法竞赛已经不再是学习生活的全部了。我走进了一个更广阔的领域，遇到了新的问题，这迫使我去学习非常多的新知识。我看待这个领域就如同我看待算法竞赛一样，我不知道它最终会走向何方，也没有过多考虑自己付出的努力会获得怎样的回报。我只希望能凭借自己所学的知识解决一个又一个有趣又棘手问题，希望自己能够提出别人未曾发现的问题，希望自己能够在这个过程中获得快乐和满足。</p><h1 id="找实习"><a href="#找实习" class="headerlink" title="找实习"></a>找实习</h1><p>不是很想写这个的，担心被自己的老板看到2333。我在11、12月的时候面了很多公司的算法岗，全部都是一二线的互联网公司和AI独角兽公司，有内推也有自己砸简历，最终也是拿到了好几个offer。经过深思熟虑（实际是只参考了薪水）后决定去某血汗工厂（雾）。</p><p>我是在参加完a day with google之后才正式开始投简历找工作的，因为这个活动有一个HR帮忙改简历的环节，我就借机把自己的简历魔改了一把，发现真的有奇效。</p><p>此外，我发现和开发岗是有明显区别（废话）。</p><p>如果有朋友想了解更多的话可以给我发邮件，我个人认为还是有些参考价值的。</p><hr><p>太晚了先休息，感觉还有很多非学业的内容没有回忆到，有时间再写。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这里只是很普通的个人2018年终总结，写在期末后，过年前。对于我来说，2018年绝对是我的一生中最不平凡的一年，是我人生轨迹发生重大转变的一年。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="只言片语" scheme="https://vincentxwd.github.io/blog/categories/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>[Good Bye 2018 D] New Year and the Permutation Concatenation（组合数学）</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/31/cf1091d/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/31/cf1091d/</id>
    <published>2018-12-31T04:37:02.000Z</published>
    <updated>2019-01-01T05:27:17.791Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1091/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/D</a><br>题意：给一个由字典序顺序的全排列拼接成的数列，问其中有多少个长度为$n$的连续子序列和为$\dfrac{n(n+1)}{2}$<br><a id="more"></a></p><p>长度为$n$的子序列和为$\dfrac{n(n+1)}{2}$的意思就是说有多少个连续子序列是$1$到$n$的全排列。</p><p>这题场上是找规律拆分贡献递推+OEIS过的，早上重新按照拆分贡献再推了一下，发现其实完全不需要OEIS。</p><p>首先分析一下答案的贡献：</p><ol><li>$n!$个原始排列的贡献。</li><li>两个排列相交的贡献。</li></ol><p>第1部分非常容易，答案就是$n!$. 关键是第二个部分。</p><p>例如$n=4$，手写几个看看规律（我写了$(n-1)!+1=3!+1$个排列的串，多1个是为了说明规律，后面的结果以此类推）：</p><p>1234 1243 1324 1342 1423 1432 2134…</p><p>我们从第一个排列的第2个数字开始，于是可能的排列是：</p><p>1 <strong>2341 2431 3241 3421 4231</strong> 4322 134 …</p><p>我们发现，两个相邻的排列是从第一个排列的第2个数字开始数的时候（也就是数到第二个排列的第1个数），前面$3!-1=5$对排列都是合法的，当1432遇到2134时则构造不出来（是4322）。</p><p>由于开头的数字可以是1、2、3、4任意一个，每一个数字的作为开头都有5个答案，于是这种构造对答案的贡献是$5\times4=20$.</p><p>同理，从第一个排列的第3个数字开始，可能的排列是：</p><p>12 <strong>3412</strong> 4313 <strong>2413</strong> 4214 <strong>2314</strong> 3221 34 …</p><p>从第4个数字开始就都不行了。</p><p>于是我们发现：<strong>每次选第一个数列的第$k+1$个数字作为开头时，必须保证这两个数列的第$k$个数字相同，这样才能保证构造出来的是一个排列，这样的k可以从1取到n-1。</strong></p><p>找到了这样的贡献分布，可是计算上是有点麻烦的。正难则反，考虑找到两个数列的第$k-1$个数字不同的排列对数。我们发现$k=1$时候，1、2、3、4开头合法的各5个，那么一共有20个；$k=2$时，合法的有12个。以此类推，我们发现，针对每一个$k$，对于答案的贡献是$n!-n(n-1)..(n-k-1)$，于是总的贡献就是：<br>$$<br>n\times n!-\sum_{k=1}^{n-1}\dfrac{n!}{k!}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL,LL&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010000</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">LL n;</span><br><span class="line">LL a[maxn], f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LL ret = exgcd(b, a%b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span> </span>&#123;</span><br><span class="line">  LL x, y;</span><br><span class="line">  exgcd(a, mod, x, y);</span><br><span class="line">  <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">  f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">    f[i] = i * f[i<span class="number">-1</span>] % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  LL ret = n * f[n] % mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    LL tmp = f[n] * inv(f[i]) % mod;</span><br><span class="line">    ret -= tmp; ret += mod; ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1091/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1091/problem/D&lt;/a&gt;&lt;br&gt;题意：给一个由字典序顺序的全排列拼接成的数列，问其中有多少个长度为$n$的连续子序列和为$\dfrac{n(n+1)}{2}$&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1092E] Minimal Diameter Forest（树直径，DFS）</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/20/cf1092E/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/20/cf1092E/</id>
    <published>2018-12-19T16:08:16.000Z</published>
    <updated>2018-12-19T16:11:04.907Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1092/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1092/problem/E</a><br><strong>给一个森林，问将这个森林连成一棵树使得新成的树直径最短。</strong><br><a id="more"></a></p><p>显然，对于森林里的每一棵树，都选各自直径的中点作为树根，全部连到直径最长的那棵树的中心上就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1111</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], vis[maxn], pre[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; root;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> L = u, R = u;</span><br><span class="line">  <span class="keyword">int</span> v, d, len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; id;</span><br><span class="line"></span><br><span class="line">  vis[u] = <span class="number">1</span>; dep[u] = <span class="number">0</span>;</span><br><span class="line">  id.emplace(u);</span><br><span class="line">  q.emplace(u);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    u = q.front(); q.pop();</span><br><span class="line">    id.emplace(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">      vis[v] = <span class="number">1</span>;</span><br><span class="line">      dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">      q.emplace(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : id) <span class="keyword">if</span>(dep[x] &gt; dep[L]) L = x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : id) &#123;</span><br><span class="line">    dep[x] = <span class="number">0</span>;</span><br><span class="line">    vis[x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">  vis[L] = <span class="number">1</span>;</span><br><span class="line">  q.emplace(L);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    u = q.front(); q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">      vis[v] = <span class="number">1</span>;</span><br><span class="line">      dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">      pre[v] = u;</span><br><span class="line">      q.emplace(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : id) <span class="keyword">if</span>(dep[x] &gt; dep[R]) R = x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : id) len = max(len, dep[x]);</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(pre[R] != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[R] == max(len/<span class="number">2</span>, len-len/<span class="number">2</span>)) &#123;</span><br><span class="line">      root.emplace_back(R, len);</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R = pre[R];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!flag) root.emplace_back(R, len);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m)) &#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">    root.clear();</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) gao(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rt = <span class="number">1</span>, len = <span class="number">-1</span>;</span><br><span class="line">    sort(root.begin(), root.end(), [](pii a, pii b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;);</span><br><span class="line">    rt = root[<span class="number">0</span>].first, len = root[<span class="number">0</span>].second;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : root) &#123;</span><br><span class="line">      <span class="keyword">if</span>(p.first == rt) <span class="keyword">continue</span>;</span><br><span class="line">      edge.emplace_back(rt, p.first);</span><br><span class="line">      G[rt].emplace_back(p.first);</span><br><span class="line">      G[p.first].emplace_back(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, gao(rt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : edge) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x.first, x.second);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1092/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1092/problem/E&lt;/a&gt;&lt;br&gt;&lt;strong&gt;给一个森林，问将这个森林连成一棵树使得新成的树直径最短。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="DFS" scheme="https://vincentxwd.github.io/blog/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1092D1&amp;D2] Tree with Maximum Cost（栈）</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/19/cf1092D/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/19/cf1092D/</id>
    <published>2018-12-19T10:01:37.000Z</published>
    <updated>2018-12-19T12:21:02.850Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<br><a href="http://codeforces.com/contest/1092/problem/D1" target="_blank" rel="noopener">http://codeforces.com/contest/1092/problem/D1</a><br><a href="http://codeforces.com/contest/1092/problem/D2" target="_blank" rel="noopener">http://codeforces.com/contest/1092/problem/D2</a><br>题意：<br>希望用$2\times 1$的砖头搭出一面长为$n$并且每一个单位长度高度为$a_i$的墙，现在允许的操作是：<br>D1：横、竖都允许放<br>D2：只允许横着放<br>问是否能搭出指定高度的墙？<br><a id="more"></a></p><p>D1：可以贪心，由于当两个相邻的墙高度的奇偶性相同的时候，那么这两个墙可以看做一面墙，并且高度可以任意（允许任意+1）。于是我们考虑维护一个栈，从左到右贪心地判断当前墙是否与栈顶的墙高度的奇偶相同，如果相同则配对出栈，否则入栈等待与它配对的墙。当栈内为空或只有一个高度的时候（此时这个高度可以搭成比之前所有墙都高的情况，并且前面的墙总可以+1到这个高度），则说明可以搭出指定高度的墙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">      a[i] &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(st.empty()) &#123;</span><br><span class="line">        st.emplace(a[i]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(st.top() != a[i]) st.emplace(a[i]);</span><br><span class="line">      <span class="keyword">else</span> st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.size() &lt;= <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D2：考虑只允许横着放，那么只有在两个块一样高的时候才能+1. 于是考虑扫到每一个数的时候是否与栈顶这个数相同，如果相同的话则可以配对出栈；否则讨论一下大小：如果当前块比栈顶的高，那就不会再有机会更新到栈顶那个块，于是这种情况下是没有解的，否则还是有可能存在解的。有一个cha点在输出前，如果栈内存在元素那么这个块一定是最高的（其他所有块结对后+1直到这个块），否则是没有解的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">int</span> hi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">      hi = max(hi, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(st.empty()) &#123;</span><br><span class="line">        st.emplace(a[i]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(st.top() == a[i]) st.pop();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(st.top() &lt; a[i]) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> st.emplace(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.empty()) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.size() == <span class="number">1</span> &amp;&amp; st.top() == hi) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;br&gt;&lt;a href=&quot;http://codeforces.com/contest/1092/problem/D1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1092/problem/D1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://codeforces.com/contest/1092/problem/D2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1092/problem/D2&lt;/a&gt;&lt;br&gt;题意：&lt;br&gt;希望用$2\times 1$的砖头搭出一面长为$n$并且每一个单位长度高度为$a_i$的墙，现在允许的操作是：&lt;br&gt;D1：横、竖都允许放&lt;br&gt;D2：只允许横着放&lt;br&gt;问是否能搭出指定高度的墙？&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="栈" scheme="https://vincentxwd.github.io/blog/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1092F] Tree with Maximum Cost（树DP）</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/19/cf1092F/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/19/cf1092F/</id>
    <published>2018-12-19T09:43:20.000Z</published>
    <updated>2018-12-19T09:48:05.164Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1092/problem/F" target="_blank" rel="noopener">http://codeforces.com/contest/1092/problem/F</a><br><strong>寻找一个点，使得这个点到其他所有点的距离乘点权的和最大。</strong><br><a id="more"></a></p><p>考虑把点权和*距离拆分成两部分，一部分是当前点的所有子孙到当前点的距离，另一部分是其余点到当前点的距离。固定一个树根，第一部分可以dfs一遍更新过来，维护当前距离和以及所有点的权值和，每次更新时去掉当前点的权值。</p><p>第二部分由某点的父亲节点更新过来，稍微计算一下计数的公式就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">200200</span>;</span><br><span class="line">LL n;</span><br><span class="line">LL a[maxn], tot1[maxn], tot2[maxn];</span><br><span class="line">LL dp1[maxn], dp2[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(LL u, LL p)</span> </span>&#123;</span><br><span class="line">tot1[u] = a[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line"><span class="keyword">if</span>(p == v) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(v, u);</span><br><span class="line">tot1[u] += tot1[v];</span><br><span class="line">dp1[u] += dp1[v] + tot1[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(LL u, LL p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p != <span class="number">-1</span>) &#123;</span><br><span class="line">tot2[u] = tot2[p] + tot1[p] - tot1[u];</span><br><span class="line">dp2[u] = dp1[p] - dp1[u] - tot1[u] + dp2[p] + tot2[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line"><span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(v, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n)) &#123;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;a[i]);</span><br><span class="line">  G[i].clear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(tot1, <span class="number">0</span>, <span class="keyword">sizeof</span> tot1);</span><br><span class="line">  <span class="built_in">memset</span>(tot2, <span class="number">0</span>, <span class="keyword">sizeof</span> tot2);</span><br><span class="line">  <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span> dp1);</span><br><span class="line">  <span class="built_in">memset</span>(dp2, <span class="number">0</span>, <span class="keyword">sizeof</span> dp2);</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%I64d %I64d"</span>, &amp;u, &amp;v);</span><br><span class="line">  G[u].emplace_back(v);</span><br><span class="line">  G[v].emplace_back(u);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs1(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt;dp1[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  ret = max(ret, dp1[i]+dp2[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1092/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1092/problem/F&lt;/a&gt;&lt;br&gt;&lt;strong&gt;寻找一个点，使得这个点到其他所有点的距离乘点权的和最大。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="dp" scheme="https://vincentxwd.github.io/blog/tags/dp/"/>
    
      <category term="树" scheme="https://vincentxwd.github.io/blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>用JS实现UCAS半自动评教脚本</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/15/ucas-pingjiao/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/15/ucas-pingjiao/</id>
    <published>2018-12-15T10:53:56.000Z</published>
    <updated>2018-12-15T11:02:59.903Z</updated>
    
    <content type="html"><![CDATA[<p>自用，同学们有需要的话也可以拿去用。</p><p>打开你的评教页面，chrome按F12调出“检查”，打开Console选项后将下面代码粘贴并回车，保存退出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> td = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'td'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; td.length;i++) &#123;</span><br><span class="line">td[i].getElementsByTagName(<span class="string">"input"</span>)[<span class="number">0</span>].checked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">"input[name='starFlag']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"checked"</span>,<span class="string">"checked"</span>);</span><br><span class="line">$(<span class="string">"textarea[id='merit']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"value"</span>,<span class="string">"课程特色鲜明，内容取舍合理，组织严密，逻辑性强。重点突出，难点讲解清楚。拓展学生知识面，培养分析能力，引导创新。"</span>);</span><br><span class="line">$(<span class="string">"textarea[id='flaw']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"value"</span>,<span class="string">"无"</span>);</span><br><span class="line">$(<span class="string">"textarea[id='suggest']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"value"</span>,<span class="string">"无"</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自用，同学们有需要的话也可以拿去用。&lt;/p&gt;
&lt;p&gt;打开你的评教页面，chrome按F12调出“检查”，打开Console选项后将下面代码粘贴并回车，保存退出。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="工具" scheme="https://vincentxwd.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1084D] The Fair Nut and the Best Path（树DP）</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/11/cf1084d/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/11/cf1084d/</id>
    <published>2018-12-11T03:39:09.000Z</published>
    <updated>2018-12-11T06:33:52.940Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1084/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1084/problem/D</a></p><p><strong>有一棵树，每一个点和边都有权值。一个人希望从一个点走到另一个点，要求在走的过程中点权和不小于边权和。求最大的点权和与边权和之差。</strong></p><a id="more"></a><hr><p>首先可以知道的是，如果两个点之间是任意可达的话，那么走这两个点的时候点权和与边权和之差一定比只选中单个点更大；如果两个点中有一个点比边权小，那选最大的那一个点的收益一定会比全选要更大。</p><p>所以实际上不需要考虑某一个点到另一个点不可达的情况，因为反过来即使可达那也不会是最优的，因此实际上路径是没有必要考虑逆方向的。</p><p>根据上述规则，就可以确定考虑将答案拆成两种：</p><p>一种是当前点为端点的一条链的情况，这种情况需要维护随后可以走的差值最大的链。</p><p>另一种是以当前点为中间点，分别从两个子树中走过来的情况，这时候需要同时维护差值最大和次大的链。</p><p>于是我们相当于是在选转折点，这个并且在这个转折点上选两个权值和最大的子链，使得点权和-边权和最大。就有个问题了，选子链的时候，都是从子链走向转折点，而题目中实际上是应该有一个子链走向转折点，而另一个子链是转折点走过去的。考虑最大连续子序列和，当扫到&lt;0的前缀和时，那么会把当前的dp值设为0，和这个问题实际上是一样的，因此不需要考虑方向的问题了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300300</span>;</span><br><span class="line">LL dp1[maxn], dp2[maxn], d[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  dp1[u] = <span class="number">0</span>, dp2[u] = <span class="number">0</span>;</span><br><span class="line">  LL a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : G[u]) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = x.first, w = x.second;</span><br><span class="line">    <span class="keyword">if</span>(p == v) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    <span class="keyword">if</span>(dp1[v] - w &gt; a) &#123;</span><br><span class="line">      b = a;</span><br><span class="line">      a = dp1[v] - w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dp1[v] - w &gt; b) &#123;</span><br><span class="line">      b = dp1[v] - w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dp1[u] = max(dp1[u], a+d[u]);</span><br><span class="line">  dp2[u] = max(dp2[u], a+b+d[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;d[i]);</span><br><span class="line">      G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span> dp1);</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">0</span>, <span class="keyword">sizeof</span> dp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v, w;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      G[u].emplace_back(v, w);</span><br><span class="line">      G[v].emplace_back(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ret = max(ret, dp2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1084/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1084/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有一棵树，每一个点和边都有权值。一个人希望从一个点走到另一个点，要求在走的过程中点权和不小于边权和。求最大的点权和与边权和之差。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="dp" scheme="https://vincentxwd.github.io/blog/tags/dp/"/>
    
      <category term="树" scheme="https://vincentxwd.github.io/blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[BZOJ4017] [Noi2008]志愿者招募（单纯形法）</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/09/bzoj1061/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/09/bzoj1061/</id>
    <published>2018-12-08T16:11:28.000Z</published>
    <updated>2018-12-09T08:40:07.666Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1061" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=1061</a><br>申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要N 天才能完成，其中第i 天至少需要Ai 个人。 布布通过了解得知，一共有M 类志愿者可以招募。其中第i 类可以从第Si 天工作到第Ti天，招募费用是每人Ci 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。</p><a id="more"></a><hr><p>学习了一个学长的博客，真的很棒：<a href="https://www.hrwhisper.me/introduction-to-simplex-algorithm/" target="_blank" rel="noopener">https://www.hrwhisper.me/introduction-to-simplex-algorithm/</a></p><p>首先这题一定是规划问题，我们根据题意列出优化方程。比如测试样例：</p><p>3 3<br>2 3 4<br>1 2 2<br>2 3 5<br>3 3 2</p><p>我们设第$i$类志愿者招$x_i$个，那么目标是：<br>$$<br>\min 2x_1+5x_2+2x_3<br>$$<br>需要满足：<br>$$<br>x_1\geq 2<br>$$</p><p>$$<br>x_1+x_2\geq 3<br>$$</p><p>$$<br>x_2+x_3\geq 4<br>$$</p><p>对于这类$\min (CX); s.t.\ AX\geq Y$的问题，其对偶问题是：<br>$$<br>\max (YX’);s.t.\ A^TX’\leq C<br>$$<br>然后就会发现这个形式跟输入的格式完全一致了。</p><p>PS：至于为什么这个问题的线性规划一定保证是整数解，因为我们构造的矩阵是全幺模矩阵，有人出现则是1，不出现则是0，由全幺模矩阵的一个定理：对于任何整数向量b，方程组A的所有基本解为整数向量的充分条件是A为幺模矩阵。所以我们可以使用单纯形法解决这个整数规划问题。</p><p>套下模版。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Simplex &#123;</span><br><span class="line">  <span class="comment">// s.t. ax≤b</span></span><br><span class="line">  <span class="comment">// MAX cx</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10010</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1E-9</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1E18</span>;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="keyword">double</span> a[maxm][maxn], b[maxm], c[maxn], v;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    b[l] /= a[l][e];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j != e) a[l][j] /= a[l][e];</span><br><span class="line">    &#125;</span><br><span class="line">    a[l][e] = <span class="number">1</span> / a[l][e];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(a[i][e]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        b[i] -= a[i][e] * b[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(j != e) a[i][j] -= a[i][e] * a[l][j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i][e] = -a[i][e] * a[l][e];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v += c[e] * b[l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j != e) c[j] -= c[e] * a[l][j];</span><br><span class="line">    &#125;</span><br><span class="line">    c[e] = -c[e] * a[l][e];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> e = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(e = <span class="number">1</span>; e &lt;= n; e++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[e] &gt; eps) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(e == n + <span class="number">1</span>) <span class="keyword">return</span> v;</span><br><span class="line">      <span class="keyword">double</span> mn = inf;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][e] &gt; eps &amp;&amp; mn &gt; b[i] / a[i][e]) &#123;</span><br><span class="line">          mn = b[i] / a[i][e];</span><br><span class="line">          l = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(mn == inf) <span class="keyword">return</span> inf;</span><br><span class="line">      pivot(l, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxm], f[maxm], c[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="comment">// freopen("out", "w", stdout);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    Simplex::n = n, Simplex::m = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">      Simplex::c[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s[i],&amp;f[i],&amp;c[i]);</span><br><span class="line">      Simplex::b[i] = c[i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = s[i]; j &lt;= f[i]; j++) &#123;</span><br><span class="line">        Simplex::a[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(Simplex::simplex()+<span class="number">0.5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1061&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.lydsy.com/JudgeOnline/problem.php?id=1061&lt;/a&gt;&lt;br&gt;申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要N 天才能完成，其中第i 天至少需要Ai 个人。 布布通过了解得知，一共有M 类志愿者可以招募。其中第i 类可以从第Si 天工作到第Ti天，招募费用是每人Ci 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="单纯形法" scheme="https://vincentxwd.github.io/blog/tags/%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95/"/>
    
      <category term="线性规划" scheme="https://vincentxwd.github.io/blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder308E] tokitsukaze and Similar String (字符串哈希, 打表)</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/07/nowcoder308e/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/07/nowcoder308e/</id>
    <published>2018-12-07T15:42:49.000Z</published>
    <updated>2018-12-07T15:51:18.477Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/308/e" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/308/e</a></p><p>tokitsukaze获得了一个长度为n，由a-z小写字母组成的字符串。<br>我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。<br>操作是这样的：选择一个字符串，把字符串的每个字母都替换为字母表上的下一个字母，同时，我们认为z的下一个字母为a，比如选择”acdz”，操作一次后变为”bdea”。<br>现在tokitsukaze从字符串中任取两个子串，她想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。</p><a id="more"></a><hr><p>字符串哈希，好久没见到了。<br>这题可以预处理出变换26次的所有串，我们希望快速查询子串，于是想到用字符串哈希。<br>对于字符串$s$，我们预处理$hash[i]$为$s[1]\to s[i]$这个字符串前缀的哈希值，可以这样求：<br>$$<br>hash[i]=hash[i-1]*M+s[i]<br>$$<br>于是我们希望知道$s[i]\to s[j]$的哈希值，就可以：<br>$$<br>hash[j]-hash[i-1]\times M^{j-i+1}<br>$$<br>不用管hash的具体值，任其自然溢出就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ULL = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ULL m1 = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line">ULL vis[<span class="number">27</span>][maxn];</span><br><span class="line">ULL mul[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mul[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">    mul[i] = mul[i<span class="number">-1</span>] * m1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">int</span> x, y, len;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(t+<span class="number">1</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        vis[i][j] = vis[i][j<span class="number">-1</span>] * m1 + t[j] - <span class="string">'a'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        t[j] = <span class="string">'a'</span> + ((t[j] - <span class="string">'a'</span> + <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;len);</span><br><span class="line">      <span class="keyword">if</span>(x + len - <span class="number">1</span> &gt; n || y + len - <span class="number">1</span> &gt; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> ret = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[<span class="number">0</span>][x+len<span class="number">-1</span>]-vis[<span class="number">0</span>][x<span class="number">-1</span>]*mul[len] == vis[i][y+len<span class="number">-1</span>]-vis[i][y<span class="number">-1</span>]*mul[len]) &#123;</span><br><span class="line">          ret = min(ret, min(i, <span class="number">26</span>-i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret==<span class="number">0x7f7f7f7f</span>?<span class="number">-1</span>:ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>供复习使用：<a href="https://blog.csdn.net/richard_for_oi/article/details/79306985" target="_blank" rel="noopener">https://blog.csdn.net/richard_for_oi/article/details/79306985</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/308/e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/308/e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;tokitsukaze获得了一个长度为n，由a-z小写字母组成的字符串。&lt;br&gt;我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。&lt;br&gt;操作是这样的：选择一个字符串，把字符串的每个字母都替换为字母表上的下一个字母，同时，我们认为z的下一个字母为a，比如选择”acdz”，操作一次后变为”bdea”。&lt;br&gt;现在tokitsukaze从字符串中任取两个子串，她想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="字符串" scheme="https://vincentxwd.github.io/blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希" scheme="https://vincentxwd.github.io/blog/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="打表" scheme="https://vincentxwd.github.io/blog/tags/%E6%89%93%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder315E] 勇敢的妞妞 (思维，状压，记忆化搜索)</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/06/nowcoder315e/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/06/nowcoder315e/</id>
    <published>2018-12-06T13:15:55.000Z</published>
    <updated>2018-12-06T13:26:51.923Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/315/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/315/E</a></p><p>美丽的牛家庄受到了外星人的侵略, 勇敢的妞妞要上战场抵御侵略。</p><p>在妞妞上战场前, 村长牛牛给了妞妞N件装备, 妞妞需要选择其中的K件,装备在身上提升自己的战斗力。每件装备有5种属性增幅值,对于第i件装备它的属性增幅值为(ri1, ri2, ri3, ri4, ri5), 分别代表该装备对不同的属性值增幅。</p><p>当妞妞装备多件装备的时候,由于装备之前会互相影响, 对于每种属性值的增幅并不是所有装备该属性值之和, 而是该种属性值下所有装备中最大的属性值。而妞妞最终增加的战斗力为这5种属性值增幅之和。</p><p>妞妞一定要保卫牛家庄, 所以她希望她能提升尽可能多的战斗力, 请你帮帮她计算她最多能增加多少战斗力。</p><a id="more"></a><p>首先能想到的是当$K\geq 5$时，只要在N件装备里选出5种属性中分别的最大值即可。</p><p>由于只有5种属性，我们可以关心每件装备对不同属性组合的贡献，于是可以状态压缩，比如我只关心第1、3属性的装备谁最大，那么这个状态就是$(10100)_2$，我们记录每种状态下都是哪个装备能提供最大幅度的增长，维护这个数组$hi$.</p><p>接下来希望尝试不同子状态的组合，比如$(10100)_2$和$(01001)_2$可以组合成$(11101)_2$，那么他们对答案的贡献就是$hi(10100_2)+hi(01001_2)$。所以我们直接先写个爆搜。</p><p>发现这个爆搜的状态重复了，于是记忆化一下就可以剪掉一部分搜索分支了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, ret;</span><br><span class="line"><span class="keyword">int</span> hi[<span class="number">1</span>&lt;&lt;<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> r[maxn][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">6</span>][<span class="number">1</span>&lt;&lt;<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">int</span> done, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(~dp[cnt][done]) <span class="keyword">return</span> dp[cnt][done];</span><br><span class="line">  <span class="keyword">if</span>(cnt == k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>((i &amp; done)) <span class="keyword">continue</span>;</span><br><span class="line">    ret = max(ret, dfs(cnt+<span class="number">1</span>, done|i, i+<span class="number">1</span>) + hi[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[cnt][done] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;r[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="built_in">memset</span>(hi, <span class="number">0</span>, <span class="keyword">sizeof</span> hi);</span><br><span class="line">    <span class="keyword">if</span>(k &gt; <span class="number">5</span>) k = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> st = <span class="number">0</span>; st &lt; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); st++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(st &amp; (<span class="number">1</span> &lt;&lt; j)) tmp += r[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        hi[st] = max(hi[st], tmp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/315/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/315/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;美丽的牛家庄受到了外星人的侵略, 勇敢的妞妞要上战场抵御侵略。&lt;/p&gt;
&lt;p&gt;在妞妞上战场前, 村长牛牛给了妞妞N件装备, 妞妞需要选择其中的K件,装备在身上提升自己的战斗力。每件装备有5种属性增幅值,对于第i件装备它的属性增幅值为(ri1, ri2, ri3, ri4, ri5), 分别代表该装备对不同的属性值增幅。&lt;/p&gt;
&lt;p&gt;当妞妞装备多件装备的时候,由于装备之前会互相影响, 对于每种属性值的增幅并不是所有装备该属性值之和, 而是该种属性值下所有装备中最大的属性值。而妞妞最终增加的战斗力为这5种属性值增幅之和。&lt;/p&gt;
&lt;p&gt;妞妞一定要保卫牛家庄, 所以她希望她能提升尽可能多的战斗力, 请你帮帮她计算她最多能增加多少战斗力。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="思维" scheme="https://vincentxwd.github.io/blog/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="状压" scheme="https://vincentxwd.github.io/blog/tags/%E7%8A%B6%E5%8E%8B/"/>
    
      <category term="记忆化搜索" scheme="https://vincentxwd.github.io/blog/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder272D] Where are you (最小生成树，缩点，割边)</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/03/nowcoder272d/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/03/nowcoder272d/</id>
    <published>2018-12-03T09:52:01.000Z</published>
    <updated>2018-12-03T11:24:14.472Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/272/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/272/D</a></p><p>求无向图中必然在最小生成树上出现的边的条数。<br><a id="more"></a></p><p>根据最小生成树的构造方法可以知道，当最小生成树不唯一时，可以用某一条边替换树上相同权值的边。<br>考虑kruskal算法，我们按照相同的边进行分组，每次处理一个组，并把这组边加到之前已经处理好的连通块上后跑tarjan求桥。在这个组里如果有某条边是桥，那么这条边一定是会选中的就可以计数，之后清理一下标记就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">int</span> w;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">202001</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  pre[find(x)] = find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tarjan</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, next;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">  &#125;;</span><br><span class="line">  Edge edge[maxn];</span><br><span class="line">  <span class="keyword">int</span> ecnt, d, Y;</span><br><span class="line">  <span class="keyword">int</span> head[maxn], bridge[maxn];</span><br><span class="line">  <span class="keyword">int</span> low[maxn], dfn[maxn];</span><br><span class="line"></span><br><span class="line">  Tarjan() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(bridge, <span class="number">0</span>, <span class="keyword">sizeof</span> bridge);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    ecnt = <span class="number">0</span>; d = <span class="number">0</span>; Y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[ecnt].u = u, edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].idx = Y;</span><br><span class="line">    edge[ecnt].next = head[u]; head[u] = ecnt++;</span><br><span class="line">    edge[ecnt].u = v, edge[ecnt].v = u;</span><br><span class="line">    edge[ecnt].idx = Y++;</span><br><span class="line">    edge[ecnt].next = head[v]; head[v] = ecnt++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i=edge[i].next) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">      <span class="keyword">int</span> idx = edge[i].idx;</span><br><span class="line">      <span class="keyword">if</span>(p == idx) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">        dfs(v, idx);</span><br><span class="line">        low[u] = min(low[u], low[v]);</span><br><span class="line">        <span class="keyword">if</span>(low[v] == dfn[v]) &#123;</span><br><span class="line">          bridge[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Tarjan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;p)) &#123;</span><br><span class="line">    Tarjan t;</span><br><span class="line">    e.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      e.emplace_back(Edge(&#123;u,v,w&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e.begin(), e.end(), [](Edge a, Edge b) &#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = i;</span><br><span class="line">      <span class="keyword">while</span>(k &lt; m &amp;&amp; e[k].w == e[i].w) k++;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">        u = find(e[j].u), v = find(e[j].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        t.adde(u, v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">        u = find(e[j].u), v = find(e[j].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t.dfn[u]) t.dfs(u, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!t.dfn[v]) t.dfs(v, <span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">        u = find(e[j].u), v = find(e[j].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        t.dfn[u] = t.dfn[v] = <span class="number">0</span>;</span><br><span class="line">        t.low[u] = t.low[v] = <span class="number">0</span>;</span><br><span class="line">        t.head[u] = t.head[v] = <span class="number">-1</span>;</span><br><span class="line">        unite(u, v);</span><br><span class="line">      &#125;</span><br><span class="line">      i = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.ecnt; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(t.bridge[i]) ret++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/272/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/272/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求无向图中必然在最小生成树上出现的边的条数。&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="最小生成树" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="缩点" scheme="https://vincentxwd.github.io/blog/tags/%E7%BC%A9%E7%82%B9/"/>
    
      <category term="割边" scheme="https://vincentxwd.github.io/blog/tags/%E5%89%B2%E8%BE%B9/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder272B] Xor Path(树，异或，计数)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/30/nowcoder272b/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/30/nowcoder272b/</id>
    <published>2018-11-30T14:08:29.000Z</published>
    <updated>2018-12-03T09:52:25.761Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/272/B" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/272/B</a></p><p>给定一棵n个点的树，每个点有权值$A_i$. 定义$path(i,j)$表示$i$到$j$的最短路径上，所有点的点权异或和。对于$i=1\to n-1,j=i+1 \to n$，求所有$path(i,j)$的异或和。</p><a id="more"></a><p>考虑到这个问题只和每个点权的出现次数的奇偶有关系，那么我们可以分情况讨论下每个点在任意两点间的路径中都是如何出现的。</p><ul><li>对于叶子节点，只有n-1次（与其他点直连）。</li><li>对于非叶节点，则有：<ul><li>与其他点直连，出现n-1次。</li><li>这个点的子树中的任意两点进行连接，出现$\sum_{1\leq i&lt;j\leq n} child_i\times child_j$次，其中$child_i$表示第$i$个儿子为根节点的总点数（包括自己）。</li><li>这个点将子树和非子树分成两部分，这两部分互相连接。那么贡献是两部分点数的乘积。</li></ul></li></ul><p>只有一个地方的计算需要优化，那就是$k$个数任意取2个数的乘积之和，维护一个前缀和随便弄一下就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500500</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL w[maxn], son[maxn], cnt[maxn];</span><br><span class="line">LL out[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  son[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum, val;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    son[u] += son[v];</span><br><span class="line">    sum.emplace_back(son[v]);</span><br><span class="line">    val.emplace_back(son[v]);</span><br><span class="line">    tot++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) &#123;</span><br><span class="line">    sum[i] += sum[i<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">    out[u] += ((val[i] * (sum[tot<span class="number">-1</span>] - sum[i]))) % <span class="number">2</span>;</span><br><span class="line">    out[u] %= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">    <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span> son);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt[i] = (n - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">      cnt[i] += ((son[i] - <span class="number">1</span>) * (n - son[i])) % <span class="number">2</span>;</span><br><span class="line">      cnt[i] += out[i] % <span class="number">2</span>;</span><br><span class="line">      cnt[i] %= <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(cnt[i] &amp; <span class="number">1</span>) ret ^= w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/272/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/272/B&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一棵n个点的树，每个点有权值$A_i$. 定义$path(i,j)$表示$i$到$j$的最短路径上，所有点的点权异或和。对于$i=1\to n-1,j=i+1 \to n$，求所有$path(i,j)$的异或和。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="异或" scheme="https://vincentxwd.github.io/blog/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="计数" scheme="https://vincentxwd.github.io/blog/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>[POJ2887] Big String（块状链表）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/29/poj2887/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/29/poj2887/</id>
    <published>2018-11-29T10:34:14.000Z</published>
    <updated>2018-11-29T10:38:43.352Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2887" target="_blank" rel="noopener">http://poj.org/problem?id=2887</a><br><strong>给一个字符串，要求两个操作：</strong><br><strong>I ch p：在这个字符串第p个字符前插入字符ch</strong><br><strong>Q p：查询第p个位置的字符</strong><br><a id="more"></a></p><p>第一次写块状链表，还挺顺利的。。。<br>就是块大小调了几次wa了好几发。。。<br>块状链表比数组分块多了一个操作就是可以用拆分操作来支持插入操作。对于这个题来说就是当某个块中插入元素是块大小的2倍时，我们就可以把这个块拆成2个了。<br>我用的list可能常数可能比较大，但是非常好实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> bsize, len;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; be;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1001000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator p = be.begin(); p != be.end(); p++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;size() &gt;= <span class="number">2</span> * bsize) &#123;</span><br><span class="line">      <span class="built_in">string</span> a = p-&gt;substr(<span class="number">0</span>, bsize);</span><br><span class="line">      <span class="built_in">string</span> b = p-&gt;substr(bsize, p-&gt;length()-bsize);</span><br><span class="line">      <span class="comment">// cout &lt;&lt;*p&lt;&lt;" split: "&lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">      *p = b;</span><br><span class="line">      be.insert(p, a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator p = be.begin(); p != be.end(); p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; tot + p-&gt;size()) &#123;</span><br><span class="line">      tot += p-&gt;size();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos == tot+<span class="number">1</span>) <span class="keyword">return</span> (*p)[i];</span><br><span class="line">      <span class="keyword">else</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">char</span>* tmp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator p = be.begin(); p != be.end(); p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; tot + p-&gt;size()) &#123;</span><br><span class="line">      tot += p-&gt;size();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos -= tot;</span><br><span class="line">    p-&gt;insert(pos, tmp);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  len++;</span><br><span class="line">  maintain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">char</span> cmd[<span class="number">5</span>], tmp[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> pos;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  be.clear();</span><br><span class="line">  bsize = <span class="number">10000</span>;</span><br><span class="line">  be.push_back(s);</span><br><span class="line">  maintain();</span><br><span class="line">  <span class="keyword">int</span> q;</span><br><span class="line">  scan_d(q);</span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">    <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">      scan_d(pos);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, query(pos));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, tmp);</span><br><span class="line">      scan_d(pos);</span><br><span class="line">      pos--;</span><br><span class="line">      <span class="keyword">if</span>(pos &gt;= len) insert(len, tmp);</span><br><span class="line">      <span class="keyword">else</span> insert(pos, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=2887&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://poj.org/problem?id=2887&lt;/a&gt;&lt;br&gt;&lt;strong&gt;给一个字符串，要求两个操作：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;I ch p：在这个字符串第p个字符前插入字符ch&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Q p：查询第p个位置的字符&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/POJ/"/>
    
    
      <category term="分块" scheme="https://vincentxwd.github.io/blog/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="块状链表" scheme="https://vincentxwd.github.io/blog/tags/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[Hiho一下 第230周] Smallest Substring（贪心,RMQ)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/29/hihocoder1888/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/29/hihocoder1888/</id>
    <published>2018-11-29T03:45:12.000Z</published>
    <updated>2019-04-11T15:37:00.379Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://hihocoder.com/contest/hiho230/problem/1" target="_blank" rel="noopener">http://hihocoder.com/contest/hiho230/problem/1</a><br>题意：找一个字符串中长度为k的字典序最小的子串。<br><a id="more"></a></p><p>考虑贪心，每次选中整个串的最小字符，那么这个字符一定属于答案，这个字符右边的最小字符也一定属于答案。当处理完这个字符后继时，看看是否取够，如果没取够那么再处理这个字符的前驱，直到取够为止。</p><p>于是需要用ST表解决一下静态区间最值查询的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a[x] &lt; a[y]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">if</span>(a[x] == a[y]) <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="keyword">int</span>(<span class="built_in">log</span>(n+<span class="number">1.0</span>)/<span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">      dp[i][j] = gao(dp[i][j<span class="number">-1</span>], dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="keyword">int</span>(<span class="built_in">log</span>(r-l+<span class="number">1.0</span>)/<span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">  <span class="keyword">return</span> gao(dp[l][k], dp[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ret.size() == k || l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> id = query(l, r);</span><br><span class="line">  ret.emplace_back(id);</span><br><span class="line">  dfs(id+<span class="number">1</span>, r);</span><br><span class="line">  dfs(l, id<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;k,a+<span class="number">1</span>)) &#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    st();</span><br><span class="line">    ret.clear();</span><br><span class="line">    dfs(<span class="number">1</span>, n);</span><br><span class="line">    sort(ret.begin(), ret.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, a[ret[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://hihocoder.com/contest/hiho230/problem/1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hihocoder.com/contest/hiho230/problem/1&lt;/a&gt;&lt;br&gt;题意：找一个字符串中长度为k的字典序最小的子串。&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Hihocoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Hihocoder/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="RMQ" scheme="https://vincentxwd.github.io/blog/tags/RMQ/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1011] Round #499 (Div. 2)（树转RMQ+莫队 or 启发式合并）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/27/cf600E/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/27/cf600E/</id>
    <published>2018-11-27T04:07:15.000Z</published>
    <updated>2018-11-27T04:23:38.065Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/600/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/600/problem/E</a><br><strong>给一棵树，问从根节点开始每个节点的子树（包含这个节点）中的众数的和。</strong></p><a id="more"></a><p>一看到子树上的某种计数我就会非常自然地想到树转RMQ再做一些区间操作，当然这个题也不例外。。。</p><p>于是考虑把这棵树的查询转成区间查询，要查每一个节点的子树，那么就是有$n​$次查询。线段树是解决不了区间众数问题的，于是就想到去分块。但是这题的意思是众数如果出现多次那就要把他们都加起来，所以我们<strong>在维护每个数出现的次数的同时，还要维护每个次数对应的数字之和。</strong>更新的时候注意加加减减就可以了，还有就是每次更新当前最大次数$ret​$的时候遇到remove要判断一下当前这个出现次数是否已经没有数字了，遇到这种情况的时候，因为每次出现次数都-1，于是我们直接把$ret-1​$就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">using</span> Query = struct &#123; LL l, r, ret, id; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(LL &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v, n, sid, sz;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;LL&gt;&gt; G;</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; c, be, w;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Query&gt; q;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;LL, LL&gt; vis, tot;</span><br><span class="line">  <span class="keyword">while</span>(scan_d(n)) &#123;</span><br><span class="line">    G = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;LL&gt;&gt;(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;LL&gt;(<span class="number">0</span>));</span><br><span class="line">    c = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    w = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    q = <span class="built_in">vector</span>&lt;Query&gt;(n+<span class="number">1</span>);</span><br><span class="line">    sz = LL(<span class="built_in">sqrt</span>(n)); sid = <span class="number">0</span>;</span><br><span class="line">    vis.clear(); tot.clear();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      scan_d(c[i]);</span><br><span class="line">      tot[<span class="number">0</span>] += c[i];</span><br><span class="line">      be.emplace_back(i / sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      scan_d(u);</span><br><span class="line">      scan_d(v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(LL, LL)&gt; dfs = [&amp;](LL u, LL p) &#123;</span><br><span class="line">      q[u].l = ++sid; w[sid] = c[u]; q[u].id = u;</span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        LL&amp; v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">      &#125;</span><br><span class="line">      q[u].r = sid;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    sort(q.begin(), q.end(), [&amp;](Query a, Query b) &#123;</span><br><span class="line">      <span class="keyword">return</span> be[a.l] == be[b.l] ? a.r &lt; b.r : a.l &lt; b.l;</span><br><span class="line">    &#125;);</span><br><span class="line">    function&lt;<span class="keyword">void</span>(LL, LL&amp;)&gt; add = [&amp;](LL x, LL&amp; ret) &#123;</span><br><span class="line">      tot[vis[x]] -= x;</span><br><span class="line">      vis[x]++;</span><br><span class="line">      tot[vis[x]] += x;</span><br><span class="line">      ret = max(ret, vis[x]);</span><br><span class="line">    &#125;;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(LL, LL&amp;)&gt; remove = [&amp;](LL x, LL&amp; ret) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ret == vis[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot[vis[x]] - x == <span class="number">0</span>) &#123;</span><br><span class="line">          ret = vis[x] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      tot[vis[x]] -= x;</span><br><span class="line">      vis[x]--;</span><br><span class="line">      tot[vis[x]] += x;</span><br><span class="line">    &#125;;</span><br><span class="line">    LL L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span>(L &lt; q[i].l) &#123; remove(w[L], ret); L++; &#125;</span><br><span class="line">      <span class="keyword">while</span>(L &gt; q[i].l) &#123; L--; add(w[L], ret); &#125;</span><br><span class="line">      <span class="keyword">while</span>(R &lt; q[i].r) &#123; R++; add(w[R], ret); &#125;</span><br><span class="line">      <span class="keyword">while</span>(R &gt; q[i].r) &#123; remove(w[R], ret); R--; &#125;</span><br><span class="line">      <span class="comment">// LL p = 0;</span></span><br><span class="line">      <span class="comment">// printf("(%lld, %lld) : ", q[i].l,q[i].r);</span></span><br><span class="line">      <span class="comment">// for(auto x : vis) &#123;</span></span><br><span class="line">      <span class="comment">//   printf("%lld %lld, ", x.first, x.second);</span></span><br><span class="line">      <span class="comment">//   p = max(p, x.second);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// printf("\n");</span></span><br><span class="line">      <span class="comment">// for(auto x : vis) &#123;</span></span><br><span class="line">      <span class="comment">//   if(x.second == p) q[i].ret += x.first;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// cout &lt;&lt; p &lt;&lt; " " &lt;&lt; ret &lt;&lt; endl;</span></span><br><span class="line">      q[i].ret = tot[ret];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q.begin(), q.end(), [=](Query a, Query b)&#123;</span><br><span class="line">      <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, q[i].ret, <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题其实就是想教大家<strong>在维护每个数出现的次数的同时，还要维护每个次数对应的数字之和。</strong>我们冷静分析以后，发现这个题可以直接DFS。</p><p>我们希望在每次DFS的时候把子树中的数字出现情况merge到当前这个父亲上，考虑对每个点维护上述两个数组，每次把小的树更新到大的树上，merge的具体操作跟上述莫队的更新一样。</p><p>如何保证小集合merge到大集合上的复杂度？</p><p>Tutorial是这么解释的：“every time when vertex <em>v</em> will be moved from one <em>map</em> to another the size of the new map will be at least two times larger. So each vertex can be moved not over than $\log n$ times.”</p><p>发现merge的时候大集合至少是小集合的2倍，实际上就是说每次每个集合被遍历的次数都会减半，相当于最坏情况下每个点被遍历$\log n$次，于是merge的复杂度就是$n\log n $. 整体复杂度就是$O(n\log^2 n)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">100100</span>;</span><br><span class="line">LL n, c[maxn], id[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; G[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; cnt[maxn], tot[maxn];</span><br><span class="line">LL ret[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(LL u, LL v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cnt[id[u]].size() &lt; cnt[id[v]].size()) swap(id[u], id[v]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt[id[v]]) &#123;</span><br><span class="line">    tot[id[u]][cnt[id[u]][x.first]] -=  x.first;</span><br><span class="line">    cnt[id[u]][x.first] += x.second;</span><br><span class="line">    tot[id[u]][cnt[id[u]][x.first]] +=  x.first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LL u, LL p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">    LL&amp; v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    gao(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  ret[u] = tot[id[u]].rbegin()-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt[i].clear();</span><br><span class="line">      tot[i].clear();</span><br><span class="line">      G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;c[i]);</span><br><span class="line">      id[i] = i;</span><br><span class="line">      cnt[i][c[i]] = <span class="number">1</span>;</span><br><span class="line">      tot[i][<span class="number">1</span>] = c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%I64d%c"</span>, ret[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/600/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/600/problem/E&lt;/a&gt;&lt;br&gt;&lt;strong&gt;给一棵树，问从根节点开始每个节点的子树（包含这个节点）中的众数的和。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="莫队算法" scheme="https://vincentxwd.github.io/blog/tags/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="离线" scheme="https://vincentxwd.github.io/blog/tags/%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="树转RMQ" scheme="https://vincentxwd.github.io/blog/tags/%E6%A0%91%E8%BD%ACRMQ/"/>
    
      <category term="启发式合并" scheme="https://vincentxwd.github.io/blog/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
</feed>
