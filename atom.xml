<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kirai</title>
  
  <subtitle>Keep going</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://vincentxwd.github.io/blog/"/>
  <updated>2018-11-25T13:35:12.940Z</updated>
  <id>https://vincentxwd.github.io/blog/</id>
  
  <author>
    <name>Kirai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Nowcoder283J] RMQ (线段树)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/25/nowcoder283j/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/25/nowcoder283j/</id>
    <published>2018-11-25T13:21:25.000Z</published>
    <updated>2018-11-25T13:35:12.940Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/283/J" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/283/J</a></p><p>小姐姐想要一种数据结构，支持如下操作： </p><p>  对于一个整数数组：     </p><p>  \1. 给定L和R，输出[L,R]中元素的和 </p><p>  \2. 给定L，R和X，将[L,R]中每个元素与X进行按位或运算 </p><p>  \3. 数组索引从1开始 </p><p>  按位或在C\C++、Java、Python中为’|’运算符</p><a id="more"></a><p>难点在于如何处理或操作。</p><p>做过异或线段树的题，这个或自然会想到拆位处理，针对每一位建一棵线段树，如果或的数字的某一位为1时，则这一位（假设是第$i$位）在区间$[l,r]$对于答案（sum）的贡献为$2^i\times(r-l+1)$.</p><p>认真写一下lazy标记的处理就好，蛮好写。注意线段树$sum[rt][i]$的顺序，惨遭卡常。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">2</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> add[maxn&lt;&lt;<span class="number">2</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUP</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  sum[rt][i] = sum[rt&lt;&lt;<span class="number">1</span>][i] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDOWN</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(add[rt][i]) &#123;</span><br><span class="line">    add[rt&lt;&lt;<span class="number">1</span>][i] |= add[rt][i];</span><br><span class="line">    add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i] |= add[rt][i];</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sum[rt&lt;&lt;<span class="number">1</span>][i] = m - l + <span class="number">1</span>;</span><br><span class="line">    sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i] = r - m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[l]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[l] &amp; <span class="number">1</span>) sum[rt][i] = <span class="number">1</span>;</span><br><span class="line">      i++;</span><br><span class="line">      a[l] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(lson);</span><br><span class="line">  build(rson);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    sum[rt][i] = sum[rt&lt;&lt;<span class="number">1</span>][i] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    add[rt][i] = <span class="number">1</span>;</span><br><span class="line">    sum[rt][i] = (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pushDOWN(rt, l, r, i);</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= m) update(L, R, c, lson, i);</span><br><span class="line">  <span class="keyword">if</span>(R &gt; m) update(L, R, c, rson, i);</span><br><span class="line">  pushUP(rt, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1L</span>L &lt;&lt; i) * sum[rt][i];</span><br><span class="line">  &#125;</span><br><span class="line">  pushDOWN(rt, l, r, i);</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= m) </span><br><span class="line">    ret += query(L, R, lson, i);</span><br><span class="line">  <span class="keyword">if</span>(m &lt; R) </span><br><span class="line">    ret += query(L, R, rson, i);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> a, b, c;</span><br><span class="line">  <span class="keyword">char</span> cmd[<span class="number">5</span>];</span><br><span class="line">  scan_d(n);</span><br><span class="line">  scan_d(q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    scan_d(::a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">    <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">'S'</span>) &#123;</span><br><span class="line">      scan_d(a);</span><br><span class="line">      scan_d(b);</span><br><span class="line">      LL ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        ret += query(a, b, <span class="number">1</span>, n, <span class="number">1</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      scan_d(a); scan_d(b); scan_d(c);</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c &amp; <span class="number">1</span>) update(a, b, <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i);</span><br><span class="line">        i++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/283/J&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/283/J&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小姐姐想要一种数据结构，支持如下操作： &lt;/p&gt;
&lt;p&gt;  对于一个整数数组：     &lt;/p&gt;
&lt;p&gt;  \1. 给定L和R，输出[L,R]中元素的和 &lt;/p&gt;
&lt;p&gt;  \2. 给定L，R和X，将[L,R]中每个元素与X进行按位或运算 &lt;/p&gt;
&lt;p&gt;  \3. 数组索引从1开始 &lt;/p&gt;
&lt;p&gt;  按位或在C\C++、Java、Python中为’|’运算符&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="线段树" scheme="https://vincentxwd.github.io/blog/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder283H] 图论一顿套模版 (最短路)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/25/nowcoder283h/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/25/nowcoder283h/</id>
    <published>2018-11-25T13:21:25.000Z</published>
    <updated>2018-11-25T13:31:46.700Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/283/H" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/283/H</a></p><p>有N栋楼和M条道路<strong>（单向）</strong>，每条路都有“不整洁度”W，现在校方想知道从S楼到T楼的所有路径中，“不整洁度”<strong>乘积最小</strong>是多少。 由于答案可能很大，所以你需要将最后的答案对10E9+7取模。</p><a id="more"></a><p>因为权值会很大，所以直接拿乘积算最短路是不可以的，因为取模后数值大小无法比较。</p><p>需要注意的是，题目保证每一个权都是2的幂，虽然我没注意。。</p><p>于是我维护了权值的每一位，计算的时候只管它们最终都是2的多少次幂。</p><p>于是可以堆优化最短路，在堆里维护2的幂次，这样就能保证一个大小顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  LL v, w, next;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">50050</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxm = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">1E18</span>;</span><br><span class="line">LL n, m, ee, s, t;</span><br><span class="line">LL d[maxn][<span class="number">64</span>];</span><br><span class="line">LL head[maxn];</span><br><span class="line">Edge e[maxm];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;PLL, <span class="built_in">vector</span>&lt;PLL&gt;, greater&lt;PLL&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; n; x=(x*x)%mod,n&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = (ret * x) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ee = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(LL u, LL v, LL w)</span> </span>&#123;</span><br><span class="line">  e[ee].v = v; e[ee].w = w; e[ee].next = head[u]; head[u] = ee++;</span><br><span class="line">  <span class="comment">// e[ee].v = u; e[ee].w = w; e[ee].next = head[v]; head[v] = ee++;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL v, LL u, LL w=<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  LL a = <span class="number">0</span>, b = <span class="built_in">ceil</span>(<span class="built_in">log</span>(w)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">    a += d[v][i] * i;</span><br><span class="line">    b += d[u][i] * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get</span><span class="params">(LL u)</span> </span>&#123;</span><br><span class="line">  LL a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">    a += d[u][i] * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(LL &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v;</span><br><span class="line">  LL w;</span><br><span class="line">  <span class="keyword">while</span>(scan_d(n)) &#123;</span><br><span class="line">    scan_d(m);</span><br><span class="line">    scan_d(s);</span><br><span class="line">    scan_d(t);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) d[i][j] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      scan_d(u);</span><br><span class="line">      scan_d(v);</span><br><span class="line">      scan_d(w);</span><br><span class="line">      adde(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">      d[s][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.push(PLL(get(s), s));</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">      PLL tmp = pq.top(); pq.pop();</span><br><span class="line">      LL pw = tmp.first, u = tmp.second;</span><br><span class="line">      <span class="keyword">if</span>(get(u) &lt; pw) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(LL i = head[u]; ~i; i=e[i].next) &#123;</span><br><span class="line">        LL v = e[i].v; LL w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(check(v, u, w)) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">            d[v][j] = d[u][j];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> cur = <span class="built_in">ceil</span>(<span class="built_in">log</span>(w)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">          d[v][cur]++;</span><br><span class="line">          pq.push(PLL(get(v), v));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[t][<span class="number">0</span>] == inf) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(d[t][i]) &#123;</span><br><span class="line">        ret *= mul(<span class="number">2L</span>L,(i*d[t][i])%mod) % mod;</span><br><span class="line">        ret %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/283/H&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/283/H&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有N栋楼和M条道路&lt;strong&gt;（单向）&lt;/strong&gt;，每条路都有“不整洁度”W，现在校方想知道从S楼到T楼的所有路径中，“不整洁度”&lt;strong&gt;乘积最小&lt;/strong&gt;是多少。 由于答案可能很大，所以你需要将最后的答案对10E9+7取模。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="最短路" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder283F] 出装方案 (状压DP or 费用流)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/25/nowcoder283f/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/25/nowcoder283f/</id>
    <published>2018-11-25T13:21:25.000Z</published>
    <updated>2018-11-25T13:25:52.022Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/283/F" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/283/F</a></p><p>众所周知，在各种对抗类游戏里装备都是很重要的一环，不同的出装方案会给玩家带来不同的强度。 </p><p>  dalao手里有N件装备，现在dalao要把装备分给N个队友，每个队友只能分一件装备，而每个队友穿上不同的装备会有不同程度的强度提升。  </p><p>  现在给出每个队友对每件装备的强度提升的值，请问dalao的所有分配方案里，<strong>最多</strong>能让团队的<strong>总</strong>强度提升多少呢？</p><a id="more"></a><p>这题可以DP也可以费用流。</p><p>DP可以维护$f(i,st)$表示处理到前$i$个人，并且当前已经拿了$st$个装备时的最佳方案，转移就从$st$中未标记的转移就可以。由于只和上一层的状态有关，因此存储空间可以压下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      f[<span class="number">0</span>][<span class="number">1</span>&lt;&lt;i] = a[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> st = <span class="number">1</span>; st &lt; nn; st++) &#123;</span><br><span class="line">          <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; j) &amp; st) <span class="keyword">continue</span>;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][st|(<span class="number">1</span>&lt;&lt;j)] = max(f[i&amp;<span class="number">1</span>][st|(<span class="number">1</span>&lt;&lt;j)], f[!(i&amp;<span class="number">1</span>)][st]+a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[(n<span class="number">-1</span>)&amp;<span class="number">1</span>][nn<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>费用流也十分好想，一边是装备一边是人，超级源连装备费用为0容量为1，人连超级汇费用为0容量为1，内部装备的费用为装备提升的相反数容量为1，跑最大费用最大流即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, next;</span><br><span class="line">  LL c, w;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">0x3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">const</span> LL inf = (<span class="number">1L</span>L&lt;&lt;<span class="number">55</span>);</span><br><span class="line"><span class="keyword">int</span> tot, head[maxn];</span><br><span class="line">LL dist[maxn];</span><br><span class="line">LL cost, flow;</span><br><span class="line">Node e[maxm];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> S, T, N;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S = T = N = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c:容量, w:费用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL c, LL w)</span> </span>&#123;</span><br><span class="line">  e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">  e[tot].u = v; e[tot].v = u; e[tot].c = <span class="number">0</span>; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dist[i] = inf;</span><br><span class="line">    visit[i] = <span class="number">0</span>;</span><br><span class="line">    pre[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">  Q.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  pre[s] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q.front();</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(e[j].c &gt; <span class="number">0</span> &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123;</span><br><span class="line">        dist[e[j].v] = dist[u] + e[j].w;</span><br><span class="line">        pre[e[j].v] = j;</span><br><span class="line">        <span class="keyword">if</span>(!visit[e[j].v]) &#123;</span><br><span class="line">          Q.push(e[j].v);</span><br><span class="line">          visit[e[j].v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return dist[t] &lt; 0; // 求可行流</span></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 求最小费用流</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ChangeFlow</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  LL det = mod;</span><br><span class="line">  <span class="keyword">int</span> u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    det = min(det, e[u].c);</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    e[u].c -= det;</span><br><span class="line">    e[u ^ <span class="number">1</span>].c += det;</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> det;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">MinCostFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  LL mincost, maxflow;</span><br><span class="line">  mincost = maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(spfa(s, t, n)) &#123;</span><br><span class="line">    LL det = ChangeFlow(t);</span><br><span class="line">    mincost += det * dist[t];</span><br><span class="line">    maxflow += det;</span><br><span class="line">  &#125;</span><br><span class="line">  cost = mincost;</span><br><span class="line">  flow = maxflow;</span><br><span class="line">  <span class="keyword">return</span> mincost;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> to[maxn][maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T_T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T_T);</span><br><span class="line">  <span class="keyword">while</span>(T_T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    init();</span><br><span class="line">    S = <span class="number">0</span>, T = <span class="number">2</span> * n + <span class="number">1</span>, N = T + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      adde(S, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      adde(n+i, T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;to[i][j]);</span><br><span class="line">        adde(i,n+j, <span class="number">1</span>, -to[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, -MinCostFlow(S, T, N));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/283/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/283/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;众所周知，在各种对抗类游戏里装备都是很重要的一环，不同的出装方案会给玩家带来不同的强度。 &lt;/p&gt;
&lt;p&gt;  dalao手里有N件装备，现在dalao要把装备分给N个队友，每个队友只能分一件装备，而每个队友穿上不同的装备会有不同程度的强度提升。  &lt;/p&gt;
&lt;p&gt;  现在给出每个队友对每件装备的强度提升的值，请问dalao的所有分配方案里，&lt;strong&gt;最多&lt;/strong&gt;能让团队的&lt;strong&gt;总&lt;/strong&gt;强度提升多少呢？&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="费用流" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="状压DP" scheme="https://vincentxwd.github.io/blog/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] EM算法</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/21/em/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/21/em/</id>
    <published>2018-11-21T10:17:33.000Z</published>
    <updated>2018-11-21T14:31:36.489Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）中EM算法部分的笔记，书上总结得很精炼，有很多细枝末节的东西需要填充。</p><p>PDF版：<a href="http://pcoln8jiu.bkt.clouddn.com/em.pdf" target="_blank" rel="noopener">http://pcoln8jiu.bkt.clouddn.com/em.pdf</a></p><a id="more"></a><hr><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>书中将EM算法总结为估计参数隐变量的方法，它是一种迭代式算法：</p><p>若参数$\Theta$已知，则根据训练数据$D$推断出最优隐变量$Z$；若$Z$的值已知，则可对$\Theta$求极大似然估计。</p><p>步骤简单地可以总结为下面两步：<br>E步：利用当前估计的参数值$\Theta$计算对数似然的期望。</p><p>M步：寻找可以使E步产生的似然期望最大的$\Theta$。</p><p>上面两个步骤交替执行，直至收敛。</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>强烈建议观看徐亦达教授的EM算法视频：<a href="https://www.bilibili.com/video/av23901379" target="_blank" rel="noopener">https://www.bilibili.com/video/av23901379</a></strong></p><p>这部分之前写的不是很清楚，于是我决定重新看一下徐老师的视频和PPT，认真把EM算法框架推导和证明过一遍，再推导出高斯混合模型带入框架中的具体形式。</p><hr><p>EM算法是一个非常好的解决计算困难问题的思路，巧妙地引入隐变量（latent variables）避开一些复杂计算。首先从高斯混合模型引入问题：</p><h2 id="高斯混合模型（Gaussian-Mixture-Model-GMM）"><a href="#高斯混合模型（Gaussian-Mixture-Model-GMM）" class="headerlink" title="高斯混合模型（Gaussian Mixture Model, GMM）"></a>高斯混合模型（Gaussian Mixture Model, GMM）</h2><p>基于贝叶斯估计通常首先假设数据中的特征之间独立同分布。我们遇到数据集的分布无法仅用一个Gaussian Distribution拟合时通常考虑使用混合模型，Gaussian mixture model就是将多个高斯模型加权求和达到对拟合数据的目的。使用GMM描述一个数据集的分布可以表示成：<br>$$<br>p(X)=\sum_{i=1}^k\alpha_iN(X|\mu_i,\Sigma_i)<br>$$</p><p>$$<br>\sum\alpha_i=1<br>$$</p><p>$k$为高斯分布个数，$\Theta$表示高斯混合模型，$\alpha$为每个高斯分布的权，$N$表示一个高斯分布的概率值，定义为$f(x;\theta_i)$，是参数为$\theta_i$的高斯分布概率密度函数$\dfrac{1}{\sqrt{2\pi}\Sigma_i}exp(-\dfrac{(x-\mu_i)^2}{2\Sigma_i^2})$。$\mu、\Sigma$分别为每个高斯分布的参数。</p><p>对于整个GMM $\Theta$，我们需要确定的参数有$2k-1$个，即$\mu_1,…,\mu_k,\Sigma_1,…,\Sigma_k,\alpha_1,…,\alpha_{k-1}$.</p><p>插一句关于$\alpha_i$的来历：因为数据分布（或者说宽度）并不一定非常平均，我随便搜了一张图来解释一下：</p><p><img src="http://f.hiphotos.baidu.com/zhidao/wh%3D450%2C600/sign=4e7ea7a347a98226b8942323bfb29537/314e251f95cad1c8023cd9f17b3e6709c83d5164.jpg" alt="img"></p><p>比如这个图，很明显两个高斯分布比例不一样，因此用权重更合适。</p><p>我思考为什么权值和是1，参考了问答[1]：因为GMM的定义本质上是一个概率密度函数，概率密度函数在负无穷到正无穷内的积分为1，因此我们首先要满足概率密度函数的性质。</p><p>我们希望GMM更好地拟合数据集，也就是希望$p(x)$尽可能地大，于是通常利用对数似然估计对高斯混合模型进行调参，使得拟合特定的数据集。</p><p>这里再插一句：为什么不用一般的极大似然估计(MAP)？</p><p>这是我和师兄同学在饭桌上讨论过的一个问题，总结一下，原因有两条：</p><ol><li>因为极大似然估计是把所有概率乘在一起，每个概率值都是小数，数据量大了小数位精度会丢得非常厉害。</li><li>将连乘换成对数和的形式，求导方便。</li></ol><p>针对高斯混合模型，我们构造损失函数$L(\Theta)$：<br>$$<br>L(\Theta|X)=\sum_{i=1}^n \log p(X)<br>$$<br>即：<br>$$<br>L(\Theta|X)=\sum_{i=1}^n \log \sum_{j=1}^k\alpha_jN(x_i|\mu_j,\Sigma_j)<br>$$<br>于是我们的优化目标就是：<br>$$<br>\Theta^{MLE}=\mathop{argmax}_\Theta L(\Theta|X)<br>$$<br>虽然上式可导，但是无法一步到位，计算过程过于复杂。</p><p>考虑是不是可以有一个迭代的方法，求得$\Theta^{(1)},\Theta^{(2)},…,\Theta^{(t)}$，使得我们最后收敛？</p><hr><p>这是推导EM需要的前置知识，摆在这里。</p><h2 id="Jensen不等式-2"><a href="#Jensen不等式-2" class="headerlink" title="Jensen不等式[2]"></a>Jensen不等式[2]</h2><p>设$f$是定义域为实数的函数，如果对于所有的实数$x$，$f(x)$的二次导数大于等于0，那么$f是$凸函数。当$x$是向量时，如果其Hessian矩阵H是半正定的，那么$f$是凸函数。如果只大于0，不等于0，那么称$f$是严格凸函数。</p><p>Jensen不等式表述如下：</p><p>如果f是凸函数，$X$是随机变量，那么：$E[f(X)]\geq f(E[X])$，特别地，如果$f$是严格凸函数，当且仅当$X$是常量时，上式取等号。</p><p><img src="http://img.my.csdn.net/uploads/201301/24/1359004230_7889.jpg" alt="img"></p><p>图中，实线$f$是凸函数，$X$是随机变量，有0.5的概率是$a$，有0.5的概率是$b$。$X$的期望值就是$a$和$b$的中值了，图中可以看到$E[f(X)]\geq f(E[X])$成立。</p><p><strong>顺便，中国数学界关于函数凹凸性定义和国外很多定义是反的。国内教材中的凹凸，是指曲线，而不是指函数，图像的凹凸与直观感受一致，却与函数的凹凸性相反[3].</strong></p><hr><h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><p>直接给出EM算法需要迭代解决的基本任务：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}_\Theta\int_z \log p(X,z|\Theta)p(z|X,\Theta^{(t)}) \mathop{dz}<br>$$<br>当然这是最普遍的定义，如果放在离散问题上，那么$z$的数量是有限的于是可以写成：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}<em>\Theta\sum</em>{i=1}^k\log p(X,z_i|\Theta)p(z_i|X,\Theta^{(t)})<br>$$<br><strong>接下来会一步一步地推出上面这个迭代式。</strong></p><p>我再摆一下原来的优化目标：<br>$$<br>\Theta^{MLE}=\mathop{argmax}<em>\Theta\log \sum</em>{j=1}^k\alpha_jN(X|\mu_j,\Sigma_j)<br>$$<br>我们发现有2个不一样的地方：</p><ol><li>怎么多了个变量$z$？</li><li>这个$\sum$怎么跑$\log$左边去了？</li></ol><h5 id="怎么多了个变量？这对原目标不会有影响么？"><a href="#怎么多了个变量？这对原目标不会有影响么？" class="headerlink" title="怎么多了个变量？这对原目标不会有影响么？"></a>怎么多了个变量？这对原目标不会有影响么？</h5><p>首先，其实$z$是辅助变量，称为隐变量（latent variable），引入这个东西是EM算法的一个亮点。我记得在数据挖掘课上徐君老师点评SVM算法，说这是一个典型的“看似化简为繁”的工作，但是有了这一步，后面的计算往往会更加简便。</p><p>这和EM算法异曲同工，EM算法的提出者也看得很远，他对需要优化的损失函数引入辅助变量，而且必须保证加和不加的分布相同（保证加了$z$之后的边缘分布与原分布一致），也就是说，给出数据的概率分布，必须保证有：<br>$$<br>p(X)=\sum_{i=1}^kp(X|\Theta,z_i)p(\Theta,z_i)<br>$$<br>$p(X|\Theta,z_i)$表示对数据判断的似然（对应GMM中的概率密度函数$N$）</p><p>$p(\Theta,z_i)$表示先验（对应GMM中的权重$\alpha_i$）</p><p>我们这么定义，因此合适的$p$都不会有影响。</p><h5 id="这个-sum-怎么跑-log-左边去了？"><a href="#这个-sum-怎么跑-log-左边去了？" class="headerlink" title="这个$\sum$怎么跑$\log$左边去了？"></a>这个$\sum$怎么跑$\log$左边去了？</h5><p>保留这个问题，首先分析我们的优化目标。由于是迭代的，那么最基本的要求就是我们每次迭代都要使当前结果更加接近最终结果，也就是：<br>$$<br>\log p(X|\Theta^{(t+1)})\geq \log p(X|\Theta^{(t)})<br>$$<br>我们的目标是推出这样一个式子，此时已经没有隐变量$z$了。我们希望通过优化目标下式来得到上式的结果：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}<em>\Theta\sum</em>{i=1}^k\log p(X,z_i|\Theta)p(z_i|X,\Theta^{(t)})<br>$$<br>这个假设非常大胆，我们很轻易地发现这里其实蕴含了一个矛盾，我们定义$\Theta$是最终的优化结果，而$\Theta^{(t)}$却是当前步的最优目标，我们在计算过程中实际上并不知道$\Theta$，这完全是个Chicken and eggs problem。</p><p>如何处理并不是很显然，我们尝试推一下。首先知道：<br>$$<br>p(X)=\dfrac{p(X)p(XZ)}{p(XZ)}=\dfrac{p(XZ)}{p(Z|X)}<br>$$<br>于是：<br>$$<br>\log p(X|\Theta)=\log \dfrac{p(XZ|\Theta)}{p(Z|X\Theta)}= \log p(XZ|\Theta)-\log p(Z|X\Theta)<br>$$<br>那么它们在$Z$下的期望也一定相等，即：<br>$$<br>E_{p(Z|X\Theta^{(t)})}[\log p(X|\Theta)]= E_{p(Z|X\Theta^{(t)})}[\log p(XZ|\Theta)-\log p(Z|X\Theta)]<br>$$<br>等式左边展开期望的定义：<br>$$<br>E_{p(Z|X\Theta^{(t)})}[\log p(X|\Theta)]=\int_Z[\log p(X|\Theta)]p(z|X\Theta^{(t)})dz<br>$$</p><p>$$<br>=\log p(X|\Theta)\int_zp(z|X\Theta^{(t)})dz<br>$$</p><p>$$<br>=\log p(X|\Theta)<br>$$</p><p>等式右边，由期望可加性拆成两项差，期望定义展开：<br>$$<br>=\int_Z\log p(XZ|\Theta)p(z|X\Theta^{(t)})dz-\int_Z\log p(Z|X\Theta)p(z|X\Theta^{(t)})dz<br>$$<br><strong>这是整个EM算法里最tricky的部分（其次是引入latent variable）</strong>，仔细观察就会发现EM算法迭代优化的只是前面那个积分$\int_Z\log p(XZ|\Theta)p(Z|X\Theta^{(t)})dz$，所以接下来就是消掉后面这个积分，这个被消掉的过程是有点厉害的。。</p><p>前半部分定义给个记号：$Q(\Theta,\Theta^{(t)})$，后半部分定义为：$H(\Theta,\Theta^{(t)})$.</p><p>重申下我们的目标，希望推出最终优化目标为：<br>$$<br>\mathop{argmax}_{\Theta}[\int_Z\log p(XZ|\Theta)p(z|X\Theta^{(t)})dz]=\Theta^{(t)}<br>$$<br>那么到$t+1$步的时候，$Q$和$H$会变大还是变小？</p><p>讨论$Q$：（因为我们的最终目标就只包含Q，所以Q肯定单调增加啦）显然$Q(\Theta^{(t+1)},\Theta^{(t)})Q&gt;(\Theta,\Theta^{(t)})$.</p><p>讨论H：如果$H(\Theta^{(t)},\Theta^{(t)})\geq H(\Theta^{(t+1)},\Theta^{(t)})$，即$H$是单调递减的话就可以将优化目标的后半部分的积分约掉了，下面证明。</p><h5 id="证明-H-Theta-t-Theta-t-geq-H-Theta-Theta-t"><a href="#证明-H-Theta-t-Theta-t-geq-H-Theta-Theta-t" class="headerlink" title="证明$H(\Theta^{(t)},\Theta^{(t)})\geq H(\Theta,\Theta^{(t)})$"></a>证明$H(\Theta^{(t)},\Theta^{(t)})\geq H(\Theta,\Theta^{(t)})$</h5><p>$$<br>\int_z\log[p(z|X\Theta^{(t)})]p(z|X\Theta^{(t)})dz-\int_z\log[p(Z|X\Theta)]p(z|X\Theta^{(t)})dz<br>$$</p><p>即：<br>$$<br>\int_z\log[\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)}]p(z|X\Theta^{(t)})dz<br>$$<br>希望上式$\geq0$，ummmm…似乎做不下去了。</p><p>冷静分析，上面实际上是个函数的期望$E_Z(log[\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)}])$，里面有个$\log$实在太复杂，能不能把$\log$拿出来，比如写成$\log E(\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)})$.</p><p>我们再仔细考虑，诶？这个分子是$p(z|X\Theta^{(t)})$，跟$Z$下的概率一样嘛。于是保证这个函数的单调性的同时做一下变换：<br>$$<br>E_Z(log[\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)}])=E_Z(-log[\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}])<br>$$<br>我们要把$log$拿出来，于是作者想到了用Jensen不等式$E[f(X)]\geq f(E[X])$，函数的期望≥期望的函数，带进去就OK了：<br>$$<br>E_Z(-log[\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}])\geq -\log E_Z(\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})})<br>$$<br>展开不等式右边：<br>$$<br>-\log E_Z(\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})})=\int_Z \dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}p(z|X\Theta^{(t)})dz=-log(1)=0<br>$$<br>于是：<br>$$<br>E_Z(-log[\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}])\geq -\log E_Z(\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})})=0<br>$$<br>单调减的性质就证出来了。</p><p>所以我们的优化目标就是：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}<em>\Theta\sum</em>{i=1}^k\log p(X,z_i|\Theta)p(z_i|X,\Theta^{(t)})<br>$$<br>（$\sum$竟然跑到$\log$的左边去了）</p><hr><p>Reference：</p><p>徐老师的视频链接：<a href="https://www.bilibili.com/video/av23901379" target="_blank" rel="noopener">https://www.bilibili.com/video/av23901379</a></p><p>[1]. <a href="https://www.quora.com/Why-are-all-of-the-weights-in-Gaussian-mixture-models-supposed-to-be-positive" target="_blank" rel="noopener">https://www.quora.com/Why-are-all-of-the-weights-in-Gaussian-mixture-models-supposed-to-be-positive</a></p><p>[2]. <a href="https://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8537620</a></p><p>[3]. <a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7/4583322?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7/4583322?fr=aladdin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）中EM算法部分的笔记，书上总结得很精炼，有很多细枝末节的东西需要填充。&lt;/p&gt;
&lt;p&gt;PDF版：&lt;a href=&quot;http://pcoln8jiu.bkt.clouddn.com/em.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pcoln8jiu.bkt.clouddn.com/em.pdf&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundH] C. Let Me Count The Ways（容斥）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/18/GCJK2018HC/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/18/GCJK2018HC/</id>
    <published>2018-11-18T12:40:34.000Z</published>
    <updated>2018-11-18T13:12:08.947Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;a=2" target="_blank" rel="noopener">https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;a=2</a></p><p><strong>一共有$2n$个座位排成一排，现在有m对人去坐，每对人之间有顺序。每对人均不可以相邻，问一共有多少种坐法？</strong></p><a id="more"></a><p>考虑用总的排列数减去每对人都相邻的情况，于是我们发现后者的排列是可以容斥的。</p><p>设$f(k)$表示$k$对人均坐在一起的排列数，那么答案就是：<br>$$<br>\sum_{k=0}^m(-1)^kf(k)<br>$$<br>$f(k)$也比较容易算，可以由下面几个部分组合起来：</p><ol><li>$m$对中任取$k$对：$C(m,k)$</li><li>每对人有顺序，那么所有可能的排列就是$2^k$</li><li>在$2n​$个位置里面挑$k​$对位置，将两个相邻位置看成一个座位，那么相当于$2n-k​$个位置的排列，那么总计一共有$(2n-k)!​$种排列。</li></ol><p>于是$f(k)=C(m,k)2^k(2n-k)!$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod =(LL) <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8100001</span>;</span><br><span class="line">LL f[maxn];</span><br><span class="line">LL n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) f[i] = (f[i<span class="number">-1</span>] * i) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = (ret * x) % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    x = (x * x) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LL ret = exgcd(b, a%b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span> </span>&#123;</span><br><span class="line">  LL x, y;</span><br><span class="line">  exgcd(a, mod, x, y);</span><br><span class="line">  <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f[x] * inv(f[x-y]) % mod * inv(f[y]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL k = <span class="number">0</span>; k &lt;= m; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">ret += (f[<span class="number">2</span>*n-i]*C(m,i)%mod)*mul(<span class="number">2L</span>L,i)%mod;</span><br><span class="line">ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ret -= (f[<span class="number">2</span>*n-i]*C(m,i)%mod)*mul(<span class="number">2L</span>L,i)%mod;</span><br><span class="line">ret += mod;</span><br><span class="line">ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) ret += mod;</span><br><span class="line"><span class="keyword">return</span> ret % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="comment">// freopen("out", "w", stdout);</span></span><br><span class="line">init();</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _ &lt;&lt; <span class="string">" Done."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, gao());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;amp;a=2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;amp;a=2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一共有$2n$个座位排成一排，现在有m对人去坐，每对人之间有顺序。每对人均不可以相邻，问一共有多少种坐法？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="组合数学， 容斥" scheme="https://vincentxwd.github.io/blog/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C-%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces521E] Thematic Contests(贪心)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/17/cf521E/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/17/cf521E/</id>
    <published>2018-11-16T18:05:11.000Z</published>
    <updated>2018-11-16T18:11:45.208Z</updated>
    
    <content type="html"><![CDATA[<p>赛后4min过题的感觉真不爽啊……</p><p>题目链接：<a href="http://codeforces.com/contest/1077/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1077/problem/E</a></p><p><strong>题意：要$n$个题出比赛，每一个题有一个类型$a_i$，要求每一天出的比赛都是同一种类型的题，并且每一种类型在这几天内只出现一次，并且当前一天出题数是前一天的2倍，问这些天最多出多少题。</strong></p><a id="more"></a><p>首先维护一下每一种题出现的次数，我们只需要操作这个次数就可以了。</p><p>对题目出现次数从大到小排个序，接下来我们考虑枚举题目的上界，然后往下枚举就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;LL,LL&gt; vis;</span><br><span class="line">LL n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL a;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n)) &#123;</span><br><span class="line">    vis.clear();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;a);</span><br><span class="line">      vis[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; cnt;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : vis) &#123;</span><br><span class="line">      cnt.emplace_back(x.second);</span><br><span class="line">      ret = max(ret, x.second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cnt.begin(), cnt.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      LL t = i;</span><br><span class="line">      LL tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt.size(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(cnt[j] &gt;= t) tmp += t;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[j] &lt; t) <span class="keyword">break</span>;</span><br><span class="line">        tmp += t;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ret = max(ret, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;赛后4min过题的感觉真不爽啊……&lt;/p&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1077/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1077/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意：要$n$个题出比赛，每一个题有一个类型$a_i$，要求每一天出的比赛都是同一种类型的题，并且每一种类型在这几天内只出现一次，并且当前一天出题数是前一天的2倍，问这些天最多出多少题。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 支持向量机（SVM）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/16/svm/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/16/svm/</id>
    <published>2018-11-16T14:16:23.000Z</published>
    <updated>2018-11-17T09:01:00.923Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第六章（支持向量机）的笔记。支持向量机最根本的想法是利用数据集找到一个超平面，将两类的样本分隔开，并且这个超平面距离两类数据的支持向量最远。支持向量指的是距离超平面最近的几个点。</p><a id="more"></a><hr><p>HEXO特别坑，我的数学公式在typora中编辑正常，但是生成静态页面时就解析错误了，只好上传图片外加附PDF文件了：<a href="http://pcoln8jiu.bkt.clouddn.com/svm.pdf" target="_blank" rel="noopener">http://pcoln8jiu.bkt.clouddn.com/svm.pdf</a></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_1.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_2.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_3.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_4.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_5.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_6.Jpeg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第六章（支持向量机）的笔记。支持向量机最根本的想法是利用数据集找到一个超平面，将两类的样本分隔开，并且这个超平面距离两类数据的支持向量最远。支持向量指的是距离超平面最近的几个点。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces520D] Fun with Integers (规律，并查集)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/16/cf520d/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/16/cf520d/</id>
    <published>2018-11-15T17:16:26.000Z</published>
    <updated>2018-11-15T17:43:12.470Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1062/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/D</a></p><p>给一个$n$，现在允许任意初始一个数$k$并给定一个操作：$ax=b$，$bx=a$当且仅当$a$为$b$的倍数或$b$为$a$的倍数时，可以将$a$变为$b$（可以是负数），同时获得分数$|x|$. 要求不允许有多次$a$到$b$或$b$到$a$的操作（每个$x$仅算一次），问最多能得多少分。</p><a id="more"></a><p>看到第一个样例就明白了：考虑一个数$x$和它的因数$p_i$，我们总可以由$x$转到所有$\pm p_i$的可能（从$x$转到$p_i$，再由$p_i$转到$-x$，然后是$-x$到$-p_i$，接着是$-p_i$到$x$），每一次的贡献是$4p_i$，于是我们考虑维护所有带有整除关系的连通块，然后计算它们的所有倍数和*4就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line">LL s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  pre[find(x)] = find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">        unite(i, i*j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">        s[find(i)] += (LL)j &lt;&lt; <span class="number">2L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = max(ret, s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1062/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1062/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给一个$n$，现在允许任意初始一个数$k$并给定一个操作：$ax=b$，$bx=a$当且仅当$a$为$b$的倍数或$b$为$a$的倍数时，可以将$a$变为$b$（可以是负数），同时获得分数$|x|$. 要求不允许有多次$a$到$b$或$b$到$a$的操作（每个$x$仅算一次），问最多能得多少分。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="规律" scheme="https://vincentxwd.github.io/blog/tags/%E8%A7%84%E5%BE%8B/"/>
    
      <category term="并查集" scheme="https://vincentxwd.github.io/blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] Bayes分类器</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/10/bayes/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/10/bayes/</id>
    <published>2018-11-10T14:08:12.000Z</published>
    <updated>2018-11-12T03:34:44.015Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）的笔记。</p><a id="more"></a><hr><h2 id="贝叶斯决策论"><a href="#贝叶斯决策论" class="headerlink" title="贝叶斯决策论"></a>贝叶斯决策论</h2><p>使用贝叶斯决策论解决问题时的目标实际上是“最小化总体风险”，可以形式化表示成下式：<br>$$<br>R(c_i|x)=\sum_{j=1}^{n}\lambda_{ij}P(c_j|x)<br>$$<br>$\lambda_{ij}$：$i$类误分类成$j$类的代价。</p><p>$P(c_i|x)$：样本$x$分类成$c_i$的概率。</p><p>贝叶斯决策论希望找到一个最小化总体风险的判别准则$h(x)$，对于分类任务则是一个分类准则（$h(x)$表示将$x$归类为$h(x)$类），使得上述总体风险最小：<br>$$<br>h(x)=\mbox{argmin}\ R(c|x)<br>$$</p><hr><h2 id="贝叶斯准则"><a href="#贝叶斯准则" class="headerlink" title="贝叶斯准则"></a>贝叶斯准则</h2><p>贝叶斯准则可以简单理解为“整体风险最小化=每个样本的风险最小化”，风险指的是（比如在分类问题中）被分成错误类的期望。</p><p>能够使用贝叶斯准则的前提是获得后验概率$P(c|x)$，贝叶斯分类器此类生成模型则会考虑使用贝叶斯定理来求解这个后验概率：<br>$$<br>P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}<br>$$<br>解释一下公式中的每一个量的意义：</p><p>$P(c|x)$：<strong>后验概率</strong>，认为$x$分类成$c$的概率。</p><p>$P(c)$：<strong>先验概率</strong>，从公式上直观上看就是“偏见”、“第一眼看到这个人就觉得他是坏人”这样的概率。</p><p>$P(x|c)$：$x$相对于$c$的类条件概率，也称<strong>似然</strong>。指的是已知某些观测所得到结果（类别是$c$）时，对有关事物的性质（恰好是样本$x$）的参数进行估计[1]。</p><p>$P(x)$：用于归一化的因子，$P(x)=\sum_{i=1}^{n}P(x|c=i)P(c=i)$.</p><p>贝叶斯定理实际上就是希望通过已知相当数量的训练数据集合$D$，我们希望找到一个合理的方法来估计$D$中的$P(c)$和$P(x|c)$：</p><p>我们假设训练集中的训练数据独立同分布，那么根据大数定律，$P(c)$可以用每一类样本的<strong>频率</strong>来估计。</p><p>$P(x|c)$很难使用频率估计，因为$D$中的样本$x$通常无法完全覆盖所有情况：未被数据集覆盖$\not=$出现概率为0。于是需要使用<strong>极大似然估计</strong>.</p><hr><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计(MLE)"></a>极大似然估计(MLE)</h2><p>书中首先在介绍Logistic回归的时候使用了MLE（对数似然），但是没有仔细介绍。</p><p>首先假设数据集符合某种概率分布$D(\theta_c)$，被分成不同类完全取决于参数向量$\theta_c$.训练模型的过程就是参数估计的过程。</p><p>极大似然估计（MLE）就是一种参数估计方法，估计方法完全写在名字里了：似然（$P(x|c)$）极大化。由于分类结果完全取决于$\theta_c$，因此这个似然可以表示成$P(x|\theta_c)$.介绍贝叶斯准则的时候也讲了，“整体风险最小化=每个样本的风险最小化”。因此$\theta_c$对于整个数据集$D​$的似然就是：<br>$$<br>P(D|\theta_c)=\prod_{x\in D}P(x|\theta_c)<br>$$<br>我们给它取对数（因为小数连乘会导致精度损失）：<br>$$<br>L(\theta_c)=logP(D|\theta_c)=\sum_{x\in D}\mbox{log}P(x|\theta_c)<br>$$<br>我们对$\theta_c$的估计为：<br>$$<br>\hat{\theta_c}=\mbox{argmax}_{\theta_c}L(\theta_c)<br>$$<br>分析到这里这个式子已经展不开了，因为每个样本具体的似然取决于<strong>我们假设的是哪个分布</strong>，比如概率密度函数服从正态分布$\N(\mu_c,\sigma^2_c)$，那么对于它的参数$\mu_c$和$\sigma_c^2$的极大似然估计分别为数据集的均值$\dfrac{\sum_{x\in D}x}{|D|}$和方差$\dfrac{\sum_{x\in D}(x-\hat{\mu_c})^2}{|D|}$。</p><p>（然而我认为通常这么随意假设数据分布是不科学的= =）</p><hr><h2 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h2><p>由于$P(x|c)$是所有属性的联合概率，难以估计属性之间的关系，为了避免计算上的问题，引入属性条件独立性假设。</p><p>属性条件独立性假设：假设所有属性（理解：样本$x$中的每一维）相互独立。</p><p>于是$P(c|x)$重写为：<br>$$<br>P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}=\dfrac{P(c)}{P(x)}\sum_{i=1}^dP(x_i|c)<br>$$<br>$d$为属性数，$x_i$为样本$x$在第$i$个属性的取值。对于每个类$c$，$P(x)$都一样。在计算过程中可以忽略，于是：<br>$$<br>h(x)=\mbox{argmin}\ R(c|x)<br>$$</p><p>$$<br>=\mbox{argmax}\ P(c|x)<br>$$</p><p>$$<br>=\mbox{argmax}\ P(c)\prod_{i=1}^dP(x_i|c)<br>$$</p><p>$P(c)$：可以由每类的样本出现<strong>频率</strong>获得。</p><p>$P(x_i|c)$：针对离散的情况，可以根据类别是$c$并且含有属性$x_i$的出现<strong>频率</strong>获得；针对连续的情况，用密度函数。</p><p>一句话：于是计算贝叶斯实际上就是算两个量：$P(c)$和$P(x_i|c)$，按照两个量对应样本的<strong>频率</strong>获得一个概率，然后再用$h(x)$的计算方法乘出不同属性对应不同分类的极大似然估计即可。</p><hr><h2 id="缺省值处理"><a href="#缺省值处理" class="headerlink" title="缺省值处理"></a>缺省值处理</h2><p>有时会遇到某个样本某个属性缺失的情况，但是又不至于将该样本删除，于是需要进行平滑处理。拉普拉斯修正。</p><hr><h2 id="半朴素贝叶斯"><a href="#半朴素贝叶斯" class="headerlink" title="半朴素贝叶斯"></a>半朴素贝叶斯</h2><p>适当考虑部分属性的相互依赖信息，半朴素贝叶斯使用<strong>“独依赖估计”</strong>，即每个属性至多依赖于一个其他属性。<br>$$<br>P(c|x) \propto P(c)\prod_{i=1}^dP(x_i|c_,pa_i)<br>$$<br>$pa_i$：$x_i$所依赖的属性（$x_i$的父属性），计算过程就是将任意两个属性之间的依赖信息$I(x_i,x_j)$为边权建图，跑最大生成树。</p><hr><h2 id="贝叶斯网"><a href="#贝叶斯网" class="headerlink" title="贝叶斯网"></a>贝叶斯网</h2><p>贝叶斯网是个有向无环图，用点表示属性，权值为属性发生的概率，边表示依赖关系，边权为条件概率。例如$A$有一条指向$B$的边，点权描述的是$P(A)$、$P(B)$，这条边的权描述的就是$P(B|A)$. 没有边相连的两个点之间是相互独立的。</p><p>有一个笔记[2]中的例子非常形象地描述了相互独立的性质：</p><p>一个聪明人，在一场很难的考试里拿了高分，却得到了一封很烂的推荐信，同时他SAT考试却是高分的概率是多少？</p><p>我们再隐藏一些细节，一个人推荐信很烂，他SAT高分的概率是多少？或者，一个人SAT低分，却手握牛推的概率是多少？</p><p>如果不考虑随机变量之间的依赖关系，上述内容是很难计算的。但是如果有一个构建好的概率图，上面的问题则可以转化为条件概率问题。</p><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>已知网络结构的话，那么贝叶斯网上的各种信息是很容易统计的，按照网络要求和训练数据统计不同<strong>频率</strong>即可。</p><p>若网络结构未知，将贝叶斯网的学习看作是一个数据压缩任务，目标是<strong>学习到一个能以最短编码长度描述训练数据的模型</strong>。定义评分函数：<br>$$<br>s(B|D)=f(\theta)|B|-L(B|D)<br>$$<br>s(B|D)：在数据集$D$条件下的贝叶斯网$B$的评分函数。</p><p>$|B|$：贝叶斯网的参数个数。</p><p>$f(\theta)$：描述每个参数$\theta$所需字节数</p><p>$L(B|D)$：贝叶斯网的对数似然。</p><p>我们最终的目的是寻找一个$B$使$s$(B|D)最小，$f(\theta)$可以取1或者$\dfrac{1}{2}\mbox{log}\ m$，分别称为AIC和BIC。</p><h4 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h4><p>不能直接根据贝叶斯网定义的联合概率分布来计算后验概率，因为网络节点多的稠密图推理是NP-hard的。于是可以借助<strong>近似推断</strong>，常用Gibbs采样完成，先跳过了= =、</p><hr><p>Reference：</p><p>[1]. <a href="https://blog.csdn.net/lwq1026/article/details/70161857" target="_blank" rel="noopener">https://blog.csdn.net/lwq1026/article/details/70161857</a></p><p>[2].  <a href="https://www.cnblogs.com/ironstark/p/5087081.html" target="_blank" rel="noopener">https://www.cnblogs.com/ironstark/p/5087081.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] Bias-Variance Dilemma</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/05/BiasVarianceTradeoff/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/05/BiasVarianceTradeoff/</id>
    <published>2018-11-05T04:08:12.000Z</published>
    <updated>2018-11-08T14:26:18.237Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Deliberate Practice$\ ^{[1]}$：to identify your weakest areas and direct a massive effort on improving those areas without worrying about areas in which you are already good.</strong></p><p>这是我在阅读西瓜书第二章时的一个遗留问题，是关于偏差-方差窘境（Bias-Variance Dilemma）的内容。</p><a id="more"></a><p>首先要解释Bias-Variance Tradeoff，也就是偏差-方差权衡，譬如当前有一个拟合任务，需要构造一个多项式函数去拟合它，函数可以构造成这样：<br>$$<br>y=a_0+a_1x+a_2x^2+…+a_nx^n<br>$$<br>如何确定$n$的大小就是一个偏差-方差的权衡问题，。图像上直观地看则是为了确定这条曲线的“弯曲程度”。</p><p>曲线拟合和机器学习：前者是利用数据尽可能地拟合出一条完美的曲线；后者则是在有限的数据规模内进行学习，目的是遇到未知数据时能够做出最好的判断。</p><p>模型的泛化能力可以由泛化误差来描述，泛化误差越小，模型的期望泛化能力越强。模型$f$在数据集$D$上的泛化误差可以分解为偏差$bias$、方差$var$、噪声$\epsilon$之和：<br>$$<br>E(f;D)=\mbox{bias}^2(x)+\mbox{var}(x)+\epsilon^2<br>$$<br>递推可以在西瓜书P45翻到。</p><p>噪声指的是学习算法本身固有的误差（系统误差）和数据集的噪声。当保证数据集十分纯净的时候，人为可控的部分就只有偏差和方差了。于是机器学习中存在偏差-方差窘境：<strong>偏差(bias)描述的是模型的拟合能力，偏差过大可以认为是欠拟合；方差(variance)则描述的是数据集的情况，方差过大可以认为是在数据集上过拟合。</strong>二者无法同时达到最小，只能取一个平衡点。    </p><p>总结一下特点：</p><ul><li>高偏差的模型：训练集的错误率高，验证集和训练集的错误率类似。</li><li>高方差的模型：训练集错误率低，验证集高。</li></ul><p>下图描述了一些简单的处理方法：<br><img src="https://www.learnopencv.com/wp-content/uploads/2017/02/Machine-Learning-Workflow.png" alt="img"></p><hr><p><strong>Reference</strong></p><p>[1]. <a href="https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/" target="_blank" rel="noopener">https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Deliberate Practice$\ ^{[1]}$：to identify your weakest areas and direct a massive effort on improving those areas without worrying about areas in which you are already good.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是我在阅读西瓜书第二章时的一个遗留问题，是关于偏差-方差窘境（Bias-Variance Dilemma）的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 决策树</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/04/decision_tree/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/04/decision_tree/</id>
    <published>2018-11-04T07:08:12.000Z</published>
    <updated>2018-11-04T16:25:40.294Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第四章（决策树）的笔记，因为决策树是比较简单的算法，没有什么数学公式的推导，书中也是简单介绍了下信息熵的定义。</p><p>简单总结一下这一章的要点：</p><p>这一章介绍决策树，决策树的特点就是每一个节点作为一个选择分支，用于判断某一个样本是否含有这个属性。</p><p>决策树是递归定义的，因此属性个数理论上讲可以是无限多个。</p><p>在选择某个节点的代表属性时，引入利用信息增益为准则的ID3、C4.5和CART算法，这是三种较为类似的决策树的学习算法。</p><p>为了防止过拟合，还对决策树使用了剪枝操作。</p><p>处理连续值的方法是离散化后设定划分点。</p><p>遇到缺失值时利用无缺失的值进行估计，计算对应的信息增益再进行划分。</p><p>决策树的每一个节点还可以考虑不止一个属性，譬如使用多个属性值的线性组合的形式（多变量决策树），即允许存在斜的划分边界。甚至可以在每一个节点放一个感知机（感知机树）。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第四章（决策树）的笔记，因为决策树是比较简单的算法，没有什么数学公式的推导，书中也是简单介绍了下信息熵的定义。&lt;/p&gt;
&lt;p&gt;简单总结一下这一章的要点：&lt;/p&gt;
&lt;p&gt;这一章介绍决策树，决策树的特点就是每一个节点作为一个选择分支，用于判断某一个样本是否含有这个属性。&lt;/p&gt;
&lt;p&gt;决策树是递归定义的，因此属性个数理论上讲可以是无限多个。&lt;/p&gt;
&lt;p&gt;在选择某个节点的代表属性时，引入利用信息增益为准则的ID3、C4.5和CART算法，这是三种较为类似的决策树的学习算法。&lt;/p&gt;
&lt;p&gt;为了防止过拟合，还对决策树使用了剪枝操作。&lt;/p&gt;
&lt;p&gt;处理连续值的方法是离散化后设定划分点。&lt;/p&gt;
&lt;p&gt;遇到缺失值时利用无缺失的值进行估计，计算对应的信息增益再进行划分。&lt;/p&gt;
&lt;p&gt;决策树的每一个节点还可以考虑不止一个属性，譬如使用多个属性值的线性组合的形式（多变量决策树），即允许存在斜的划分边界。甚至可以在每一个节点放一个感知机（感知机树）。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 线性判别分析：LDA</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/04/lda/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/04/lda/</id>
    <published>2018-11-03T16:50:10.000Z</published>
    <updated>2018-11-03T17:57:44.442Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线性判别分析（Linear Discriminant Analysis, LDA）又称Fisher判别分析，是一种数据降维的方法，主要思想是使属于同一类的投影点距离尽可能地接近（类内方差小），不同类的中心点距离尽可能地远（类间中点距离大）。</strong></p><a id="more"></a><p>LDA就是模识课上黄老板讲的Fisher判别，名字不同而已。思想也很简单，计算也不复杂。首先定义一些变量：<br>$$<br>x_i：i类数据的训练样本<br>$$</p><p>$$<br>\mu_i：i类数据的均值向量<br>$$</p><p>$$<br>\Sigma_i：i类数据的协方差矩阵<br>$$</p><p>投影到直线$w$上后，样本中心（均值）所在的投影就变为$w^T\mu_i$，协方差变为$w^T\Sigma_i w$，推一下协方差：</p><p>展开协方差的定义：$\Sigma_i=\sum_{j=1}^n(x_j-u_i)^2$</p><p>变换后的协方差定义：$\Sigma’<em>i=\sum</em>{j=1}^n(w^Tx_j-w^Tu_i)^2$</p><p>则有：<br>$$<br>\Sigma’<em>i=\sum</em>{j=1}^n(w^Tx_j-w^Tu_i)^2=\sum_{j=1}^n(w^T(x_j-u_i))^2<br>$$</p><p>$$<br>=\sum_{j=1}^nw^T(x_j-u_i)(w^T(x_j-u_i))^T<br>$$</p><p>$$<br>=\sum_{j=1}^nw^T(x_j-u_i)(x_j-u_i)^Tw<br>$$</p><p>$$<br>=w^T\sum_{j=1}^n(x_j-u_i)^2w<br>$$</p><p>$$<br>=w^T\Sigma_iw<br>$$</p><p>用变换后的协方差作为衡量类内点的“集中”程度，我们尽可能想让这个值小。于是第一个目标可以用这个值逼近。</p><p>为了叙述方便，现在假设分类任务是二分类，分别是0、1类。第二个目标类间距离可以直接比较类内中点之间的距离测度，定义类间距为中点的Euclidean Distance平方：$Dis(0,1)=|w^T\mu_0-w^T\mu_1|^2$来衡量。我们希望这个值尽可能大</p><p>定义：$S_w’=\Sigma’_0+\Sigma’_1$，$S_b’=Dis(0,1)$。</p><p>同时考虑上述两个指标，于是做商合成一个目标函数（突然想起自己的paper里也搞过这种设计）：<br>$$<br>J=\dfrac{S_b’}{S_w’}=\dfrac{|w^T\mu_0w-w^T\mu_1|^2}{w^T\Sigma_0w+w^T\Sigma_1w}<br>$$</p><p>$$<br>=\dfrac{w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w}<br>$$</p><p>目标即为通过调整$w$最大化$J$，$S’_b$和$S’_w$的比值称为“广义瑞利商”。由于分子和分布都是关于$w$的二次项，因此解只与$w$的方向有关。方程等价于优化下式：<br>$$<br>\min_w -w^TS’_bw<br>$$</p><p>$$<br>st.\ w^TS’_ww=1<br>$$</p><p>这是个带约束的极值求解问题，可以用高数中学过的拉格朗日乘数法解决，构造拉格朗日函数：<br>$$<br>L(w)=-w^TS’_bw+\lambda(w^TS’_ww-1)<br>$$<br>令上式的导数得0，即可得：<br>$$<br>w=S_w’^{-1}(\mu_0-\mu_1)<br>$$<br>问题转换成求解$S’_w$的逆。注意该阵通常情况下不可逆，原因是数据维数和数据条目数通常是不匹配，就是说数据集并不能确定地体现数据的分布情况。</p><p>书上介绍的实际是PCA方法，直接给$S’_w$进行SVD分解，得到$S’_w=U\Sigma V^T$，于是$S_w’^{-1}=(U\Sigma V^T)^{-1}=V\Sigma^{-1}U^T$。</p><p>最终我们可推得：<br>$$<br>w=V\Sigma^{-1}U^T(\mu_0-\mu_1)<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线性判别分析（Linear Discriminant Analysis, LDA）又称Fisher判别分析，是一种数据降维的方法，主要思想是使属于同一类的投影点距离尽可能地接近（类内方差小），不同类的中心点距离尽可能地远（类间中点距离大）。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 线性模型、Logistic回归</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/03/logistic/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/03/logistic/</id>
    <published>2018-11-03T15:39:00.000Z</published>
    <updated>2018-11-03T17:56:27.818Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授的《机器学习》中关于Logistic回归部分的笔记（在模识老师的安利下，最终还是买了西瓜书）。</p><p><strong>Logistic回归音译为“逻辑回归”实在是太蠢了。</strong></p><a id="more"></a><p>Logistic回归是西瓜书第三章“线性模型”中的内容，首先总结一下在logistic回归之前的知识点。</p><p>所谓线性回归就是定义一个线性函数$f(x)=w^Tx+b$，经过在一个特定数据集上学习后获得参数$w$和$b$的过程。通常需要搭配优化算法使用，例如最小二乘法、梯度下降法、牛顿法、拟牛顿法$^{[1,2]}$等，我将它们的特点总结如下：</p><p>最小二乘法：希望找到一条n维空间上的直线，使得所有数据点到这条线上的欧几里德距离最短（均方差误差最小），因为均方误差损失函数是凸的，所以最小二乘法直接对该损失函数关于$w$和$b$进行求导。</p><p>梯度下降法：这是一种迭代求解最优的算法，方法就是将参数沿着梯度负方向更新。这种算法经常陷入局部最优，而且速度未必快。有很多延伸的优化，比如随机梯度下降、带惯性的梯度下降等。</p><p>牛顿法：对拟合目标函数泰勒展开后求导后迭代，需要计算任意两个变量的二阶偏导的逆（海森矩阵的逆）所以计算复杂度高，但是收敛快。过程一图以蔽之：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif" alt="img"></p><p>拟牛顿法：添加了步长的牛顿法。</p><p>但是通常的拟合任务并非是线性的，数据可能是符合某种非线性函数的变化（例如指数），因此有了对数线性回归（log-linear regression）。由于自变量的变化还是$w^Tx+b$，因此还属于线性回归模型。更一般的形式如下：<br>$$<br>g(y)=w^Tx+b<br>$$<br>$$<br>y=g^{-1}(w^Tx+b)<br>$$</p><p>此处$g(\cdot)$是一个非线性函数，这个函数需要“<strong>连续且充分光滑</strong>”。</p><p>分类任务和回归任务最大的区别是，分类需要一个hard-label，而回归通常是一个实数值的soft-label（hard-label和soft-label是我自己起的）。想用回归的方法进行分类，则需要有一个soft-&gt;hard的映射函数。</p><p>可以手动设阈值（阶跃，就是分段函数），但是不满足作为$g(\cdot)$需要的充分条件。于是有人构造了更加光滑的logistic function（对数几率函数）：<br>$$<br>y=\dfrac{1}{1+e^{-z}}<br>$$<br>这是一种sigmoid函数：形似S的函数。我们想表示成$g(y)=w^Tx+b$的形式，可以推：<br>$$<br>y=\dfrac{1}{1+e^{-z}}<br>$$<br>$$<br>y+ye^{-z}=1<br>$$</p><p>$$<br>\dfrac{1-y}{y}=e^{-z}<br>$$</p><p>$$<br>\ln\dfrac{1-y}{y}=-z<br>$$</p><p>$$<br>\ln\dfrac{y}{1-y}=z<br>$$</p><p>其中$z=w^Tx+b$，$y$和$1-y$分别可看作是正反例的可能性（logits），二者的比值取对数称为“对数几率 ”。通常写作：<br>$$<br>\ln\dfrac{p(y=1|x)}{p(y=0|x)}=z<br>$$<br>有：<br>$$<br>p(y=1|x)=\dfrac{e^{z}}{1+e^z}<br>$$<br>由于$p(y=0|x)=1-p(y=1|x)$，则：<br>$$<br>p(y=0|x)=\dfrac{1}{1+e^z}<br>$$<br>使用极大似然估计$w$和$b$，构造损失函数$l(w,b)=\sum_{i=1}^{m}\ln p(y_i|x_i;w,b)$，最大化该函数，整理一下就能得到loss函数的形式，之后就能用上述的最优化算法求它的最优解了。</p><p><strong>Reference</strong></p><p>[1]. <a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixiangwan/p/7532830.html</a></p><p>[2]. <a href="https://www.cnblogs.com/xiaohuahua108/p/6011105.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuahua108/p/6011105.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授的《机器学习》中关于Logistic回归部分的笔记（在模识老师的安利下，最终还是买了西瓜书）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Logistic回归音译为“逻辑回归”实在是太蠢了。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] Neural Networks and Deep Learning Chapter 2</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/29/nndl_ch2/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/29/nndl_ch2/</id>
    <published>2018-10-29T14:28:00.000Z</published>
    <updated>2018-11-04T15:03:58.621Z</updated>
    
    <content type="html"><![CDATA[<p>这是我阅读在线书籍《Neural Networks and Deep Learning》第二章的笔记。</p><p>手残不小心把整个笔记的文件夹误删了，原来这种事是真的会发生的啊，还好对第一章笔记做了备份= =、</p><p>章节链接： <a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap2.html</a></p><a id="more"></a><p>尽力恢复车祸现场。。</p><p>先给出一堆变量定义（图来自知乎<a href="https://zhuanlan.zhihu.com/p/26765585）：" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26765585）：</a></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/gsddyyyy.png" alt="img"></p><hr><p>在”The four fundamental equations behind backpropagation”之前，主要介绍了一个化简前馈表示的方法：$a^{l} = \sigma(w^l a^{l-1}+b^l)$。</p><p>还有两个一个函数允许作为损失函数的两个条件：1. 必须是以网络输出作为参数；2. 损失函数必须写成多个独立样本的损失的和的形式。</p><p>以及介绍了哈达玛积（Hadamard product）：$(s \odot t)_j = s_j t_j$，就是对应项相乘，例：<br>$$<br>\left[\begin{array}{c} 1 \ 2 \end{array}\right]<br>  \odot \left[\begin{array}{c} 3 \ 4\end{array} \right]<br>= \left[ \begin{array}{c} 1 <em> 3 \ 2 </em> 4 \end{array} \right]<br>= \left[ \begin{array}{c} 3 \ 8 \end{array} \right]<br>$$</p><hr><h3 id="The-four-fundamental-equations-behind-backpropagation"><a href="#The-four-fundamental-equations-behind-backpropagation" class="headerlink" title="The four fundamental equations behind backpropagation"></a><strong>The four fundamental equations behind backpropagation</strong></h3><p>反向传播会计算出$\delta_j^l$，表示为第$l$层的第$j$个神经元的误差。</p><p>定义：$\delta^l_j = \frac{\partial  C}{\partial z^l_j}$，$z_j^l$为第$l$层的第$j$个神经元的加权输入结果。反向传播的目标就是计算每一层的$\delta^l$，称之为measure of error。反向传播总的来说是4个方程。</p><p><strong>words</strong></p><ol><li>intermediate：中间的</li><li>messes with：由于……而迷糊</li><li>perturb：扰乱</li></ol><hr><p>首先看看最后一层的损失如何计算：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)<br>$$<br>$\partial C/\partial a_j^L$用于描述作为第$j$个激活函数的输出变化有多快，如果$C$不依赖于这个神经元，那么$\delta_j^L$会比较小（接近收敛）。后面的$\sigma$的导数表示激活函数在这个点的变化有多快。</p><p>这个式子的计算瓶颈在于这个偏导数，于是转换成了下面的形式：<br>$$<br>\delta^L = (a^L-y) \odot \sigma’(z^L)<br>$$<br>$a^L-y$是$C$的变化率，就是个$\Delta$，拆开后就写成上面哈达玛积的形式了。</p><p>再次重申，$\delta^L$表示的是第$L$层（也就是最后一层）的传播误差。<strong>for the error in the output layer</strong>。</p><p>接着看看隐层的传播如何计算：<br>$$<br>\delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l)<br>$$<br>式子中很明显，$l$层的误差就是由下一层（$l+1$层）反传回去的。</p><p>关于对$w^{l+1}$参数矩阵求转置：我是这么理解的，因为输出的时候$l$层用的是$n \times m$的矩阵，想要传回去的话，下层的size就不能是$n\times m$了，而是$m\times n$。转置和下一层的误差相乘，可以把误差传回对应的神经元。</p><p>网络中偏差（bias）的损失的计算：<br>$$<br>\frac{\partial C}{\partial b^l_j} =  \delta^l_j<br>$$<br>模型直接可以用该层的损失来更新某个神经元的bias，于是可以简写：$\partial C / \partial b=\delta$。</p><p>网络中权重的损失的计算：<br>$$<br>\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j<br>$$<br>某层某个神经元的输入乘以该神经元的偏差可以认为是这个神经元对于最终损失的影响值。简写为：$\frac{\partial<br>​    C}{\partial w} = a_{\rm in} \delta_{\rm out}$。</p><p>总结四个BP的关键等式：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz21.png" alt="img"></p><p>下面对每一个等式进行证明，加深理解。</p><hr><p>证明主要分两个部分：</p><p>第一部分是推导出反向传播损失函数和输出之间的关系（BP1 BP2）</p><p>第二部分是推导出损失函数与权重weight和偏差bias的关系（BP3 BP4）</p><p><strong>BP1：</strong><br>$$<br>\delta^L = \nabla_aC \odot \sigma’(z^L)<br>$$<br>证：对于第$j$个激活函数，有定义：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial z^L_j}<br>$$<br>展开：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)=\dfrac{\part C}{\part a_j^L}\dfrac{\part a_j^L}{\part z_j^L}<br>$$<br>由于$a_j^L=\sigma(z_j^L)$，那么$\sigma’(z_j^L)=\dfrac{\partial a_j^L}{\partial z_j^L}$，即：$\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)$</p><p>推广至$L$层，公式可简写为：<br>$$<br>\delta^L = \frac{\partial C}{\partial a^L} \sigma’(z^L)<br>$$</p><p><strong>BP2：</strong><br>$$<br>\delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l)<br>$$<br>证：由定义展开$\delta^l$：<br>$$<br>\delta^l = \frac{\partial C}{\partial z^l}<br>$$<br>利用导数的链式法则，对拆成对$z^{l+1}$求导的形式：<br>$$<br>\delta^l = \dfrac{\partial C}{\partial z^{l+1}}\dfrac{\part z^{l+1}}{\part z^{l}}=\dfrac{\partial z^{l+1}}{\partial z^{l}}\delta^{l+1}<br>$$<br>由于$z^{l+1}=\sum_jw_{j}^{l+1}\delta^l(z_{j}^{l+1})+b^{l+1}$，带入上式即证。</p><p><strong>BP3：</strong><br>$$<br>\frac{\partial C}{\partial b^l_j} =  \delta^l_j<br>$$<br>证：<br>$$<br>\frac{\partial C}{\partial b^l_j} =  \frac{\part C}{\part z^{l+1}_j}\frac{\part z^{l+1}_j}{\part b_j^l}=\delta_j^l\frac{\part(w^l_jz^l+b^l_j)}{\part b_j^l}=\delta_j^l<br>$$<br><strong>BP4：</strong></p><p>和上面一样，把$b$换成$w$就行。</p><hr><h3 id="The-backpropagation-algorithm"><a href="#The-backpropagation-algorithm" class="headerlink" title="The backpropagation algorithm"></a><strong>The backpropagation algorithm</strong></h3><p>利用上面证明过的4个结论，就可以推导出反向传播算法，算法可以递归形式地定义成这样：</p><ol><li>输入$x$</li><li>前馈：$z^l=w^la^{l-1}+b^l，夏日难a^l=\sigma(z^l)$</li><li>输出误差：$\delta^L = \nabla_aC \odot \sigma’(z^L)$</li><li>反向传播误差：对于每一层$l,l=L-1,L-2…,2$，于是$\delta^l=((w^{l+1})^T\delta^{l+1})\odot \sigma’(z^l)$</li><li>输出：$w,b$的损失函数定义为$\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j$和$\frac{\partial C}{\partial b^l_j} = \delta^l_j$。</li><li>$\frac{\partial  C}{\partial  b^l_j} = \delta^l_j$。</li></ol><hr><h3 id="The-code-for-backpropagation"><a href="#The-code-for-backpropagation" class="headerlink" title="The code for backpropagation"></a><strong>The code for backpropagation</strong></h3><p>这章实现了用SGD训练的的BP：每次叠小批量的训练集，再计算损失后反传。</p><p>介绍了一个可以同时计算多个mini-batch的trick：把多个mini-batch放到一个矩阵里，利用矩阵计算库对矩阵计算的优化来加速训练。</p><hr><h3 id="In-what-sense-is-backpropagation-a-fast-algorithm"><a href="#In-what-sense-is-backpropagation-a-fast-algorithm" class="headerlink" title="In what sense is backpropagation a fast algorithm?"></a><strong>In what sense is backpropagation a fast algorithm?</strong></h3><p>想在求偏导这一步加速梯度下降的计算，考虑利用$\dfrac{\partial C}{\partial w_j}\approx \dfrac{C(w+\epsilon e_j)-C(w)}{\epsilon}$这样近的似来代替计算偏导，当$\epsilon$很小的时候，起码GD方向是不会变的（$\epsilon$很小的话，多叠几次就可以近似等价于梯度方向走步长步）。但是实际上这样做的计算开销仍然会非常大。</p><p>而反向传播可以<strong>DP</strong>地把损失传回去。</p><hr><h3 id="Backpropagation-the-big-picture"><a href="#Backpropagation-the-big-picture" class="headerlink" title="Backpropagation: the big picture"></a><strong>Backpropagation: the big picture</strong></h3><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz25.png" alt="img"></p><p>对于每层输出产生的误差$\Delta a_j^l$，可以用下式做近似：<br>$$<br>\Delta a^l_j \approx \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>那么对于这层而言其中一条由输出反传回来的结果则是：<br>$$<br>\Delta C \approx \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>于是考虑所有连通的情况：<br>$$<br>\Delta C \approx \sum_{mnp\ldots q} \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>这就是反向传播对于某一条边更新时需要的计算：<br>$$<br>\frac{\partial C}{\partial w^l_{jk}} = \sum_{mnp\ldots q} \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我阅读在线书籍《Neural Networks and Deep Learning》第二章的笔记。&lt;/p&gt;
&lt;p&gt;手残不小心把整个笔记的文件夹误删了，原来这种事是真的会发生的啊，还好对第一章笔记做了备份= =、&lt;/p&gt;
&lt;p&gt;章节链接： &lt;a href=&quot;http://neuralnetworksanddeeplearning.com/chap2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://neuralnetworksanddeeplearning.com/chap2.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Deep Learning" scheme="https://vincentxwd.github.io/blog/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>The Last Samurai</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/28/the-last-samurai/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/28/the-last-samurai/</id>
    <published>2018-10-28T14:23:05.000Z</published>
    <updated>2018-10-28T16:29:17.022Z</updated>
    
    <content type="html"><![CDATA[<p>I watched a movie named “the last samurai” today: almost after some paper’s deadline. Actually I have watched it when I graduated from my high school. I was impressed by their fearless spirit and extremely focusing.</p><a id="more"></a><p>The story happened at the end of the 19th century, during the Southwest War and the Meiji Restoration of Japan. A drunken hero who participated in the American Civil War was invited by Japanese Reformers to train the new recruits of the Shogunate（幕府）Army. However, he was captured by the anti-Shogunate（倒幕派）to a small village in a battle. He was influenced by their really Bushido spirit and become a warrior of old and new ways(今古有神奉志士，就是融汇古今的武士).</p><p>There are many places worth roasting. For instance, samurais have a tradition of using firearms. But this movie shows they are just using samurai swords and bows. So many examples like this, but they don’t hinder this masterpiece to become one of my favorite movies.</p><p>I love Japanese anime so much and I’m also interested in Japanese traditional culture (in spite of I only know about it in some films). I’m yearning for the life with peace and warm. People in that time can focus on something in a long period, enjoy the process of doing only one thing to the extreme. That maybe is called Craftsmanship(工匠精神). Aside from the historical factors of Japan at that time, this spirit is also worth learning.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai1.png" alt="img"></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai2.png" alt="img"></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai3.png" alt="img"></p><p>The film section that I love the best is in the village, Algren saw the villagers were doing their own things with their heart and soul as if there was a discipline that cannot be seen. When Algren was learning how to battle with Samurai sword but always beaten by Ujio. Then he was told by Higen that he had “too many minds”. That means Algren shouldn’t think too much except defeating his enemy.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai4.png" alt="img"></p><p>I think the essence of Craftsmanship spirit is “no mind”, means without too many distracting thoughts and just focus on the moment now.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai5.png" alt="img"></p><p>I’m very lacking in this spirit. I was always disturbed by many things. Maybe that is the reason why I cannot do anything better. Although there is a huge contrast between that time and the times I am in now and the requirements for people are getting higher,  it cannot become the reason of inattention. I should learn how to abandon distracting thoughts and focus on one thing. For me, I think the main source of disturbing is from the Internet. Maybe I should close my QQ and WeChat when I’m doing something that needs “no mind”.</p><p>I talked about some small things above. But what if some big things. I was always hearing something interesting and turning to explore that thing. Then I’ll do nothing at the end. That is called “ to put away the cup after taking a tiny sip”(浅尝辄止).  The reason for this phenomenon is having too many minds. I always want to grasp anything but it is not realistic because human has limited energy.</p><p>I’m sure I have to throw away so many minds and focus on something I think is the most worthy.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I watched a movie named “the last samurai” today: almost after some paper’s deadline. Actually I have watched it when I graduated from my high school. I was impressed by their fearless spirit and extremely focusing.&lt;/p&gt;
    
    </summary>
    
      <category term="只言片语" scheme="https://vincentxwd.github.io/blog/categories/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>[Codeforces517D] Minimum path (DP, 贪心, 搜索)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/28/CF1072D/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/28/CF1072D/</id>
    <published>2018-10-28T06:06:16.000Z</published>
    <updated>2018-10-28T06:21:59.927Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1072/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1072/problem/D</a></p><p>给一个$n\times n$的字母阵，允许修改其中的$k$个字符，问从$(1,1)$走到$(n,n)$字典序最小的字符串。</p><a id="more"></a><p>如果不考虑替换的话，字典序最小的字符串可以由BFS得到。</p><p>如果考虑替换的话，首先知道替换掉的字符肯定都会把不是’a’的换成’a’。</p><p>接下来考虑DP，维护$dp(i,j)$为走到$(i,j)$处最多的’a’数量，这里不考虑$k$次替换。</p><p>由于是字典序最小，那么我们知道越早替换成’a’字典序一定是最小的，因此我们就确定了贪心地替换前面扫描的非’a’字符这样一个转移的无后效性。</p><p>DP转移可以这样：<br>$$<br>dp(i,j)=max(dp(i-1,j),dp(i,j-1))+(G(i,j)==’a’)<br>$$<br>接着考虑是否有足够的替换次数，于是存在$i+j-1-dp(i,j)$个待替换的非’a’字符，显然都替换掉字典序是最小的，于是我们拿这个和$k$比一下就可以确定当前字符$G(i,j)$是否需要替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> G[maxn][maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;pii&gt; pq;</span><br><span class="line"><span class="keyword">int</span> p[maxn][maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ret;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">    reverse(ret.begin(), ret.end());</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ok(x<span class="number">-1</span>,y)&amp;&amp;p[x<span class="number">-1</span>][y]) &#123;</span><br><span class="line">    ret.push_back(G[x<span class="number">-1</span>][y]);</span><br><span class="line">    dfs(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">    ret.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ok(x,y<span class="number">-1</span>)&amp;&amp;p[x][y<span class="number">-1</span>]) &#123;</span><br><span class="line">    ret.push_back(G[x][y<span class="number">-1</span>]);</span><br><span class="line">    dfs(x,y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">    ret.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="built_in">memset</span>(dp ,<span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + (G[i][j] == <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">if</span>(i + j - <span class="number">1</span> - dp[i][j] &lt;= k) G[i][j] = <span class="string">'a'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.push(pii(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    p[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;pii&gt; tmp;</span><br><span class="line">      <span class="keyword">int</span> cur = <span class="number">200</span>;</span><br><span class="line">      <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        tmp.push_back(pq.front());</span><br><span class="line">        cur = min(cur, (<span class="keyword">int</span>)G[pq.front().first][pq.front().second]);</span><br><span class="line">        pq.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = tmp[i].first, y = tmp[i].second;</span><br><span class="line">        <span class="keyword">if</span>(cur == (<span class="keyword">int</span>)G[x][y]) &#123;</span><br><span class="line">          p[x][y] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(ok(x+<span class="number">1</span>, y)&amp;&amp;!vis[x+<span class="number">1</span>][y]) &#123;</span><br><span class="line">            vis[x+<span class="number">1</span>][y] = <span class="number">1</span>;</span><br><span class="line">            pq.push(pii(x+<span class="number">1</span>, y));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(ok(x, y+<span class="number">1</span>)&amp;&amp;!vis[x][y+<span class="number">1</span>]) &#123;</span><br><span class="line">            vis[x][y+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            pq.push(pii(x, y+<span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.clear();</span><br><span class="line">    ret.push_back(G[n][n]);</span><br><span class="line">    dfs(n,n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1072/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1072/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给一个$n\times n$的字母阵，允许修改其中的$k$个字符，问从$(1,1)$走到$(n,n)$字典序最小的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces Mail.Ru Cup 2018 Round 1] D. Changing Array (异或和，贪心)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/19/CF1054D/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/19/CF1054D/</id>
    <published>2018-10-19T09:18:08.000Z</published>
    <updated>2018-10-19T09:33:05.418Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1054/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1054/problem/D</a></p><p><strong>一个人有$n$个二进制最高位$1%不超过$k$位的数，现在允许每一个数按位取反，统计这个数列中最多有多少个区间异或和不是0。</strong></p><a id="more"></a><p>发现一个重要的性质是，每一个区间内有两个数进行取反操作的话，实际就是没有进行取反操作。因为取反操作可以看做是一个数对$2^k-1$异或，两个数进行取反的话，那么就是异或$2^k-1$两次，就被抵消了。</p><p>假设前缀和为$sum$的点有$k$个，那么一定有$C_{k-1}^2$种构成区间异或和为0的方式，现在的问题就是尽量减少每一种$sum$出现的次数了。</p><p>于是我们可以贪心地去比每一个数和它翻转后与前缀和异或后的次数，每次往出现少的异或和上加。总的贡献是$\sum_i C^2_{cnt_i-1}$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL a[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">auto</span> rev = [=](LL x) &#123; <span class="keyword">return</span> x ^ ((<span class="number">1L</span>L &lt;&lt; (LL)k) - <span class="number">1</span>); &#125;;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    LL ret = <span class="number">1L</span>L * (n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    cnt.clear();</span><br><span class="line">    cnt[sum]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">      <span class="keyword">if</span>(cnt[sum^a[i]] &gt; cnt[sum^rev(a[i])]) sum ^= rev(a[i]);</span><br><span class="line">      <span class="keyword">else</span> sum ^= a[i];</span><br><span class="line">      cnt[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : cnt) &#123;</span><br><span class="line">      ret -=  <span class="number">1L</span>L * (p.second - <span class="number">1</span>) * p.second / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1054/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1054/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个人有$n$个二进制最高位$1%不超过$k$位的数，现在允许每一个数按位取反，统计这个数列中最多有多少个区间异或和不是0。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="异或" scheme="https://vincentxwd.github.io/blog/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>[C++] 闭包的capture（捕获）方式</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/19/Cpp-capture/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/19/Cpp-capture/</id>
    <published>2018-10-19T05:01:40.000Z</published>
    <updated>2018-10-19T05:08:39.573Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷题喜欢用闭包把函数全部写到main中，通常一个函数可以这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; f = [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x; &#125;;</span><br></pre></td></tr></table></figure><p>但是在闭包[]中可以添加=或&amp;两个运算符，查过cpp reference后，这个叫capture（捕获），即<strong>使用闭包外的变量的方式</strong>。讨论这两个运算符：</p><p>[=](){}：这是对闭包外变量进行const引用的形式，即不允许修改闭包外的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> p = [=]()&#123;</span><br><span class="line">  x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这段代码编译会报错，因为=捕获不允许修改外变量。</p><p>[&amp;](){}：这是对闭包外变量进行引用的形式，可以修改闭包外的变量，并且保留为修改后的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> p = [&amp;]()&#123;</span><br><span class="line">  x = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>而这段代码会输出4，因为闭包捕获到外部变量后将其修改并保留。</p><p>除此之外，还可以声明特定变量使用特定的捕获方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a,&amp;b]。将a按值进行传递，b按引用进行传递。</span><br><span class="line">[=,&amp;a,&amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</span><br><span class="line">[&amp;,a,b]。除a和b按值进行传递外，其他参数都按引用进行传递。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近刷题喜欢用闭包把函数全部写到main中，通常一个函数可以这样：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/p
      
    
    </summary>
    
      <category term="编程语言" scheme="https://vincentxwd.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="https://vincentxwd.github.io/blog/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundB] B. Sherlock and the Bit Strings</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-B-Sherlock-and-the-Bit-Strings/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-B-Sherlock-and-the-Bit-Strings/</id>
    <published>2018-10-18T14:37:59.000Z</published>
    <updated>2018-10-18T14:40:26.732Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.google.com/codejam/contest/10284486/dashboard#s=p1" target="_blank" rel="noopener">https://code.google.com/codejam/contest/10284486/dashboard#s=p1</a></p><p>给一个长为n的01串，现在规定在串的一些区间$[A_i,B_i]$中至少存在$C_i$个1，求满足条件的字典序为第$p$大的串。</p><a id="more"></a><p>小数据可以直接暴力，记下空位和$p$的二进制形式，然后从低到高扫01串就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL p;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="built_in">string</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span> ,&amp;n,&amp;k,&amp;p);</span><br><span class="line">    p--;</span><br><span class="line">    pos.clear();</span><br><span class="line">    ret.resize(n); fill(ret.begin(), ret.end(), <span class="string">'#'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">      <span class="keyword">if</span>(c[i]) ret[a[i]<span class="number">-1</span>] = <span class="string">'1'</span>;</span><br><span class="line">      <span class="keyword">else</span> ret[a[i]<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">      pos.emplace_back(p&amp;<span class="number">1</span>);</span><br><span class="line">      p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ret[j] == <span class="string">'1'</span> || ret[j] == <span class="string">'0'</span>) j--;</span><br><span class="line">        ret[j--] = <span class="string">'1'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(pos[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ret[j] == <span class="string">'1'</span> || ret[j] == <span class="string">'0'</span>) j--;</span><br><span class="line">        ret[j--] = <span class="string">'0'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ret[i] == <span class="string">'#'</span>) ret[i] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _++ &lt;&lt; <span class="string">": "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://code.google.com/codejam/contest/10284486/dashboard#s=p1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/10284486/dashboard#s=p1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给一个长为n的01串，现在规定在串的一些区间$[A_i,B_i]$中至少存在$C_i$个1，求满足条件的字典序为第$p$大的串。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="暴力" scheme="https://vincentxwd.github.io/blog/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundB] A. No Nine</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-A-No-Nine/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-A-No-Nine/</id>
    <published>2018-10-18T12:17:33.000Z</published>
    <updated>2018-10-18T12:20:40.764Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/10284486/dashboard#s=p0" target="_blank" rel="noopener">https://code.google.com/codejam/contest/10284486/dashboard#s=p0</a></p><p>求$[L,R]$内不被9整除且每一位都不是9的数的个数。</p><a id="more"></a><p>经典数位dp，根据$(x+y)\%m=(x\%m+y\%m)\%m$，直接维护前$l$位对9取模的值，向后dfs到最后一位发现模数不是0就计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> digit[maxn];</span><br><span class="line">LL dp[maxn][maxn];</span><br><span class="line">LL L, R;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mod, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!flag &amp;&amp; ~dp[l][mod]) <span class="keyword">return</span> dp[l][mod];</span><br><span class="line">  <span class="keyword">if</span>(l == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(mod % <span class="number">9</span> == <span class="number">0</span>) <span class="keyword">return</span> dp[l][mod] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[l][mod] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> pos = flag ? digit[l] : <span class="number">9</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pos; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">    ret += dfs(l<span class="number">-1</span>, (mod*<span class="number">10</span>+i)%<span class="number">9</span>, flag&amp;&amp;(i==pos));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!flag) dp[l][mod] = ret;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x) &#123;</span><br><span class="line">    digit[++tot] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(tot, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;L,&amp;R);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, f(R)-f(L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://code.google.com/codejam/contest/10284486/dashboard#s=p0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/10284486/dashboard#s=p0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求$[L,R]$内不被9整除且每一位都不是9的数的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="数位DP" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
</feed>
