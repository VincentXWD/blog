<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kirai</title>
  
  <subtitle>Keep going</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://vincentxwd.github.io/blog/"/>
  <updated>2018-11-05T12:11:43.585Z</updated>
  <id>https://vincentxwd.github.io/blog/</id>
  
  <author>
    <name>Kirai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[读书笔记] Bias-Variance Dilemma</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/05/BiasVarianceTradeoff/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/05/BiasVarianceTradeoff/</id>
    <published>2018-11-05T04:08:12.000Z</published>
    <updated>2018-11-05T12:11:43.585Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Deliberate Practice$\ ^{[1]}$：to identify your weakest areas and direct a massive effort on improving those areas without worrying about areas in which you are already good.</strong></p><p>这是我在阅读西瓜书第二章时的一个遗留问题，是关于偏差-方差窘境（Bias-Variance Dilemma）的内容。</p><a id="more"></a><p>首先要解释Bias-Variance Tradeoff，也就是偏差-方差权衡，譬如当前有一个拟合任务，需要构造一个多项式函数去拟合它，函数可以构造成这样：<br>$$<br>y=a_0+a_1x+a_2x^2+…+a_nx^n<br>$$<br>如何确定$n$的大小就是一个偏差-方差的权衡问题，。图像上直观地看则是为了确定这条曲线的“弯曲程度”。</p><p>曲线拟合和机器学习：前者是利用数据尽可能地拟合出一条完美的曲线；后者则是在有限的数据规模内进行学习，目的是遇到未知数据时能够做出最好的判断。</p><p>模型的泛化能力可以由泛化误差来描述，泛化误差越小，模型的期望泛化能力越强。模型$f$在数据集$D$上的泛化误差可以分解为偏差$bias$、方差$var$、噪声$\epsilon$之和：<br>$$<br>E(f;D)=\mbox{bias}^2(x)+\mbox{var}(x)+\epsilon^2<br>$$<br>递推可以在西瓜书P45翻到。</p><p>噪声指的是学习算法本身固有的误差（系统误差）和数据集的噪声。当保证数据集十分纯净的时候，人为可控的部分就只有偏差和方差了。于是机器学习中存在偏差-方差窘境：<strong>偏差描述的是模型的拟合能力，偏差过大可以认为是欠拟合；方差则描述的是数据集的情况，方差过大可以认为是在数据集上过拟合。</strong>二者无法同时达到最小，只能取一个平衡点。    </p><p>总结一下特点：</p><ul><li>高偏差的模型：训练集的错误率高，验证集和训练集的错误率类似。</li><li>高方差的模型：训练集错误率低，验证集高。</li></ul><p>下图描述了一些简单的处理方法：<br><img src="https://www.learnopencv.com/wp-content/uploads/2017/02/Machine-Learning-Workflow.png" alt="img"></p><hr><p><strong>Reference</strong></p><p>[1]. <a href="https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/" target="_blank" rel="noopener">https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Deliberate Practice$\ ^{[1]}$：to identify your weakest areas and direct a massive effort on improving those areas without worrying about areas in which you are already good.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是我在阅读西瓜书第二章时的一个遗留问题，是关于偏差-方差窘境（Bias-Variance Dilemma）的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 决策树</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/04/decision_tree/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/04/decision_tree/</id>
    <published>2018-11-04T07:08:12.000Z</published>
    <updated>2018-11-04T16:25:40.294Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第四章（决策树）的笔记，因为决策树是比较简单的算法，没有什么数学公式的推导，书中也是简单介绍了下信息熵的定义。</p><p>简单总结一下这一章的要点：</p><p>这一章介绍决策树，决策树的特点就是每一个节点作为一个选择分支，用于判断某一个样本是否含有这个属性。</p><p>决策树是递归定义的，因此属性个数理论上讲可以是无限多个。</p><p>在选择某个节点的代表属性时，引入利用信息增益为准则的ID3、C4.5和CART算法，这是三种较为类似的决策树的学习算法。</p><p>为了防止过拟合，还对决策树使用了剪枝操作。</p><p>处理连续值的方法是离散化后设定划分点。</p><p>遇到缺失值时利用无缺失的值进行估计，计算对应的信息增益再进行划分。</p><p>决策树的每一个节点还可以考虑不止一个属性，譬如使用多个属性值的线性组合的形式（多变量决策树），即允许存在斜的划分边界。甚至可以在每一个节点放一个感知机（感知机树）。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第四章（决策树）的笔记，因为决策树是比较简单的算法，没有什么数学公式的推导，书中也是简单介绍了下信息熵的定义。&lt;/p&gt;
&lt;p&gt;简单总结一下这一章的要点：&lt;/p&gt;
&lt;p&gt;这一章介绍决策树，决策树的特点就是每一个节点作为一个选择分支，用于判断某一个样本是否含有这个属性。&lt;/p&gt;
&lt;p&gt;决策树是递归定义的，因此属性个数理论上讲可以是无限多个。&lt;/p&gt;
&lt;p&gt;在选择某个节点的代表属性时，引入利用信息增益为准则的ID3、C4.5和CART算法，这是三种较为类似的决策树的学习算法。&lt;/p&gt;
&lt;p&gt;为了防止过拟合，还对决策树使用了剪枝操作。&lt;/p&gt;
&lt;p&gt;处理连续值的方法是离散化后设定划分点。&lt;/p&gt;
&lt;p&gt;遇到缺失值时利用无缺失的值进行估计，计算对应的信息增益再进行划分。&lt;/p&gt;
&lt;p&gt;决策树的每一个节点还可以考虑不止一个属性，譬如使用多个属性值的线性组合的形式（多变量决策树），即允许存在斜的划分边界。甚至可以在每一个节点放一个感知机（感知机树）。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 线性判别分析：LDA</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/04/lda/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/04/lda/</id>
    <published>2018-11-03T16:50:10.000Z</published>
    <updated>2018-11-03T17:57:44.442Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线性判别分析（Linear Discriminant Analysis, LDA）又称Fisher判别分析，是一种数据降维的方法，主要思想是使属于同一类的投影点距离尽可能地接近（类内方差小），不同类的中心点距离尽可能地远（类间中点距离大）。</strong></p><a id="more"></a><p>LDA就是模识课上黄老板讲的Fisher判别，名字不同而已。思想也很简单，计算也不复杂。首先定义一些变量：<br>$$<br>x_i：i类数据的训练样本<br>$$</p><p>$$<br>\mu_i：i类数据的均值向量<br>$$</p><p>$$<br>\Sigma_i：i类数据的协方差矩阵<br>$$</p><p>投影到直线$w$上后，样本中心（均值）所在的投影就变为$w^T\mu_i$，协方差变为$w^T\Sigma_i w$，推一下协方差：</p><p>展开协方差的定义：$\Sigma_i=\sum_{j=1}^n(x_j-u_i)^2$</p><p>变换后的协方差定义：$\Sigma’<em>i=\sum</em>{j=1}^n(w^Tx_j-w^Tu_i)^2$</p><p>则有：<br>$$<br>\Sigma’<em>i=\sum</em>{j=1}^n(w^Tx_j-w^Tu_i)^2=\sum_{j=1}^n(w^T(x_j-u_i))^2<br>$$</p><p>$$<br>=\sum_{j=1}^nw^T(x_j-u_i)(w^T(x_j-u_i))^T<br>$$</p><p>$$<br>=\sum_{j=1}^nw^T(x_j-u_i)(x_j-u_i)^Tw<br>$$</p><p>$$<br>=w^T\sum_{j=1}^n(x_j-u_i)^2w<br>$$</p><p>$$<br>=w^T\Sigma_iw<br>$$</p><p>用变换后的协方差作为衡量类内点的“集中”程度，我们尽可能想让这个值小。于是第一个目标可以用这个值逼近。</p><p>为了叙述方便，现在假设分类任务是二分类，分别是0、1类。第二个目标类间距离可以直接比较类内中点之间的距离测度，定义类间距为中点的Euclidean Distance平方：$Dis(0,1)=|w^T\mu_0-w^T\mu_1|^2$来衡量。我们希望这个值尽可能大</p><p>定义：$S_w’=\Sigma’_0+\Sigma’_1$，$S_b’=Dis(0,1)$。</p><p>同时考虑上述两个指标，于是做商合成一个目标函数（突然想起自己的paper里也搞过这种设计）：<br>$$<br>J=\dfrac{S_b’}{S_w’}=\dfrac{|w^T\mu_0w-w^T\mu_1|^2}{w^T\Sigma_0w+w^T\Sigma_1w}<br>$$</p><p>$$<br>=\dfrac{w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w}<br>$$</p><p>目标即为通过调整$w$最大化$J$，$S’_b$和$S’_w$的比值称为“广义瑞利商”。由于分子和分布都是关于$w$的二次项，因此解只与$w$的方向有关。方程等价于优化下式：<br>$$<br>\min_w -w^TS’_bw<br>$$</p><p>$$<br>st.\ w^TS’_ww=1<br>$$</p><p>这是个带约束的极值求解问题，可以用高数中学过的拉格朗日乘数法解决，构造拉格朗日函数：<br>$$<br>L(w)=-w^TS’_bw+\lambda(w^TS’_ww-1)<br>$$<br>令上式的导数得0，即可得：<br>$$<br>w=S_w’^{-1}(\mu_0-\mu_1)<br>$$<br>问题转换成求解$S’_w$的逆。注意该阵通常情况下不可逆，原因是数据维数和数据条目数通常是不匹配，就是说数据集并不能确定地体现数据的分布情况。</p><p>书上介绍的实际是PCA方法，直接给$S’_w$进行SVD分解，得到$S’_w=U\Sigma V^T$，于是$S_w’^{-1}=(U\Sigma V^T)^{-1}=V\Sigma^{-1}U^T$。</p><p>最终我们可推得：<br>$$<br>w=V\Sigma^{-1}U^T(\mu_0-\mu_1)<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线性判别分析（Linear Discriminant Analysis, LDA）又称Fisher判别分析，是一种数据降维的方法，主要思想是使属于同一类的投影点距离尽可能地接近（类内方差小），不同类的中心点距离尽可能地远（类间中点距离大）。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 线性模型、Logistic回归</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/03/logistic/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/03/logistic/</id>
    <published>2018-11-03T15:39:00.000Z</published>
    <updated>2018-11-03T17:56:27.818Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授的《机器学习》中关于Logistic回归部分的笔记（在模识老师的安利下，最终还是买了西瓜书）。</p><p><strong>Logistic回归音译为“逻辑回归”实在是太蠢了。</strong></p><a id="more"></a><p>Logistic回归是西瓜书第三章“线性模型”中的内容，首先总结一下在logistic回归之前的知识点。</p><p>所谓线性回归就是定义一个线性函数$f(x)=w^Tx+b$，经过在一个特定数据集上学习后获得参数$w$和$b$的过程。通常需要搭配优化算法使用，例如最小二乘法、梯度下降法、牛顿法、拟牛顿法$^{[1,2]}$等，我将它们的特点总结如下：</p><p>最小二乘法：希望找到一条n维空间上的直线，使得所有数据点到这条线上的欧几里德距离最短（均方差误差最小），因为均方误差损失函数是凸的，所以最小二乘法直接对该损失函数关于$w$和$b$进行求导。</p><p>梯度下降法：这是一种迭代求解最优的算法，方法就是将参数沿着梯度负方向更新。这种算法经常陷入局部最优，而且速度未必快。有很多延伸的优化，比如随机梯度下降、带惯性的梯度下降等。</p><p>牛顿法：对拟合目标函数泰勒展开后求导后迭代，需要计算任意两个变量的二阶偏导的逆（海森矩阵的逆）所以计算复杂度高，但是收敛快。过程一图以蔽之：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif" alt="img"></p><p>拟牛顿法：添加了步长的牛顿法。</p><p>但是通常的拟合任务并非是线性的，数据可能是符合某种非线性函数的变化（例如指数），因此有了对数线性回归（log-linear regression）。由于自变量的变化还是$w^Tx+b$，因此还属于线性回归模型。更一般的形式如下：<br>$$<br>g(y)=w^Tx+b<br>$$<br>$$<br>y=g^{-1}(w^Tx+b)<br>$$</p><p>此处$g(\cdot)$是一个非线性函数，这个函数需要“<strong>连续且充分光滑</strong>”。</p><p>分类任务和回归任务最大的区别是，分类需要一个hard-label，而回归通常是一个实数值的soft-label（hard-label和soft-label是我自己起的）。想用回归的方法进行分类，则需要有一个soft-&gt;hard的映射函数。</p><p>可以手动设阈值（阶跃，就是分段函数），但是不满足作为$g(\cdot)$需要的充分条件。于是有人构造了更加光滑的logistic function（对数几率函数）：<br>$$<br>y=\dfrac{1}{1+e^{-z}}<br>$$<br>这是一种sigmoid函数：形似S的函数。我们想表示成$g(y)=w^Tx+b$的形式，可以推：<br>$$<br>y=\dfrac{1}{1+e^{-z}}<br>$$<br>$$<br>y+ye^{-z}=1<br>$$</p><p>$$<br>\dfrac{1-y}{y}=e^{-z}<br>$$</p><p>$$<br>\ln\dfrac{1-y}{y}=-z<br>$$</p><p>$$<br>\ln\dfrac{y}{1-y}=z<br>$$</p><p>其中$z=w^Tx+b$，$y$和$1-y$分别可看作是正反例的可能性（logits），二者的比值取对数称为“对数几率 ”。通常写作：<br>$$<br>\ln\dfrac{p(y=1|x)}{p(y=0|x)}=z<br>$$<br>有：<br>$$<br>p(y=1|x)=\dfrac{e^{z}}{1+e^z}<br>$$<br>由于$p(y=0|x)=1-p(y=1|x)$，则：<br>$$<br>p(y=0|x)=\dfrac{1}{1+e^z}<br>$$<br>使用极大似然估计$w$和$b$，构造损失函数$l(w,b)=\sum_{i=1}^{m}\ln p(y_i|x_i;w,b)$，最大化该函数，整理一下就能得到loss函数的形式，之后就能用上述的最优化算法求它的最优解了。</p><p><strong>Reference</strong></p><p>[1]. <a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixiangwan/p/7532830.html</a></p><p>[2]. <a href="https://www.cnblogs.com/xiaohuahua108/p/6011105.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuahua108/p/6011105.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授的《机器学习》中关于Logistic回归部分的笔记（在模识老师的安利下，最终还是买了西瓜书）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Logistic回归音译为“逻辑回归”实在是太蠢了。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] Neural Networks and Deep Learning Chapter 2</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/29/nndl_ch2/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/29/nndl_ch2/</id>
    <published>2018-10-29T14:28:00.000Z</published>
    <updated>2018-11-04T15:03:58.621Z</updated>
    
    <content type="html"><![CDATA[<p>这是我阅读在线书籍《Neural Networks and Deep Learning》第二章的笔记。</p><p>手残不小心把整个笔记的文件夹误删了，原来这种事是真的会发生的啊，还好对第一章笔记做了备份= =、</p><p>章节链接： <a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap2.html</a></p><a id="more"></a><p>尽力恢复车祸现场。。</p><p>先给出一堆变量定义（图来自知乎<a href="https://zhuanlan.zhihu.com/p/26765585）：" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26765585）：</a></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/gsddyyyy.png" alt="img"></p><hr><p>在”The four fundamental equations behind backpropagation”之前，主要介绍了一个化简前馈表示的方法：$a^{l} = \sigma(w^l a^{l-1}+b^l)$。</p><p>还有两个一个函数允许作为损失函数的两个条件：1. 必须是以网络输出作为参数；2. 损失函数必须写成多个独立样本的损失的和的形式。</p><p>以及介绍了哈达玛积（Hadamard product）：$(s \odot t)_j = s_j t_j$，就是对应项相乘，例：<br>$$<br>\left[\begin{array}{c} 1 \ 2 \end{array}\right]<br>  \odot \left[\begin{array}{c} 3 \ 4\end{array} \right]<br>= \left[ \begin{array}{c} 1 <em> 3 \ 2 </em> 4 \end{array} \right]<br>= \left[ \begin{array}{c} 3 \ 8 \end{array} \right]<br>$$</p><hr><h3 id="The-four-fundamental-equations-behind-backpropagation"><a href="#The-four-fundamental-equations-behind-backpropagation" class="headerlink" title="The four fundamental equations behind backpropagation"></a><strong>The four fundamental equations behind backpropagation</strong></h3><p>反向传播会计算出$\delta_j^l$，表示为第$l$层的第$j$个神经元的误差。</p><p>定义：$\delta^l_j = \frac{\partial  C}{\partial z^l_j}$，$z_j^l$为第$l$层的第$j$个神经元的加权输入结果。反向传播的目标就是计算每一层的$\delta^l$，称之为measure of error。反向传播总的来说是4个方程。</p><p><strong>words</strong></p><ol><li>intermediate：中间的</li><li>messes with：由于……而迷糊</li><li>perturb：扰乱</li></ol><hr><p>首先看看最后一层的损失如何计算：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)<br>$$<br>$\partial C/\partial a_j^L$用于描述作为第$j$个激活函数的输出变化有多快，如果$C$不依赖于这个神经元，那么$\delta_j^L$会比较小（接近收敛）。后面的$\sigma$的导数表示激活函数在这个点的变化有多快。</p><p>这个式子的计算瓶颈在于这个偏导数，于是转换成了下面的形式：<br>$$<br>\delta^L = (a^L-y) \odot \sigma’(z^L)<br>$$<br>$a^L-y$是$C$的变化率，就是个$\Delta$，拆开后就写成上面哈达玛积的形式了。</p><p>再次重申，$\delta^L$表示的是第$L$层（也就是最后一层）的传播误差。<strong>for the error in the output layer</strong>。</p><p>接着看看隐层的传播如何计算：<br>$$<br>\delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l)<br>$$<br>式子中很明显，$l$层的误差就是由下一层（$l+1$层）反传回去的。</p><p>关于对$w^{l+1}$参数矩阵求转置：我是这么理解的，因为输出的时候$l$层用的是$n \times m$的矩阵，想要传回去的话，下层的size就不能是$n\times m$了，而是$m\times n$。转置和下一层的误差相乘，可以把误差传回对应的神经元。</p><p>网络中偏差（bias）的损失的计算：<br>$$<br>\frac{\partial C}{\partial b^l_j} =  \delta^l_j<br>$$<br>模型直接可以用该层的损失来更新某个神经元的bias，于是可以简写：$\partial C / \partial b=\delta$。</p><p>网络中权重的损失的计算：<br>$$<br>\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j<br>$$<br>某层某个神经元的输入乘以该神经元的偏差可以认为是这个神经元对于最终损失的影响值。简写为：$\frac{\partial<br>​    C}{\partial w} = a_{\rm in} \delta_{\rm out}$。</p><p>总结四个BP的关键等式：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz21.png" alt="img"></p><p>下面对每一个等式进行证明，加深理解。</p><hr><p>证明主要分两个部分：</p><p>第一部分是推导出反向传播损失函数和输出之间的关系（BP1 BP2）</p><p>第二部分是推导出损失函数与权重weight和偏差bias的关系（BP3 BP4）</p><p><strong>BP1：</strong><br>$$<br>\delta^L = \nabla_aC \odot \sigma’(z^L)<br>$$<br>证：对于第$j$个激活函数，有定义：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial z^L_j}<br>$$<br>展开：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)=\dfrac{\part C}{\part a_j^L}\dfrac{\part a_j^L}{\part z_j^L}<br>$$<br>由于$a_j^L=\sigma(z_j^L)$，那么$\sigma’(z_j^L)=\dfrac{\partial a_j^L}{\partial z_j^L}$，即：$\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)$</p><p>推广至$L$层，公式可简写为：<br>$$<br>\delta^L = \frac{\partial C}{\partial a^L} \sigma’(z^L)<br>$$</p><p><strong>BP2：</strong><br>$$<br>\delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l)<br>$$<br>证：由定义展开$\delta^l$：<br>$$<br>\delta^l = \frac{\partial C}{\partial z^l}<br>$$<br>利用导数的链式法则，对拆成对$z^{l+1}$求导的形式：<br>$$<br>\delta^l = \dfrac{\partial C}{\partial z^{l+1}}\dfrac{\part z^{l+1}}{\part z^{l}}=\dfrac{\partial z^{l+1}}{\partial z^{l}}\delta^{l+1}<br>$$<br>由于$z^{l+1}=\sum_jw_{j}^{l+1}\delta^l(z_{j}^{l+1})+b^{l+1}$，带入上式即证。</p><p><strong>BP3：</strong><br>$$<br>\frac{\partial C}{\partial b^l_j} =  \delta^l_j<br>$$<br>证：<br>$$<br>\frac{\partial C}{\partial b^l_j} =  \frac{\part C}{\part z^{l+1}_j}\frac{\part z^{l+1}_j}{\part b_j^l}=\delta_j^l\frac{\part(w^l_jz^l+b^l_j)}{\part b_j^l}=\delta_j^l<br>$$<br><strong>BP4：</strong></p><p>和上面一样，把$b$换成$w$就行。</p><hr><h3 id="The-backpropagation-algorithm"><a href="#The-backpropagation-algorithm" class="headerlink" title="The backpropagation algorithm"></a><strong>The backpropagation algorithm</strong></h3><p>利用上面证明过的4个结论，就可以推导出反向传播算法，算法可以递归形式地定义成这样：</p><ol><li>输入$x$</li><li>前馈：$z^l=w^la^{l-1}+b^l，夏日难a^l=\sigma(z^l)$</li><li>输出误差：$\delta^L = \nabla_aC \odot \sigma’(z^L)$</li><li>反向传播误差：对于每一层$l,l=L-1,L-2…,2$，于是$\delta^l=((w^{l+1})^T\delta^{l+1})\odot \sigma’(z^l)$</li><li>输出：$w,b$的损失函数定义为$\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j$和$\frac{\partial C}{\partial b^l_j} = \delta^l_j$。</li><li>$\frac{\partial  C}{\partial  b^l_j} = \delta^l_j$。</li></ol><hr><h3 id="The-code-for-backpropagation"><a href="#The-code-for-backpropagation" class="headerlink" title="The code for backpropagation"></a><strong>The code for backpropagation</strong></h3><p>这章实现了用SGD训练的的BP：每次叠小批量的训练集，再计算损失后反传。</p><p>介绍了一个可以同时计算多个mini-batch的trick：把多个mini-batch放到一个矩阵里，利用矩阵计算库对矩阵计算的优化来加速训练。</p><hr><h3 id="In-what-sense-is-backpropagation-a-fast-algorithm"><a href="#In-what-sense-is-backpropagation-a-fast-algorithm" class="headerlink" title="In what sense is backpropagation a fast algorithm?"></a><strong>In what sense is backpropagation a fast algorithm?</strong></h3><p>想在求偏导这一步加速梯度下降的计算，考虑利用$\dfrac{\partial C}{\partial w_j}\approx \dfrac{C(w+\epsilon e_j)-C(w)}{\epsilon}$这样近的似来代替计算偏导，当$\epsilon$很小的时候，起码GD方向是不会变的（$\epsilon$很小的话，多叠几次就可以近似等价于梯度方向走步长步）。但是实际上这样做的计算开销仍然会非常大。</p><p>而反向传播可以<strong>DP</strong>地把损失传回去。</p><hr><h3 id="Backpropagation-the-big-picture"><a href="#Backpropagation-the-big-picture" class="headerlink" title="Backpropagation: the big picture"></a><strong>Backpropagation: the big picture</strong></h3><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz25.png" alt="img"></p><p>对于每层输出产生的误差$\Delta a_j^l$，可以用下式做近似：<br>$$<br>\Delta a^l_j \approx \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>那么对于这层而言其中一条由输出反传回来的结果则是：<br>$$<br>\Delta C \approx \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>于是考虑所有连通的情况：<br>$$<br>\Delta C \approx \sum_{mnp\ldots q} \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>这就是反向传播对于某一条边更新时需要的计算：<br>$$<br>\frac{\partial C}{\partial w^l_{jk}} = \sum_{mnp\ldots q} \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我阅读在线书籍《Neural Networks and Deep Learning》第二章的笔记。&lt;/p&gt;
&lt;p&gt;手残不小心把整个笔记的文件夹误删了，原来这种事是真的会发生的啊，还好对第一章笔记做了备份= =、&lt;/p&gt;
&lt;p&gt;章节链接： &lt;a href=&quot;http://neuralnetworksanddeeplearning.com/chap2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://neuralnetworksanddeeplearning.com/chap2.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Deep Learning" scheme="https://vincentxwd.github.io/blog/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>The Last Samurai</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/28/the-last-samurai/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/28/the-last-samurai/</id>
    <published>2018-10-28T14:23:05.000Z</published>
    <updated>2018-10-28T16:29:17.022Z</updated>
    
    <content type="html"><![CDATA[<p>I watched a movie named “the last samurai” today: almost after some paper’s deadline. Actually I have watched it when I graduated from my high school. I was impressed by their fearless spirit and extremely focusing.</p><a id="more"></a><p>The story happened at the end of the 19th century, during the Southwest War and the Meiji Restoration of Japan. A drunken hero who participated in the American Civil War was invited by Japanese Reformers to train the new recruits of the Shogunate（幕府）Army. However, he was captured by the anti-Shogunate（倒幕派）to a small village in a battle. He was influenced by their really Bushido spirit and become a warrior of old and new ways(今古有神奉志士，就是融汇古今的武士).</p><p>There are many places worth roasting. For instance, samurais have a tradition of using firearms. But this movie shows they are just using samurai swords and bows. So many examples like this, but they don’t hinder this masterpiece to become one of my favorite movies.</p><p>I love Japanese anime so much and I’m also interested in Japanese traditional culture (in spite of I only know about it in some films). I’m yearning for the life with peace and warm. People in that time can focus on something in a long period, enjoy the process of doing only one thing to the extreme. That maybe is called Craftsmanship(工匠精神). Aside from the historical factors of Japan at that time, this spirit is also worth learning.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai1.png" alt="img"></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai2.png" alt="img"></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai3.png" alt="img"></p><p>The film section that I love the best is in the village, Algren saw the villagers were doing their own things with their heart and soul as if there was a discipline that cannot be seen. When Algren was learning how to battle with Samurai sword but always beaten by Ujio. Then he was told by Higen that he had “too many minds”. That means Algren shouldn’t think too much except defeating his enemy.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai4.png" alt="img"></p><p>I think the essence of Craftsmanship spirit is “no mind”, means without too many distracting thoughts and just focus on the moment now.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai5.png" alt="img"></p><p>I’m very lacking in this spirit. I was always disturbed by many things. Maybe that is the reason why I cannot do anything better. Although there is a huge contrast between that time and the times I am in now and the requirements for people are getting higher,  it cannot become the reason of inattention. I should learn how to abandon distracting thoughts and focus on one thing. For me, I think the main source of disturbing is from the Internet. Maybe I should close my QQ and WeChat when I’m doing something that needs “no mind”.</p><p>I talked about some small things above. But what if some big things. I was always hearing something interesting and turning to explore that thing. Then I’ll do nothing at the end. That is called “ to put away the cup after taking a tiny sip”(浅尝辄止).  The reason for this phenomenon is having too many minds. I always want to grasp anything but it is not realistic because human has limited energy.</p><p>I’m sure I have to throw away so many minds and focus on something I think is the most worthy.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I watched a movie named “the last samurai” today: almost after some paper’s deadline. Actually I have watched it when I graduated from my high school. I was impressed by their fearless spirit and extremely focusing.&lt;/p&gt;
    
    </summary>
    
      <category term="只言片语" scheme="https://vincentxwd.github.io/blog/categories/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>[Codeforces517D] Minimum path (DP, 贪心, 搜索)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/28/CF1072D/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/28/CF1072D/</id>
    <published>2018-10-28T06:06:16.000Z</published>
    <updated>2018-10-28T06:21:59.927Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1072/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1072/problem/D</a></p><p>给一个$n\times n$的字母阵，允许修改其中的$k$个字符，问从$(1,1)$走到$(n,n)$字典序最小的字符串。</p><a id="more"></a><p>如果不考虑替换的话，字典序最小的字符串可以由BFS得到。</p><p>如果考虑替换的话，首先知道替换掉的字符肯定都会把不是’a’的换成’a’。</p><p>接下来考虑DP，维护$dp(i,j)$为走到$(i,j)$处最多的’a’数量，这里不考虑$k$次替换。</p><p>由于是字典序最小，那么我们知道越早替换成’a’字典序一定是最小的，因此我们就确定了贪心地替换前面扫描的非’a’字符这样一个转移的无后效性。</p><p>DP转移可以这样：<br>$$<br>dp(i,j)=max(dp(i-1,j),dp(i,j-1))+(G(i,j)==’a’)<br>$$<br>接着考虑是否有足够的替换次数，于是存在$i+j-1-dp(i,j)$个待替换的非’a’字符，显然都替换掉字典序是最小的，于是我们拿这个和$k$比一下就可以确定当前字符$G(i,j)$是否需要替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> G[maxn][maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;pii&gt; pq;</span><br><span class="line"><span class="keyword">int</span> p[maxn][maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ret;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">    reverse(ret.begin(), ret.end());</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ok(x<span class="number">-1</span>,y)&amp;&amp;p[x<span class="number">-1</span>][y]) &#123;</span><br><span class="line">    ret.push_back(G[x<span class="number">-1</span>][y]);</span><br><span class="line">    dfs(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">    ret.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ok(x,y<span class="number">-1</span>)&amp;&amp;p[x][y<span class="number">-1</span>]) &#123;</span><br><span class="line">    ret.push_back(G[x][y<span class="number">-1</span>]);</span><br><span class="line">    dfs(x,y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">    ret.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="built_in">memset</span>(dp ,<span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + (G[i][j] == <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">if</span>(i + j - <span class="number">1</span> - dp[i][j] &lt;= k) G[i][j] = <span class="string">'a'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.push(pii(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    p[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;pii&gt; tmp;</span><br><span class="line">      <span class="keyword">int</span> cur = <span class="number">200</span>;</span><br><span class="line">      <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        tmp.push_back(pq.front());</span><br><span class="line">        cur = min(cur, (<span class="keyword">int</span>)G[pq.front().first][pq.front().second]);</span><br><span class="line">        pq.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = tmp[i].first, y = tmp[i].second;</span><br><span class="line">        <span class="keyword">if</span>(cur == (<span class="keyword">int</span>)G[x][y]) &#123;</span><br><span class="line">          p[x][y] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(ok(x+<span class="number">1</span>, y)&amp;&amp;!vis[x+<span class="number">1</span>][y]) &#123;</span><br><span class="line">            vis[x+<span class="number">1</span>][y] = <span class="number">1</span>;</span><br><span class="line">            pq.push(pii(x+<span class="number">1</span>, y));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(ok(x, y+<span class="number">1</span>)&amp;&amp;!vis[x][y+<span class="number">1</span>]) &#123;</span><br><span class="line">            vis[x][y+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            pq.push(pii(x, y+<span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.clear();</span><br><span class="line">    ret.push_back(G[n][n]);</span><br><span class="line">    dfs(n,n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1072/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1072/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给一个$n\times n$的字母阵，允许修改其中的$k$个字符，问从$(1,1)$走到$(n,n)$字典序最小的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces Mail.Ru Cup 2018 Round 1] D. Changing Array (异或和，贪心)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/19/CF1054D/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/19/CF1054D/</id>
    <published>2018-10-19T09:18:08.000Z</published>
    <updated>2018-10-19T09:33:05.418Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1054/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1054/problem/D</a></p><p><strong>一个人有$n$个二进制最高位$1%不超过$k$位的数，现在允许每一个数按位取反，统计这个数列中最多有多少个区间异或和不是0。</strong></p><a id="more"></a><p>发现一个重要的性质是，每一个区间内有两个数进行取反操作的话，实际就是没有进行取反操作。因为取反操作可以看做是一个数对$2^k-1$异或，两个数进行取反的话，那么就是异或$2^k-1$两次，就被抵消了。</p><p>假设前缀和为$sum$的点有$k$个，那么一定有$C_{k-1}^2$种构成区间异或和为0的方式，现在的问题就是尽量减少每一种$sum$出现的次数了。</p><p>于是我们可以贪心地去比每一个数和它翻转后与前缀和异或后的次数，每次往出现少的异或和上加。总的贡献是$\sum_i C^2_{cnt_i-1}$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL a[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">auto</span> rev = [=](LL x) &#123; <span class="keyword">return</span> x ^ ((<span class="number">1L</span>L &lt;&lt; (LL)k) - <span class="number">1</span>); &#125;;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    LL ret = <span class="number">1L</span>L * (n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    cnt.clear();</span><br><span class="line">    cnt[sum]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">      <span class="keyword">if</span>(cnt[sum^a[i]] &gt; cnt[sum^rev(a[i])]) sum ^= rev(a[i]);</span><br><span class="line">      <span class="keyword">else</span> sum ^= a[i];</span><br><span class="line">      cnt[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : cnt) &#123;</span><br><span class="line">      ret -=  <span class="number">1L</span>L * (p.second - <span class="number">1</span>) * p.second / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1054/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1054/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个人有$n$个二进制最高位$1%不超过$k$位的数，现在允许每一个数按位取反，统计这个数列中最多有多少个区间异或和不是0。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="异或" scheme="https://vincentxwd.github.io/blog/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>[C++] 闭包的capture（捕获）方式</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/19/Cpp-capture/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/19/Cpp-capture/</id>
    <published>2018-10-19T05:01:40.000Z</published>
    <updated>2018-10-19T05:08:39.573Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷题喜欢用闭包把函数全部写到main中，通常一个函数可以这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; f = [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x; &#125;;</span><br></pre></td></tr></table></figure><p>但是在闭包[]中可以添加=或&amp;两个运算符，查过cpp reference后，这个叫capture（捕获），即<strong>使用闭包外的变量的方式</strong>。讨论这两个运算符：</p><p>[=](){}：这是对闭包外变量进行const引用的形式，即不允许修改闭包外的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> p = [=]()&#123;</span><br><span class="line">  x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这段代码编译会报错，因为=捕获不允许修改外变量。</p><p>[&amp;](){}：这是对闭包外变量进行引用的形式，可以修改闭包外的变量，并且保留为修改后的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> p = [&amp;]()&#123;</span><br><span class="line">  x = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>而这段代码会输出4，因为闭包捕获到外部变量后将其修改并保留。</p><p>除此之外，还可以声明特定变量使用特定的捕获方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a,&amp;b]。将a按值进行传递，b按引用进行传递。</span><br><span class="line">[=,&amp;a,&amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</span><br><span class="line">[&amp;,a,b]。除a和b按值进行传递外，其他参数都按引用进行传递。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近刷题喜欢用闭包把函数全部写到main中，通常一个函数可以这样：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/p
      
    
    </summary>
    
      <category term="编程语言" scheme="https://vincentxwd.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="https://vincentxwd.github.io/blog/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundB] B. Sherlock and the Bit Strings</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-B-Sherlock-and-the-Bit-Strings/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-B-Sherlock-and-the-Bit-Strings/</id>
    <published>2018-10-18T14:37:59.000Z</published>
    <updated>2018-10-18T14:40:26.732Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.google.com/codejam/contest/10284486/dashboard#s=p1" target="_blank" rel="noopener">https://code.google.com/codejam/contest/10284486/dashboard#s=p1</a></p><p>给一个长为n的01串，现在规定在串的一些区间$[A_i,B_i]$中至少存在$C_i$个1，求满足条件的字典序为第$p$大的串。</p><a id="more"></a><p>小数据可以直接暴力，记下空位和$p$的二进制形式，然后从低到高扫01串就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL p;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="built_in">string</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span> ,&amp;n,&amp;k,&amp;p);</span><br><span class="line">    p--;</span><br><span class="line">    pos.clear();</span><br><span class="line">    ret.resize(n); fill(ret.begin(), ret.end(), <span class="string">'#'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">      <span class="keyword">if</span>(c[i]) ret[a[i]<span class="number">-1</span>] = <span class="string">'1'</span>;</span><br><span class="line">      <span class="keyword">else</span> ret[a[i]<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">      pos.emplace_back(p&amp;<span class="number">1</span>);</span><br><span class="line">      p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ret[j] == <span class="string">'1'</span> || ret[j] == <span class="string">'0'</span>) j--;</span><br><span class="line">        ret[j--] = <span class="string">'1'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(pos[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ret[j] == <span class="string">'1'</span> || ret[j] == <span class="string">'0'</span>) j--;</span><br><span class="line">        ret[j--] = <span class="string">'0'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ret[i] == <span class="string">'#'</span>) ret[i] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _++ &lt;&lt; <span class="string">": "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://code.google.com/codejam/contest/10284486/dashboard#s=p1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/10284486/dashboard#s=p1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给一个长为n的01串，现在规定在串的一些区间$[A_i,B_i]$中至少存在$C_i$个1，求满足条件的字典序为第$p$大的串。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="暴力" scheme="https://vincentxwd.github.io/blog/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundB] A. No Nine</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-A-No-Nine/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundB-A-No-Nine/</id>
    <published>2018-10-18T12:17:33.000Z</published>
    <updated>2018-10-18T12:20:40.764Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/10284486/dashboard#s=p0" target="_blank" rel="noopener">https://code.google.com/codejam/contest/10284486/dashboard#s=p0</a></p><p>求$[L,R]$内不被9整除且每一位都不是9的数的个数。</p><a id="more"></a><p>经典数位dp，根据$(x+y)\%m=(x\%m+y\%m)\%m$，直接维护前$l$位对9取模的值，向后dfs到最后一位发现模数不是0就计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> digit[maxn];</span><br><span class="line">LL dp[maxn][maxn];</span><br><span class="line">LL L, R;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mod, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!flag &amp;&amp; ~dp[l][mod]) <span class="keyword">return</span> dp[l][mod];</span><br><span class="line">  <span class="keyword">if</span>(l == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(mod % <span class="number">9</span> == <span class="number">0</span>) <span class="keyword">return</span> dp[l][mod] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[l][mod] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> pos = flag ? digit[l] : <span class="number">9</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pos; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">    ret += dfs(l<span class="number">-1</span>, (mod*<span class="number">10</span>+i)%<span class="number">9</span>, flag&amp;&amp;(i==pos));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!flag) dp[l][mod] = ret;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x) &#123;</span><br><span class="line">    digit[++tot] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(tot, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;L,&amp;R);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, f(R)-f(L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://code.google.com/codejam/contest/10284486/dashboard#s=p0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/10284486/dashboard#s=p0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求$[L,R]$内不被9整除且每一位都不是9的数的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="数位DP" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundA] B. Lucky Dip</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundA-B-Lucky-Dip/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundA-B-Lucky-Dip/</id>
    <published>2018-10-18T06:36:31.000Z</published>
    <updated>2018-10-18T06:45:28.769Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/9234486/dashboard#s=p1" target="_blank" rel="noopener">https://code.google.com/codejam/contest/9234486/dashboard#s=p1</a></p><p><strong>有n个数，允许k次“取一个数再放回重新取”的操作，一个人希望拿到最大的那个数字。求取到数字最大的期望。</strong></p><a id="more"></a><p>$k=0$时，期望就是均值，即$E_0=\frac{1}{n}\sum_{i=0}^nv_i$。</p><p>$k=1$时，每取到一个数可以有一次机会选择是否放回，但是期望拿到数字最大，因此要选取比$k=0$时期望大的数，$E_1=\frac{1}{n}\sum_{i=1}^n\mbox{max}(v_i,E_0)$。</p><p>可以推广：$E_k=\frac{1}{n}\sum_{i=1}^n\mbox{max}(v_i,E_{k-1})$。</p><p>假设计算$E_k$时，有$t$个数字使得$E_{k-1}$比$v_i$大，那么就有$n-t$个数使$E_{k-1}$比$v_i$小，他们的对$E_k$的贡献分别是$tE_{k-1}$和$\sum_{v&lt;E_{k-1}}v$。我们可以对$v$排序，前者的$t$可以二分得到，后者可以维护一个前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20020</span>;</span><br><span class="line"><span class="keyword">double</span> v[maxn], sum[maxn];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> E)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[mid] &lt;= E) &#123;</span><br><span class="line">      ret = mid;</span><br><span class="line">      lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">    <span class="keyword">double</span> E = <span class="number">.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v+<span class="number">1</span>, v+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i<span class="number">-1</span>] + v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> t = bs(E);</span><br><span class="line">      E = (sum[n]-sum[t]) + t * E;</span><br><span class="line">      E /= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %.8f\n"</span>, _++, E);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://code.google.com/codejam/contest/9234486/dashboard#s=p1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/9234486/dashboard#s=p1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有n个数，允许k次“取一个数再放回重新取”的操作，一个人希望拿到最大的那个数字。求取到数字最大的期望。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="期望, 二分" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%9F%E6%9C%9B-%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundA] A. Even Digits</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundA-A-Even-Digits/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/18/GCJKickstart2018RoundA-A-Even-Digits/</id>
    <published>2018-10-18T04:13:47.000Z</published>
    <updated>2018-10-18T04:21:52.088Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/9234486/dashboard#s=p0" target="_blank" rel="noopener">https://code.google.com/codejam/contest/9234486/dashboard#s=p0</a></p><p><strong>给一个数，这个数每次只能+1或-1，问把这个数变成每一位都是偶数的最少步数。</strong></p><a id="more"></a><p>其实就是说，求和这个数的差的绝对值最小的每位都是偶数的数。</p><p>考虑比这个数小的数，要最大化这个数就是把这个数最高位的奇数-1后面的数都是8；</p><p>考虑比这个数大的数，要最小化这个数就是把这个数最高位的奇数+1后面的数都是0，但是要考虑当前最高位是9的时候，再+1是不可能的了，所以这一个情况就不需要++。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span> maxn = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">down</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> y = x;</span><br><span class="line">  LL a = stoull(x);</span><br><span class="line">  y[<span class="number">0</span>]--;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; y.length(); i++) y[i] = <span class="string">'8'</span>;</span><br><span class="line">  LL b = stoull(y);</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">up</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> y = x;</span><br><span class="line">  LL a = stoull(x);</span><br><span class="line">  <span class="keyword">if</span>(y[<span class="number">0</span>] != <span class="string">'9'</span>) &#123;</span><br><span class="line">    y[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; y.length(); i++) y[i] = <span class="string">'0'</span>;</span><br><span class="line">    LL b = stoull(y);</span><br><span class="line">    <span class="keyword">return</span> b - a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>((s[i] - <span class="string">'0'</span>) % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      ret = min(down(s.substr(i, n-i)), up(s.substr(i, n-i)));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://code.google.com/codejam/contest/9234486/dashboard#s=p0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.google.com/codejam/contest/9234486/dashboard#s=p0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给一个数，这个数每次只能+1或-1，问把这个数变成每一位都是偶数的最少步数。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="构造, 模拟" scheme="https://vincentxwd.github.io/blog/tags/%E6%9E%84%E9%80%A0-%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] Neural Networks and Deep Learning Chapter 1</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/08/nndl_ch1/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/08/nndl_ch1/</id>
    <published>2018-10-08T01:28:00.000Z</published>
    <updated>2018-10-12T02:34:38.044Z</updated>
    
    <content type="html"><![CDATA[<p>这是我阅读在线书籍《Neural Networks and Deep Learning》的笔记，这篇博文是第一章的。没什么营养，因为大部分都知道了，于是草草略过。</p><p>章节链接： <a href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html</a></p><a id="more"></a><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h3><p>科普。</p><h3 id="words"><a href="#words" class="headerlink" title="words"></a><strong>words</strong></h3><ol><li>effortlessly：毫不费力地</li><li>deceptive：欺骗性的</li><li>superbly：雄伟地（文中表程度大）</li><li>astoundingly：令人惊讶地</li><li>stupendously：（同上）</li></ol><hr><p>科普。。</p><p><strong>words</strong></p><ol><li>morass：沼泽、困境</li><li>caveats：警告</li></ol><hr><p>科普。。。讲下NN可以从一堆数据中学习到一些特征，然后去预测一些没见过的数据。并且数据越多效果越好。</p><hr><p>介绍第一章要搞什么（手撸一个NN，用来识别手写数字，就74行），随后的章节要搞什么（想一些trick提升NN的acc之类）。</p><p><strong>words</strong></p><ol><li>intervention：介入、调停</li></ol><hr><p>手写数字识别这个问题简单，非常适合用来举例（大概这样可以把注意力更多地集中到NN本身之类？）。<em>it’s challenging - it’s no small feat to recognize handwritten digits - but it’s not so difficult as to require an extremely complicated solution, or tremendous computational power.</em><br>(这是一项具有挑战性的工作——识别手写的数字绝非易事——但是拥有一个极其复杂的解决方案，或者是巨大的计算能力的话就不难了)，之后会讲一些扩展。</p><p><strong>words</strong></p><ol><li>throughout：自始至终</li></ol><hr><p>这章的重点：</p><p>两类神经元：<strong>感知机（Perceptrons）</strong>和<strong>sigmoid函数</strong>。</p><p>神经网络的标准训练方法：<strong>随机梯度下降（Stochastic gradient descent, SGD）</strong></p><p><em>Amongst the payoffs, by the end of the chapter we’ll be in position to understand what deep learning is, and why it matters.</em>最后会讨论一下DL为什么会matters。</p><hr><h3 id="Perceptrons"><a href="#Perceptrons" class="headerlink" title="Perceptrons"></a><strong>Perceptrons</strong></h3><p>感知机（<a href="http://books.google.ca/books/about/Principles_of_neurodynamics.html?id=7FhRAAAAMAAJ）是一类人工神经元，由科学家Frank" target="_blank" rel="noopener">http://books.google.ca/books/about/Principles_of_neurodynamics.html?id=7FhRAAAAMAAJ）是一类人工神经元，由科学家Frank</a> Rosenblatt在上世纪50到60年代间完成。</p><p>不过目前非常流行的一类模型是神经网络（Neural Network），最重要的一部分是sigmoid（就个非线性函数）。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz0.png" alt="img"></p><p>上图是个最原始感知机的神经元，嗯。</p><p>假设这个perceptron有三个输入$x_1,x_2,x_3$，中间的圈里一系列权重$w_1,w_2,w_3$。输入来的时候，我们首先做向量乘法$sum=\sum_i w_ix_i$，然后要和一个阈值$threshold$比较得到$output$：<br>$$<br>output=<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ sum \leq threshold \<br>1, \ \ otherwise.<br>\end{array}<br>\right.<br>$$</p><hr><p>举个例子。</p><p><strong>words</strong></p><ol><li>transit：公共交通</li><li>adore：崇拜、爱慕</li><li>loathe：讨厌</li></ol><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz1.png" alt="img"></p><p>每一列称之为<strong>层（Layer）</strong>，第一层的三个神经元对输入分别以自己的权重进行处理（每层的处理就是向量乘积，最后获得<strong>一个值</strong>），得到的输出（可能不用threshold判断）再分别给第二层的每一个神经元，第二层的决策会更加复杂，因为第二层的输入是通过第一层抽象过的结果。</p><p>实际上每个神经元的输入可以有很多，但是输出都是一个。这么画是为了说明层与层之间是如何联系起来的。</p><p><strong>words</strong></p><ol><li>plausible：可信的</li><li>subtle：微妙的</li><li>engage：从事，参与</li><li>sophisticated：复杂的</li><li>incidentally：顺便，附带地</li></ol><hr><p>把上述神经元的计算过程简化下：<br>$$<br>output=<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ \omega\cdot x+b \leq 0 \<br>1, \ \ otherwise.<br>\end{array}<br>\right.<br>$$<br>$b$就是bias，也是threshold。表示一种“输出1”的测量(<em>the bias as a measure of how easy it is to get the perceptron to output a 1.</em> )。</p><p><strong>words</strong></p><ol><li>cumbersome：冗杂的，累赘的</li><li>notation：标志、符号、记号</li><li>reminder：剩下的</li></ol><hr><p>举了个简单的例子，说明感知机可以做与、或、非之类的逻辑操作：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz2.png" alt="img"></p><p>上图就是一个与非门，实际上感知机能做任何逻辑操作（因为这东西可以实现一切基本逻辑操作，那么就像连电路一样把那些门都连起来就行了）。</p><p>这是为了说明，感知机可以和其他计算设备一样强大。然而并非仅此而已，我们还可以在这个简单的模型上使用学习算法，使这个模型可以自己调整每一个神经元中的weights和bias，这种调节来自外部刺激（external stimuli），而非手动调整。</p><p><strong>words</strong></p><ol><li>equivalent：等价物</li><li>notable：值得注意的</li></ol><hr><p><strong>Sigmoid Neurons</strong></p><p>先介绍更新权重的时候，可以表示成$\omega+\Delta\omega$的形式，这样就可以学习了（当然都是向量）。也就是，我们希望每次output反过头过来传个值，然后更新这个网络。</p><p>但是上述的naïve perceptron在输出的时候都会经过一个突变函数（非零即一），通过这个门以后后面的神经元就完全没法恒量差别了（就像雅思）。</p><p>引出sigmoid：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz9.png" alt="img"></p><p>这里output为$\sigma(z) \equiv\dfrac{1}{1+e^{-z}}=\dfrac{1}{1+exp(-\sum_jw_jx_j-b)}$。</p><p>这样做的好处是对之前用的step function做了平滑处理，使得变化看起来不会过于激烈。看看原文是如何解释的：</p><p><em>The smoothness of $\sigma$ means that small changes $\Delta w_j$ in the weights and $\Delta b$ in the bias will produce a small change $\Delta output$ in the output from the neuron.</em></p><p>就是说变化后的w和b在处理完输入接着输出到output的时候，使得output的变化不至于太剧烈，output可以近似为下面的值：<br>$$<br>  \Delta \mbox{output} \approx \sum_j \frac{\partial \, \mbox{output}}{\partial w_j}<br>  \Delta w_j + \frac{\partial \, \mbox{output}}{\partial b} \Delta b<br>$$<br>确实可以用微分来解释，因为$\mbox{output}$是一个n元一次线性方程，那么对它微分就是各项偏导之和，而微分的几何意义就是表示偏移量（变化量）的。</p><p>我们需要有一个平滑函数$\sigma$来简化运算，由于指数在微分时的性质（无限可微），所以构造了sigmoid函数作为激活函数（sigmoid还有一个著名性质就是导数可以用自身表达）。</p><p>如何解释经过sigmoid的输出？</p><p>最大的不同是：经过sigmoid平滑后，输出由原来的0或1变为[0,1]中任意实数（希望变成0 1的话直接设阈值max一下就ok）。</p><p><strong>words</strong></p><ol><li>terrific：可怕的</li><li>property：性质、性能</li><li>occasionally：偶尔、偶然地、不定期地</li><li>legitimate：合法的</li><li>convention：约定</li></ol><hr><p><strong>Exercises</strong></p><p>part I：证明感知机中所有w、b都乘一个大于0的常数c，这个网络的输出不会改变。</p><p>证：$<br>\mbox{output}=<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ \omega\cdot x+b \leq 0 \<br>1, \ \ otherwise.<br>\end{array}<br>\right.$，乘一个整数不会影响。</p><p>part II：给一个感知机，对于任意输入$x$，都有$\omega\cdot x+b \not=0$。现在把所有神经元都替换成sigmoid神经元，再乘一个大于0的常数c，证明假如c趋于无穷大的时候，有sigmoid神经元的模型就会退化成没有sigmoid的网络。假如$\omega\cdot x+b =0$的时候又会有什么不同？</p><p>(1). 证：$c \to +\infty,c&gt;0$时，可以分别将$lim$带入上述$\sigma$函数中求极限，发现分别收敛于0和1。</p><p>(2). 结果会输出0，而sigmoid会输出0.5，是不一样的。</p><hr><h3 id="The-architecture-of-neural-networks"><a href="#The-architecture-of-neural-networks" class="headerlink" title="The architecture of neural networks"></a><strong>The architecture of neural networks</strong></h3><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz10.png" alt="img"></p><p>上图是一个网络，从左到右开始，第1层叫输入层（input layer），每个元素叫输入神经元；第2层叫隐层（hidden layer），未必只有一层；第3层叫输出层（output layer）。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz11.png" alt="img"></p><p>有多层的网络有时候也被称作“多层感知机”，这是有历史原因的。所以现在完全可以认为NN=MLP（MLP里的感知层（简单的线性操作）换成sigmoid）。</p><p>然后介绍识别手写数字的任务，提到最简单的构建NN的方法就是把一张图片（例如$64\times 64$）的灰度信息直接保存（输入直接是$4096$维，当然要把灰度归一化到[0,1]内），然后走一遍网络取argmax。同时，hidden layer的设计会非常多样。</p><p>前馈神经网络：通常定义只允许前面的层向后面的层输出，不允许反过来（不允许有环）。但是现在已经有一些可以带环的网络（RNN）。</p><p><strong>words</strong></p><ol><li>terminology：术语</li><li>philosophical：哲学的</li><li>rules of thumb：经验法则（大拇指规则）</li><li>heuristics：启发、尝试（法）</li></ol><hr><h3 id="A-simple-network-to-classify-handwritten-digits"><a href="#A-simple-network-to-classify-handwritten-digits" class="headerlink" title="A simple network to classify handwritten digits"></a><strong>A simple network to classify handwritten digits</strong></h3><p>本科做过了这段懒得读了。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz12.png" alt="img"></p><p>这个图挺帅，意思就是用一层hidden，然后输入是$28\times 28=784$维，然后最后输出10个分类的logits。</p><p>这里讨论了一个很有趣的问题：为什么输出是10个而不是4个（因为$2^4=16&gt;10$可以表示所有我们希望的数字情况）？</p><p>个人认为隐层中每次处理后都会提取图像中的某一部分的特征，预测的时候被激活与否的影响因素为某部分是不是有这个特征，有某种特征对应0-9这十个数是很容易的，然而要对应二进制编码则很难表示。</p><p><strong>words</strong></p><ol><li>sake：利益、理由</li></ol><p>Exercise懒得做了，只要对应好四个位置给权值就行了。</p><hr><h3 id="Learning-with-gradient-descent"><a href="#Learning-with-gradient-descent" class="headerlink" title="Learning with gradient descent"></a><strong>Learning with gradient descent</strong></h3><p>介绍mnist数据集，同时设计一些必要的环节：</p><p>$\mbox{cost function}$：$\begin{eqnarray}  C(w,b) \equiv \frac{1}{2n} \sum_x | y(x) - a|^2\end{eqnarray}.$（均方误差），训练过程中的目标是最小化$\mbox{cost function}$。</p><p>然后讲梯度下降：</p><p>$\begin{eqnarray}    \Delta C \approx \frac{\partial C}{\partial v_1} \Delta v_1 +   \frac{\partial C}{\partial v_2} \Delta v_2. \end{eqnarray}$ 我们的目标是希望使$\Delta C$变负，$\Delta v_1,\Delta v_2$分别是两个不同方向的偏移量。因此可以说$\Delta C$是两个方向偏移量的叠加。</p><p>定义梯度向量：$\begin{eqnarray}    \nabla C \equiv \left( \frac{\partial C}{\partial v_1},    \frac{\partial C}{\partial v_2} \right)^T. \end{eqnarray}$</p><p>所以化简后，变化量可以表示成：$\begin{eqnarray}    \Delta C \approx \nabla C \cdot \Delta v. \end{eqnarray}$</p><p>定义$\begin{eqnarray}    \Delta v = -\eta \nabla C\end{eqnarray}$，$\eta$是一个极小的正数（学习率），$\Delta C \approx -\eta \nabla C \cdot \nabla C = -\eta |\nabla C|^2$，$\Delta C \leq0$恒成立知，$C$是一个只减不增的值，于是我们在算出的$\Delta C$（我们希望让$\Delta C$一直是负数，也就是$C$一直下降）的同时，算出$v$移动后的位置$v’=v-\eta \nabla C$。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/valley_with_ball.png" alt="img"></p><p>就像这个绿球一直往地势低的地方滚，直到最低点（极低点）为止。</p><p>到$m$维的向量空间，$\nabla C$的定义会得到扩展：<br>$$<br>\begin{eqnarray}<br>  \nabla C \equiv \left(\frac{\partial C}{\partial v_1}, \ldots,<br>  \frac{\partial C}{\partial v_m}\right)^T<br>\end{eqnarray}<br>$$<br>（对于$\Delta v$中的每维变量，都会有一个对应的梯度去更新它。）</p><p>通常训练神经网络的工作都是面对这样一个最优化问题，梯度下降算法可以看做是一个采用最少步骤使得$C$下降的一个方法。</p><p><strong>words</strong></p><ol><li>quadratic：二次的</li><li>ah-doc：特别的</li><li>recap：翻造、重申</li><li>distract：转移、分心</li><li>lurk：潜伏、埋伏、隐藏</li></ol><hr><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a><strong>Exercise</strong></h3><p><a href="http://neuralnetworksanddeeplearning.com/chap1.html#exercises_647181" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html#exercises_647181</a></p><p>Part I. 证明上述的假设，即：当$\left|v\right| = \epsilon, \Delta v =-\eta \nabla C​$时，其中$\epsilon &gt;0​$为很小的一个数，且当$\eta =\dfrac{\epsilon}{\left| \nabla C\right|}​$时，$\Delta C=\nabla C \cdot \Delta v​$可以取到最小值。（也就是要证给定步长，我们沿着梯度的方向总能找到最小值）</p><p>证明：当$\Delta C = \nabla C \cdot \Delta v$且$\left|v\right|=\epsilon$时，令$\Delta v=-\eta \nabla C=(-\epsilon/\left|\Delta C\right|)\nabla C$，则有：<br>$$<br>\begin{align}<br>\Delta C &amp;= \nabla C \cdot \Delta v \<br>&amp;=  \nabla C \cdot  ( -\epsilon/\left|\nabla C\right| ) \nabla C \<br>&amp;= \nabla C ^2 ( -\epsilon/\left|\nabla C\right| ) \<br>&amp;= \left|\nabla C\right| ^2 ( -\epsilon/\left|\nabla C\right| ) \<br>&amp;= -\epsilon \left|\nabla C\right| \<br>&amp;= -\left|\Delta v\right|\left|\nabla C\right|<br>\end{align}<br>$$<br>由柯西-施瓦兹不等式，$\left|u\right|\left|v\right| \ge \left|u \cdot v\right|$得，$\left|\Delta v\right|\left|\nabla C\right|\ge \left| \Delta v \cdot \nabla C \right|$，$-\left|\Delta v\right|\left|\nabla C\right|$必为最小值。</p><p>Part II. 给出一个在多维和一维情况下梯度下降的几何解释。</p><p>答：一维的话就退化成函数求导问题了，就是在一个曲线上找极小值，也就是一个圆点往地势低的地方滚。</p><hr><p>接近物理学球下滚模拟的变种算法不可避免地需要求二阶偏微分，十分复杂。因此书中会引出一些方法来避免这个问题（梯度下降）。</p><p>梯度下降的目标是最小化$\mbox{cost function}\begin{eqnarray}  C(w,b) \equiv   \frac{1}{2n} \sum_x | y(x) - a|^2 \nonumber\end{eqnarray}$.</p><p>反向更新的时候，这样来更新weights和biases：<br>$$<br>\begin{eqnarray}<br>  w_k &amp; \rightarrow &amp; w_k’ = w_k-\eta \frac{\partial C}{\partial w_k} \<br>  b_l &amp; \rightarrow &amp; b_l’ = b_l-\eta \frac{\partial C}{\partial b_l}.<br>\end{eqnarray}<br>$$<br>但是有一个问题，原始的梯度下降里，这个目标函数实际上是在求$C​$在不同$x​$取值时的均值，也就是要把整个dataset都迭代一遍后再去反向传播。</p><p>随机梯度下降（Stochastic gradient descent，SGD）每次选取指定规模的mini-batch去做梯度下降，在mini-batch的大小$m$满足：<br>$$<br>\begin{eqnarray}<br>  \frac{\sum_{j=1}^m \nabla C_{X_{j}}}{m} \approx \frac{\sum_x \nabla C_x}{n} = \nabla C,<br>\end{eqnarray}<br>$$<br>即$m$个输入的平均值要接近于全体输入的平均值，SGD才可近似于naïve GD。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/1539092769209.png" alt="1539092769209"></p><p>带入权值和偏移更新中，公式变成这样：<br>$$<br>\begin{eqnarray}<br>  w_k &amp; \rightarrow &amp; w_k’ = w_k-\frac{\eta}{m}<br>  \sum_j \frac{\partial C_{X_j}}{\partial w_k} \<br>  b_l &amp; \rightarrow &amp; b_l’ = b_l-\frac{\eta}{m}<br>  \sum_j \frac{\partial C_{X_j}}{\partial b_l},<br>\end{eqnarray}<br>$$<br>在SGD时，称把整个数据集经过mini-batch训练一遍为一个epoch，通常要来好几个epoch。</p><p>在算目标函数的时候不要忘记$\frac{1}{n}$（用mini-batch的时候是$\frac{1}{m}$），做一下平均（因为有可能后来添加数据，就是说数据规模不一定的时候会影响到）。</p><p><strong>words</strong></p><ol><li>incidentally：顺便地，偶然一提地</li><li>convention：惯例，约定</li><li>omit：省略、疏忽</li></ol><hr><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a><strong>Exercise</strong></h3><p>提到了mini-batch size=1的时候的一种极限情况。</p><hr><h3 id="Implementing-our-network-to-classify-digits"><a href="#Implementing-our-network-to-classify-digits" class="headerlink" title="Implementing our network to classify digits"></a><strong>Implementing our network to classify digits</strong></h3><p>介绍数据集，和要实现的神经网络。稍微读下代码，其他没什么好看的。</p><hr><h3 id="Toward-deep-learning"><a href="#Toward-deep-learning" class="headerlink" title="Toward deep learning"></a><strong>Toward deep learning</strong></h3><p>又是一些废话。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我阅读在线书籍《Neural Networks and Deep Learning》的笔记，这篇博文是第一章的。没什么营养，因为大部分都知道了，于是草草略过。&lt;/p&gt;
&lt;p&gt;章节链接： &lt;a href=&quot;http://neuralnetworksanddeeplearning.com/chap1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://neuralnetworksanddeeplearning.com/chap1.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Deep Learning" scheme="https://vincentxwd.github.io/blog/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder199A] 分组(dfs，拉姆齐定理, 随机)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/07/Nowcoder-199A/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/07/Nowcoder-199A/</id>
    <published>2018-10-07T13:25:20.000Z</published>
    <updated>2018-10-07T14:02:47.494Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/199/A" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/199/A</a></p><p><strong>意思就是给你一个无向图染色，每个点最多有一个相邻点可以染成同色。</strong></p><a id="more"></a><p>我们证明一下解一定存在：</p><p>首先考虑$n&lt;4$，无论如何都能有解，显然成立。</p><p>我们可以画一下最极端的情况是什么样子的…</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/1538920651987.png" alt="1538920651987"></p><p>在这个情况下无法再想这个完全图内加边加点，因此这是个最极端的情况，但是它是有解的。</p><p>那么我们其他的符合条件的图都可以由这个图通过删边加点加边的方式获得并且他们是一个连通图（每个人都认识聚会中的一些人）。</p><p>于是这题就可以解了：</p><p>直接dfs，但是题目最后有个备注很蛋疼，那就是有10%的数据，有一组数据存在某个组里每个人都互相不认识。</p><p>所以我们考虑尽可能先处理那个分组里的点，这个分组里的点尽量首先安排。但是我们又不能知道那个组都有哪些个点，因此我们考虑把每一个点的边打乱一下保存再dfs，最后再加个特判就ok。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  vis[u] = id;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(!vis[v]) dfs(v, u, <span class="number">3</span>-vis[u]);</span><br><span class="line">    <span class="keyword">if</span>(vis[v] == vis[u]) cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span>) vis[u] = <span class="number">3</span> - vis[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      random_shuffle(G[i].begin(), G[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) dfs(i, <span class="number">-1</span>, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt2 == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,vis[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,vis[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">      <span class="keyword">if</span>(vis[i] == <span class="number">1</span>) cnt1++;</span><br><span class="line">      <span class="keyword">else</span> cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/199/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/199/A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;意思就是给你一个无向图染色，每个点最多有一个相邻点可以染成同色。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="dfs" scheme="https://vincentxwd.github.io/blog/tags/dfs/"/>
    
      <category term="随机" scheme="https://vincentxwd.github.io/blog/tags/%E9%9A%8F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder208A] Birthday(最小费用最大流)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/06/Nowcoder-208A/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/06/Nowcoder-208A/</id>
    <published>2018-10-06T13:51:47.000Z</published>
    <updated>2018-10-07T13:29:46.467Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/206/A" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/206/A</a></p><p><strong>题意很简单，给你n个球，m个桶。现在每个球最多可以丢到两个桶中的一个，同时规定每个桶中球的平方和为代价。现在希望你找一个方案，使得代价最小。</strong></p><a id="more"></a><p>一开始random_shuffle后回溯在60%左右T掉。。</p><p>回溯的时候往一个当前有$x$个球的桶里丢一个球的时候，代价的增幅为$(x+1)^2-x^2$，于是来了灵感。</p><p>我们可以把丢球的过程看作节点，每次往一个当前有$x$个球的桶里多丢一个球的时候，意味着代价增加了$(x+1)^2-x^2$，而且这个代价是单调递增的。</p><p>我们考虑建图，超级源、汇中间有n个代表球的节点和m个代表桶中球数量的节点：</p><p>由源点出发，n个节点代表球，各连接一条，流量为1，费用为0的边。</p><p>接着从n个节点向m个节点出发，代表球可以向某两个桶里丢，流量为1，费用为0。</p><p>接着由m个桶向汇点连边，每个桶连n条边，流量为1，费用为该桶+1个球后代价的涨幅。由于涨幅是递增的，因此在求最小费用最大流的时候肯定从小到大流。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, next;</span><br><span class="line">  LL c, w;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">7070</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">0x3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">const</span> LL inf = (<span class="number">1L</span>L&lt;&lt;<span class="number">55</span>);</span><br><span class="line"><span class="keyword">int</span> tot, head[maxn];</span><br><span class="line">LL dist[maxn];</span><br><span class="line">LL cost, flow;</span><br><span class="line">Node e[maxm];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> S, T, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S = T = N = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c:容量, w:费用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL c, LL w)</span> </span>&#123;</span><br><span class="line">  e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">  e[tot].u = v; e[tot].v = u; e[tot].c = <span class="number">0</span>; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dist[i] = inf;</span><br><span class="line">    visit[i] = <span class="number">0</span>;</span><br><span class="line">    pre[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">  Q.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  pre[s] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q.front();</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(e[j].c &gt; <span class="number">0</span> &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123;</span><br><span class="line">        dist[e[j].v] = dist[u] + e[j].w;</span><br><span class="line">        pre[e[j].v] = j;</span><br><span class="line">        <span class="keyword">if</span>(!visit[e[j].v]) &#123;</span><br><span class="line">          Q.push(e[j].v);</span><br><span class="line">          visit[e[j].v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return dist[t] &lt; 0; // 求可行流</span></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 求最小费用流</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ChangeFlow</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  LL det = mod;</span><br><span class="line">  <span class="keyword">int</span> u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    det = min(det, e[u].c);</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    e[u].c -= det;</span><br><span class="line">    e[u ^ <span class="number">1</span>].c += det;</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> det;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">MinCostFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  LL mincost, maxflow;</span><br><span class="line">  mincost = maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(spfa(s, t, n)) &#123;</span><br><span class="line">    LL det = ChangeFlow(t);</span><br><span class="line">    mincost += det * dist[t];</span><br><span class="line">    maxflow += det;</span><br><span class="line">  &#125;</span><br><span class="line">  cost = mincost;</span><br><span class="line">  flow = maxflow;</span><br><span class="line">  <span class="keyword">return</span> mincost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    init();</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>; N = T + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) adde(S, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">      adde(i, n+a, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      adde(i, n+b, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        adde(i+n, T, <span class="number">1</span>, j*j-(j<span class="number">-1</span>)*(j<span class="number">-1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, MinCostFlow(S, T, N));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/206/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/206/A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意很简单，给你n个球，m个桶。现在每个球最多可以丢到两个桶中的一个，同时规定每个桶中球的平方和为代价。现在希望你找一个方案，使得代价最小。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="最小费用最大流" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>[总结] 反素数</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/05/emirp/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/05/emirp/</id>
    <published>2018-10-05T09:23:10.000Z</published>
    <updated>2018-10-07T16:09:56.868Z</updated>
    
    <content type="html"><![CDATA[<p><strong>素数</strong>的定义可以为：因子只有2个的数（一个是1，另一个是本身），也就是因子最少的数。</p><p>那么，<strong>反素数</strong>可以定义成<strong>因子数最多的数，假如因子个数相同那么是最小的那个数</strong>，反素数是相对于一个集合来说的（比如在$n$个数以内的数）。</p><p>简而言之，<strong>因素最多并且值最小的数，就是反素数</strong>。</p><a id="more"></a><p>朴素求法：利用整数唯一分解定理若$x=p_1^{k_1}p_2^{k_2}…p_n^{k_n}$，那么$x$就有$(k_1+1)(k_2+1)…(k_n+1)$个因数。给某个集合扫一遍求下$max$即可。</p><p>反素数有两个特点：</p><ol><li>反素数肯定是从$2$开始的连续素数的幂次形式的乘积。</li><li>数值小的素数的幂次大于等于数值大的素数：$x=p_1^{k_1}p_2^{k_2}…p_n^{k_n}$，那么有$k1 \geq k2 \geq…k_n$。    </li></ol><p>解释：</p><ol><li>反证，若存在不从$2$开始的连续素数之积$p$，那么必然存在一个从2开始的连续素数之积$q$，除了一个$2$以外，其他值均与$p$相等，而此时$q &lt; p$。</li><li>若存在$k_i, k_j$，使得$i&lt;j,k_i&gt;k_j$成立。那么我们可以交换一下$p_i$与$p_j$，使得这个数更小。</li></ol><p>想要求给定自然数$n$，求$[1,n]$内的反素数。这个问题似乎没有什么更加牛X的解决方法，实际上还是要通过<strong>枚举</strong>的方法，为了解决这个问题，我们再提出两个问题：</p><ol><li><strong>对于给定的$n$，要枚举到哪一个素数</strong>：枚举到$\leq n$的素数就可以。</li><li><strong>枚举多少次幂</strong>：实际上枚举到最小素数$p$的$k$次幂，使得$p^k&gt;n$，那么枚举到的最大幂次肯定要小于$k$。</li></ol><p>一般这类问题都是DFS+一些分支限界枚举答案的。</p><hr><p>练习1：<a href="http://codeforces.com/contest/27/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/27/problem/E</a></p><p>题意：找含有$n$个因子的最小的那个数，这个数不超过1E18。</p><p>分析：</p><ol><li>设这个数字是$m$，那么可以设$m=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$，其中$(k_1+1)(k_2+1)…(k_r+1)=n$。我们由上述<strong>结论1</strong>可以求出来$p_i$的上界：取$k_1=$2，那么最多也就是$\lceil log_21000 \rceil=10$个不同的素数，贪心取最小的前10个素数就可以。<del>分析到这里就可以打表了。</del></li><li>再考虑这个数在1E18内的问题，也就是$k$的取值范围。取最小的$p=2$，那么顶多是60层。</li></ol><p>于是我们就可以DFS，在每层（即每个素数）暴力枚举这个数选取次数，然后维护上一层的数值以及因数个数就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[maxn] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;;</span><br><span class="line">ull ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, ull cur, <span class="keyword">int</span> cnt, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(depth &gt;= <span class="number">11</span> || cnt &gt; n) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(cnt == n) &#123;</span><br><span class="line">    ret = min(ret, cur);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt * (i + <span class="number">1</span>) &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    cur *= (ull)p[depth];</span><br><span class="line">    dfs(depth+<span class="number">1</span>, cur, cnt*(i+<span class="number">1</span>), i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    ret = <span class="number">1E18</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;素数&lt;/strong&gt;的定义可以为：因子只有2个的数（一个是1，另一个是本身），也就是因子最少的数。&lt;/p&gt;
&lt;p&gt;那么，&lt;strong&gt;反素数&lt;/strong&gt;可以定义成&lt;strong&gt;因子数最多的数，假如因子个数相同那么是最小的那个数&lt;/strong&gt;，反素数是相对于一个集合来说的（比如在$n$个数以内的数）。&lt;/p&gt;
&lt;p&gt;简而言之，&lt;strong&gt;因素最多并且值最小的数，就是反素数&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="算法总结" scheme="https://vincentxwd.github.io/blog/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="总结" scheme="https://vincentxwd.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="数论" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder190H] CSL的校园卡</title>
    <link href="https://vincentxwd.github.io/blog/2018/09/15/nowcoder190h/"/>
    <id>https://vincentxwd.github.io/blog/2018/09/15/nowcoder190h/</id>
    <published>2018-09-15T15:10:34.000Z</published>
    <updated>2018-09-15T15:17:52.279Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/190/H" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/190/H</a></p><p><strong>中文题面不解释。</strong></p><a id="more"></a><p>很容易想到dp，但是要仔细设计一下状态。</p><p>两个人一起走，可以直接定义状态为dp(ax,ay,bx,by)，但是要维护每个可行点都遍历过，那么可以二进制位压。状态记成dp(sta,ax,ay,bx,by)，然后常规dfs就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ax, ay, bx, by, st;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, es;</span><br><span class="line"><span class="keyword">char</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">16</span>][maxn][maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; (G[x][y] == <span class="string">'S'</span> || G[x][y] == <span class="string">'O'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">  <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">  dp[<span class="number">1</span>&lt;&lt;id(sx, sy)][sx][sy][sx][sy] = <span class="number">0</span>;</span><br><span class="line">  q.push(&#123;sx, sy, sx, sy, <span class="number">1</span> &lt;&lt; id(sx, sy)&#125;);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    Node t = q.front(); q.pop();</span><br><span class="line">    <span class="keyword">if</span>(t.st == es) <span class="keyword">return</span> dp[es][t.ax][t.ay][t.bx][t.by];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> ax = t.ax + dx[i], ay = t.ay + dy[i];</span><br><span class="line">      <span class="keyword">if</span>(!ok(ax, ay)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bx = t.bx + dx[j], by = t.by + dy[j];</span><br><span class="line">        <span class="keyword">if</span>(!ok(bx, by)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> st = t.st | (<span class="number">1</span> &lt;&lt; id(ax, ay));</span><br><span class="line">        st |= (<span class="number">1</span> &lt;&lt; id(bx, by));</span><br><span class="line">        <span class="keyword">if</span>(dp[st][ax][ay][bx][by] == <span class="number">-1</span>) dp[st][ax][ay][bx][by] = dp[t.st][t.ax][t.ay][t.bx][t.by] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        q.push(&#123;ax, ay, bx, by, st&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    es = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[i][j] == <span class="string">'O'</span>) es |= (<span class="number">1</span> &lt;&lt; id(i, j));</span><br><span class="line">        <span class="keyword">if</span>(G[i][j] == <span class="string">'S'</span>) &#123;</span><br><span class="line">          x = i, y = j;</span><br><span class="line">          es |= (<span class="number">1</span> &lt;&lt; id(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs(x, y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/190/H&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/190/H&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中文题面不解释。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="bfs" scheme="https://vincentxwd.github.io/blog/tags/bfs/"/>
    
      <category term="dp" scheme="https://vincentxwd.github.io/blog/tags/dp/"/>
    
      <category term="状态压缩" scheme="https://vincentxwd.github.io/blog/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder180D] xor序列 (线性基)</title>
    <link href="https://vincentxwd.github.io/blog/2018/09/08/Nowcoder-180D/"/>
    <id>https://vincentxwd.github.io/blog/2018/09/08/Nowcoder-180D/</id>
    <published>2018-09-08T09:43:18.000Z</published>
    <updated>2018-09-08T12:33:25.566Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/180/D" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/180/D</a></p><p><strong>题意就是给你$n$个数和$q$次询问，每次问你一个数$x$能不能被上述$n$个数之间随意异或得到。</strong></p><a id="more"></a><p>这题可以想到构造一组32个异或方程的方程组，每一个方程代表数位中某一位的异或结果。我们需要判断这个方程组是否有解。考虑方程组有无解实际上就是判断这个方程组的参数矩阵构成的一组基底能否表示每次查询的$x$，因此我们可以用线性基的技术解决这个问题。</p><p>关于线性基可以学习这篇blog：<a href="https://blog.sengxian.com/algorithms/linear-basis" target="_blank" rel="noopener">https://blog.sengxian.com/algorithms/linear-basis</a></p><p>由于我们不关心这组方程中最大线性无关组具体是什么，因此我们可以直接向无关组中判断插入每一个方程（就是每一个数字）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, x, y;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">31</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(!a[j]) &#123;</span><br><span class="line">            a[j] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          x ^= a[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">      x ^= y;</span><br><span class="line">      <span class="built_in">memcpy</span>(b, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">31</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(!b[j]) &#123;</span><br><span class="line">            b[j] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          x ^= b[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, x == <span class="number">0</span> ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/180/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/180/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意就是给你$n$个数和$q$次询问，每次问你一个数$x$能不能被上述$n$个数之间随意异或得到。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="线性基" scheme="https://vincentxwd.github.io/blog/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>你好，UCAS</title>
    <link href="https://vincentxwd.github.io/blog/2018/09/04/Hello-UCAS/"/>
    <id>https://vincentxwd.github.io/blog/2018/09/04/Hello-UCAS/</id>
    <published>2018-09-04T09:37:15.000Z</published>
    <updated>2018-09-04T10:33:16.034Z</updated>
    
    <content type="html"><![CDATA[<p>70多公里，坐了一小时左右的车，终于到这里了。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/tsg.jpg" alt="img"></p><a id="more"></a><p>还真是蛮激动的，毕竟在所里的时候就听师兄师姐们说雁栖湖环境特别好。我来报到的这一天还在下雨，空气极度清晰。</p><p>坐车在学校绕了好久才找到了宿舍，宿舍可以说完全就是在山脚下。。。</p><p>这是宿舍的“客厅”。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/kt.jpg" alt="img"></p><p>一个屋子里一共有9个套间，每个套间只住一个人（单人间好评）。</p><p>套间是这样的。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/ss.jpg" alt="img"></p><p>有一个小窗户，我这里的位置不算太好，但是靠近向左看还是可以看到骆驼山的。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/ch.jpg" alt="img"></p><p>袋子里的全部东西（手写学生证预定）。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/zb.jpg" alt="img"></p><p>简单收拾了一下 ，于是跑路去买被窝还有一些日常用品了。由于太拥挤，并没有拍食堂。</p><p>下午在学校里转了转，感觉校园有点大啊。。晚上跑回宿舍洗衣服洗澡写论文。</p><hr><p>以上是报到当天的实况，然而最近有点自闭。大概是因为突然到一个新环境，有点不适应吧…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;70多公里，坐了一小时左右的车，终于到这里了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcoln8jiu.bkt.clouddn.com/tsg.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="只言片语" scheme="https://vincentxwd.github.io/blog/categories/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/"/>
    
    
  </entry>
  
</feed>
