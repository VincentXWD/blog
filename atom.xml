<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kirai</title>
  
  <subtitle>我好菜啊 QAQ | I Good Vegetable A QAQ</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://vincentxwd.github.io/blog/"/>
  <updated>2018-08-12T13:20:01.675Z</updated>
  <id>https://vincentxwd.github.io/blog/</id>
  
  <author>
    <name>Kirai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018百度之星-初赛（B）ADF题解</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/12/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E5%88%9D%E8%B5%9B%EF%BC%88B%EF%BC%89ADF%E9%A2%98%E8%A7%A3/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/12/2018百度之星-初赛（B）ADF题解/</id>
    <published>2018-08-12T13:11:30.000Z</published>
    <updated>2018-08-12T13:20:01.675Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826</a></p><p>只会签到。。。</p><a id="more"></a><p>A： 因为无限添加，考虑先把另外一些树加到这个点上，再把其他子树的叶子加到某一个点上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; pre[find(x)] = find(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T, u, v;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) pre[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      in[u]++, in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      ret = max(ret, in[i]+n-in[i]<span class="number">-1</span>-max(<span class="number">0</span>, m-in[i]-k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：这题直接二分答案，即最小的那个数字。然后按照这个数字来划分是加还是减，保证加的次数的2倍比减的次数多就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">300200</span>;</span><br><span class="line">LL n;</span><br><span class="line">LL x[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(LL mid)</span> </span>&#123;</span><br><span class="line">  LL a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x[i] &gt; mid+<span class="number">1</span>) &#123;</span><br><span class="line">      b += (x[i] - mid) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> a += max(<span class="number">0L</span>L, mid-x[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  b &gt;= a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x+<span class="number">1</span>, x+n+<span class="number">1</span>);</span><br><span class="line">    LL lo = <span class="number">0</span>, hi = <span class="number">1E9</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">      LL mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(gao(mid)) &#123;</span><br><span class="line">        lo = mid + <span class="number">1</span>;</span><br><span class="line">        ret = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        hi = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F：因为$x_i$和$y_i$不会存在重复的，那么直接垂直接到最近的边上就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL mx, my, q, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; mx &gt;&gt; my &gt;&gt; q;</span><br><span class="line">      LL ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">          LL tmp = x &lt; mx - x ? x : mx - x;</span><br><span class="line">          <span class="keyword">if</span>(x &lt; mx - x) tmp = x;</span><br><span class="line">          <span class="keyword">else</span> tmp = mx - x;</span><br><span class="line">          <span class="keyword">if</span>(tmp &gt;= y) tmp = y;</span><br><span class="line">          <span class="keyword">if</span>(tmp &gt;= my - y) tmp = my - y;</span><br><span class="line">          ret += tmp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只会签到。。。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018百度之星" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F/"/>
    
    
      <category term="规律" scheme="https://vincentxwd.github.io/blog/tags/%E8%A7%84%E5%BE%8B/"/>
    
      <category term="二分" scheme="https://vincentxwd.github.io/blog/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[CF1020A-C] Codeforces Round #503 (Div.2)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/12/CF1020A-C-Codeforces-Round-503-Div-2/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/12/CF1020A-C-Codeforces-Round-503-Div-2/</id>
    <published>2018-08-12T05:15:17.000Z</published>
    <updated>2018-08-12T05:25:18.404Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1020" target="_blank" rel="noopener">http://codeforces.com/contest/1020</a></p><p><strong>上分啦</strong></p><a id="more"></a><p>A：<strong>n个楼每个楼h层，在每栋楼的$[a,b]$层上都有一个横向的通道，可以从一个楼去任意楼。现在给你两个位置，问最少要走多少步。</strong></p><p>对两个位置和通道区间进行讨论，然后抠一下就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL n, h, a, b, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL ta, fa, tb, fb;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;h&gt;&gt;a&gt;&gt;b&gt;&gt;k) &#123;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;ta&gt;&gt;fa&gt;&gt;tb&gt;&gt;fb;</span><br><span class="line">      LL ret = (LL)<span class="built_in">abs</span>(ta - tb);</span><br><span class="line">      <span class="keyword">if</span>(ta == tb) &#123;</span><br><span class="line">        ret += (LL)<span class="built_in">abs</span>(fa - fb);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa &gt; b &amp;&amp; fb &gt; b) &#123;</span><br><span class="line">          ret += (fa + fb - <span class="number">2L</span>L * b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fa &lt; a &amp;&amp; fb &lt; a) &#123;</span><br><span class="line">          ret += (<span class="number">2L</span>L * a - fa - fb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ret += (LL)<span class="built_in">abs</span>(fa - fb);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>意思就是让你从每个人出发找第一个遍历2次的点。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  dfs(p[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(p ,<span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">      p[i] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">      dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>n个人要给m个政党投票，每个人都有自己的投票目标以及花钱收买他的代价。现在希望让1号政党的票数超过其他所有政党的票数，问你至少要花多少钱。</strong></p><p>考虑贪心地选花费最少的，但是直接这样选相当于确定了收买人数，实际上可以买某一个政党的一些票就可以减少收买人数。于是我们考虑枚举1号政党的目标票数，超过该票数的政党则购买所有最少价格的差票，如果还不足我们的目标票数则从剩下的票里选最便宜的买。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3030</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, W;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">int</span> p[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(<span class="keyword">int</span> vote)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  tmp.clear();</span><br><span class="line">  <span class="keyword">int</span> need = vote - W;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[i].size() &gt;= vote) &#123;</span><br><span class="line">      id = f[i].size() - vote + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id &gt; need) <span class="keyword">return</span> <span class="number">1E18</span>;</span><br><span class="line">    need -= id;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; id; j++) &#123;</span><br><span class="line">      ret += f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = id; j &lt; f[i].size(); j++) &#123;</span><br><span class="line">      tmp.push_back(f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(tmp.begin(), tmp.end());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; need; i++) &#123;</span><br><span class="line">    ret += tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i],&amp;w[i]);</span><br><span class="line">      f[p[i]].push_back(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      sort(f[i].begin(), f[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">1E18</span>;</span><br><span class="line">    W = f[<span class="number">1</span>].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = W; i &lt;= n; i++) &#123;</span><br><span class="line">      ret = min(ret, gao(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://codeforces.com/contest/1020&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1020&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上分啦&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="dfs" scheme="https://vincentxwd.github.io/blog/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>[2018百度之星] 初赛（A）A-C题解</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/11/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E5%88%9D%E8%B5%9B%EF%BC%88A%EF%BC%89AA-C%E9%A2%98%E8%A7%A3/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/11/2018百度之星-初赛（A）AA-C题解/</id>
    <published>2018-08-11T11:48:32.000Z</published>
    <updated>2018-08-11T12:10:02.046Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825</a></p><p><strong>这场出的三题，有两道和标算不太一样啊。。。其中一道题还是因为数据弱暴力过的，感觉这样下去不太行啊。。。</strong></p><a id="more"></a><p>A：直接按照长短排序，从大到小连续取3根，看看能不能构成三角形。取最大的三根就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a+n);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>]) &#123;</span><br><span class="line">        ok = <span class="number">1</span>;</span><br><span class="line">        ret = a[i]+a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ok) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：这里直接用deque或者list暴力就行，其实应该手写一个list，然后接头接尾直接翻转两个指针。（其实我想到了，但是写不来。码力太差了啊。。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150100</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&gt; l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">int</span> u, v, w, val;</span><br><span class="line">  <span class="keyword">while</span>(scan_d(n)) &#123;</span><br><span class="line">    l.resize(n+<span class="number">1</span>);</span><br><span class="line">    scan_d(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l[i].clear();</span><br><span class="line">    <span class="keyword">int</span> cmd;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">      scan_d(cmd);</span><br><span class="line">      <span class="keyword">if</span>(cmd == <span class="number">1</span>) &#123;</span><br><span class="line">        scan_d(u); scan_d(w); scan_d(val);</span><br><span class="line">        <span class="keyword">if</span>(w == <span class="number">0</span>) l[u].emplace_front(val);</span><br><span class="line">        <span class="keyword">else</span> l[u].emplace_back(val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cmd == <span class="number">2</span>) &#123;</span><br><span class="line">        scan_d(u); scan_d(w);</span><br><span class="line">        <span class="keyword">if</span>(l[u].size() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l[u].front());</span><br><span class="line">          l[u].pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l[u].back());</span><br><span class="line">          l[u].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cmd == <span class="number">3</span>) &#123;</span><br><span class="line">        scan_d(u); scan_d(v); scan_d(w);</span><br><span class="line">        <span class="keyword">if</span>(w == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(!l[v].empty()) &#123;</span><br><span class="line">            l[u].emplace_back(l[v].front());</span><br><span class="line">            l[v].pop_front();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span>(!l[v].empty()) &#123;</span><br><span class="line">            l[u].emplace_back(l[v].back());</span><br><span class="line">            l[v].pop_back();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：（一道比较简单的签到题），这题我在第17分钟的时候就提交了DP做法，就是先把1串拆出来，两头的花费为1，中间的花费为2，然后做背包容量为k+1的01背包，一开始想的是最左花费为0，后来觉得不太对，有可能拆分后原先最左不在最左了，于是分了两种情况讨论了一下。折腾了2h才步入正轨。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; seg;</span><br><span class="line"><span class="keyword">int</span> f[maxn], L, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gao2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  seg.clear();</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i, tot = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(j &lt; n &amp;&amp; s[j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        tot++, j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>) seg.push_back(make_pair(tot, <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == n) seg.push_back(make_pair(tot, <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">else</span> seg.push_back(make_pair(tot, <span class="number">2</span>));</span><br><span class="line">      i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> seg[<span class="number">0</span>].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seg.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt;= seg[i].second; j--) &#123;</span><br><span class="line">      f[j] = max(f[j], f[j-seg[i].second]+seg[i].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    k++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, gao2());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赛后感觉应该把B C D按照正解做一下。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这场出的三题，有两道和标算不太一样啊。。。其中一道题还是因为数据弱暴力过的，感觉这样下去不太行啊。。。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018百度之星" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F/"/>
    
    
      <category term="暴力" scheme="https://vincentxwd.github.io/blog/tags/%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="规律" scheme="https://vincentxwd.github.io/blog/tags/%E8%A7%84%E5%BE%8B/"/>
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>[总结] 关于01背包和完全背包以及优化</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/11/%E6%80%BB%E7%BB%93-%E5%85%B3%E4%BA%8E01%E8%83%8C%E5%8C%85%E5%92%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/11/总结-关于01背包和完全背包/</id>
    <published>2018-08-10T17:22:48.000Z</published>
    <updated>2018-08-10T18:02:04.132Z</updated>
    
    <content type="html"><![CDATA[<p>今天晚上又被问起01背包和完全背包的遍历顺序了，我决定写一篇博文，这样再有人问我就可以直接把这篇文章发给他了。</p><p>我要不要先以我的方式来介绍一下这两个问题？首先我们知道01背包和完全背包的状态转移方程：</p><p>01背包：$f(i,j)=max{f(i-1,j), f(i-1,j-w_i)+v_i}$</p><p>完全背包：$f(i,j)=max{f(i-1,j),f(i-1,j-kw_i)+kv_i}$</p><p>简单解释一下，以01背包为例，我们定义$f(i,j)$为扫到第$i$个物品为止，背包容量为$j$时的最大价值。我们依次从第一个物品开始，决定要不要往这个背包里放，如果放的话，我们一定会从另一个状态转移过来，这个状态即扫到上一个物品、同时容量为$j-w_i$时的状态，为什么不是比$j-w_i$更小的一个状态？因为这个方程满足最优子结构：保证$f(i-1,j-w_i)$一定由上一个最优状态转移来，那么这个状态必然是最优的。完全背包也是如此，只不过朴素的做法需要多枚举一维第$i$个物品放的个数。</p><a id="more"></a><p>我们回到最开始的问题：01背包和完全背包的遍历顺序为什么会不一样？究竟有什么关系？</p><p>在我初学背包问题的时候也想到了这个问题，但是很久之后才去想着弄明白这件事。一般提出这个问题的是已经了解了这两种背包问题并且知道了他们的优化算法的同学。能提出这个问题也说明实际上并没有真正理解这两个状态转移的内涵（以及没认真看背包九讲2333）。</p><p>首先介绍一下01背包的优化，针对01背包的时间复杂度是无法再优化的了，但是朴素地开二维数组是冗余的。有人发现了这个问题，并且进一步发现了01背包的更新规律：<strong>在更新$i,j$时，并不会用到比$j$大的位置，即$f(i-1,k), k&gt;j$。</strong>这很显而易见，因为<strong>物品的重量（花费）是大于等于0的，因此$j-w_i≥j$是一定成立的</strong>。所以我们才会有那个喜闻乐见的一位数组优化，只不过内层的更新顺序是从背包容量到物品重量（花费）的递减遍历顺序，<strong>这样能保证我们的递推是由扫到上一个物品时留下的数组中更新过来的</strong>，我贴一下喜闻乐见的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= w[i]; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得还不够清楚，那我贴一个二维的、滚动数组形式的来帮你理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; w[i]) &#123;</span><br><span class="line">      f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[i][j] = max(f[i][j], f[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; w[i]) &#123;</span><br><span class="line">      f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[i][j] = max(f[i][j], f[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还会发现，一位数组优化后的代码更简洁，因为不需要转移$j&lt;w_i$时的状态（一位数组里，不转移就直接保存在原位了）。</p><p>这就是为什么一位数组优化的01背包内层循环遍历顺序为什么是背包容量到物品重量的原因。</p><p>再看一下完全背包，我们朴素的完全背包更新是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; w[i]) &#123;</span><br><span class="line">      f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k * w[i] &lt;= j; k++) &#123;</span><br><span class="line">      f[i][j] = max(f[i][j], f[i<span class="number">-1</span>][j-k*w[i]]+k*v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多了一层，遍历物品件数，复杂度变高。</p><p>背包九讲里将完全背包转化为01背包来做，我们记得刚刚讨论过的01背包的一位数组优化，为了防止把扫到上一个物品的状态用扫到当前物品的状态更新掉，我们内层循环倒过来更新。但是反过来会发生什么呢？反过来的话，当我们更新$f(j)$的时候，会从$f(j-w_i)$更新过来，但<strong>此时$f(j-w_i)$或许已经包括了当前这个物品，那么$f(j)$再被此状态更新的话，实际上就相当于包括了两个物品$i$</strong>，这也是我们希望的，因为完全背包不限制每种物品数量，这也是这个优化成立的原因。贴份代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= W; j++) &#123;</span><br><span class="line">    f[j] = max(f[j], f[j-w[i]]+v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天晚上又被问起01背包和完全背包的遍历顺序了，我决定写一篇博文，这样再有人问我就可以直接把这篇文章发给他了。&lt;/p&gt;
&lt;p&gt;我要不要先以我的方式来介绍一下这两个问题？首先我们知道01背包和完全背包的状态转移方程：&lt;/p&gt;
&lt;p&gt;01背包：$f(i,j)=max{f(i-1,j), f(i-1,j-w_i)+v_i}$&lt;/p&gt;
&lt;p&gt;完全背包：$f(i,j)=max{f(i-1,j),f(i-1,j-kw_i)+kv_i}$&lt;/p&gt;
&lt;p&gt;简单解释一下，以01背包为例，我们定义$f(i,j)$为扫到第$i$个物品为止，背包容量为$j$时的最大价值。我们依次从第一个物品开始，决定要不要往这个背包里放，如果放的话，我们一定会从另一个状态转移过来，这个状态即扫到上一个物品、同时容量为$j-w_i$时的状态，为什么不是比$j-w_i$更小的一个状态？因为这个方程满足最优子结构：保证$f(i-1,j-w_i)$一定由上一个最优状态转移来，那么这个状态必然是最优的。完全背包也是如此，只不过朴素的做法需要多枚举一维第$i$个物品放的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="算法总结" scheme="https://vincentxwd.github.io/blog/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
      <category term="总结" scheme="https://vincentxwd.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2018牛客多校07 C Bit Compression (DP)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/10/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A107-C-Bit-Compression-DP/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/10/2018牛客多校07-C-Bit-Compression-DP/</id>
    <published>2018-08-10T08:04:38.000Z</published>
    <updated>2018-08-10T08:08:40.854Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/acm/contest/145/C" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/145/C</a></p><p><strong>一个长度为$2^n$的01串，每次允许相邻两个数字进行与、或、异或操作，最终希望结果是1，问有多少种不同的操作路径。</strong></p><a id="more"></a><p>$f(i,j)$表示01串从$2^n$开始，扫到长度为$2^i$时，01串变为j时的路径数，用一个map来记录状态，然后暴力dp转移到下一层就行。整体复杂度是$O(2^nn)$，可以过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300200</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; f[<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">22</span>; i++) f[i].clear();</span><br><span class="line">    <span class="built_in">string</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    f[n][s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="built_in">string</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span>(it = f[i].begin(); it != f[i].end(); it++) &#123;</span><br><span class="line">        tmp = it-&gt;first, tot = it-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> nn = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        a = b = c = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nn; j+=<span class="number">2</span>) &#123;</span><br><span class="line">          a += ((tmp[j]-<span class="string">'0'</span>) &amp; (tmp[j+<span class="number">1</span>]-<span class="string">'0'</span>)) + <span class="string">'0'</span>;</span><br><span class="line">          b += ((tmp[j]-<span class="string">'0'</span>) | (tmp[j+<span class="number">1</span>]-<span class="string">'0'</span>)) + <span class="string">'0'</span>;</span><br><span class="line">          c += ((tmp[j]-<span class="string">'0'</span>) ^ (tmp[j+<span class="number">1</span>]-<span class="string">'0'</span>)) + <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i<span class="number">-1</span>][a] += tot;</span><br><span class="line">        f[i<span class="number">-1</span>][b] += tot;</span><br><span class="line">        f[i<span class="number">-1</span>][c] += tot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">0</span>][<span class="string">"1"</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/145/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/145/C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个长度为$2^n$的01串，每次允许相邻两个数字进行与、或、异或操作，最终希望结果是1，问有多少种不同的操作路径。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="2018牛客多校" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces348D] Turtles (DP, LGV引理)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/10/Codeforces348D-Turtles-LiDP-LGV%E5%BC%95%E7%90%86/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/10/Codeforces348D-Turtles-LiDP-LGV引理/</id>
    <published>2018-08-09T17:57:32.000Z</published>
    <updated>2018-08-09T18:05:16.583Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/348/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/348/problem/D</a></p><p><strong>两只乌龟在棋盘上从(1,1)出发到(n,m)，其中有的地方有障碍物，两只乌龟希望找到有多少对路径，使得他们到(n,m)的路上不相交。</strong></p><a id="more"></a><p>如果我没有做牛客多校，我也不会知道这个冷艳的Lindstrom-Gessel-Viennot引理。今天翻笔记看到了，还记得CF上有一道考这个的，于是来除草。</p><p>这东西出题很单一，就是用来计算n对起止点不相交路径组合数的，出题也挺单一，其中的一个trick可能是在拆点这方面，给出公式：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/CF348D1.png" alt="img"></p><p>其中$e(a_i,b_j)$表示从起点$a_i$到终点$b_j$的路径数，M的行列式的值就是我们要求的不相交路径的组合数了。</p><p>关于拆点，一般都是移动到起点附近步长为1的位置，终点也是，具体我不太明白，希望有朝一日能证明出来：)</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/CF348D.png" alt="img"></p><p>这题的DP方程就很简单了，看代码吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3030</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line">LL f[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">1</span>][<span class="number">2</span>] == <span class="string">'#'</span> || s[<span class="number">2</span>][<span class="number">1</span>] == <span class="string">'#'</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL a, b, c, d;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">2</span>] = (s[<span class="number">1</span>][<span class="number">2</span>] != <span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][j] == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">f[i][j] += (f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>]) % mod;</span><br><span class="line">f[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a = f[n<span class="number">-1</span>][m], b = f[n][m<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">2</span>][<span class="number">1</span>] = (s[<span class="number">2</span>][<span class="number">1</span>] != <span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][j] == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">f[i][j] += (f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>]) % mod;</span><br><span class="line">f[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c = f[n<span class="number">-1</span>][m], d = f[n][m<span class="number">-1</span>];</span><br><span class="line">LL ret = ((a * d) % mod - (b * c) % mod + mod) % mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈，除草真开心啊！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://codeforces.com/contest/348/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/348/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两只乌龟在棋盘上从(1,1)出发到(n,m)，其中有的地方有障碍物，两只乌龟希望找到有多少对路径，使得他们到(n,m)的路上不相交。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
      <category term="组合数学" scheme="https://vincentxwd.github.io/blog/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1017E] The Supersonic Rocket (凸包, KMP)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/09/Codeforces1017E-The-Supersonic-Rocket-%E5%87%B8%E5%8C%85-KMP/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/09/Codeforces1017E-The-Supersonic-Rocket-凸包-KMP/</id>
    <published>2018-08-09T14:50:12.000Z</published>
    <updated>2018-08-09T14:52:39.164Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1017/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1017/problem/E</a></p><p><strong>给你两组点，问你这两组点的凸包是不是同构的。</strong></p><a id="more"></a><p>先分别跑出两组点的凸包，判断一下点数是否相等，然后依次按照凸包的长度和拐点的角度记录下数列，然后可以用最小表示法都调成最小表示，或者对其中一个数列扩大两倍作匹配串，另一个作模式串跑KMP。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">1500500</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> LL x, y; &#125;Point;</span><br><span class="line">Point point[maxn];</span><br><span class="line">LL st[maxn], top;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">cross</span><span class="params">(Point p0, Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dis</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">  LL tmp = cross(point[<span class="number">0</span>], p1, p2);</span><br><span class="line">  <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(tmp == <span class="number">0</span>) <span class="keyword">return</span> dis(point[<span class="number">0</span>], p1) &lt; dis(point[<span class="number">0</span>], p2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graham</span><span class="params">(LL n, <span class="built_in">vector</span>&lt;Point&gt; &amp;ret)</span> </span>&#123;</span><br><span class="line">  ret.clear();</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(point[<span class="number">0</span>].y &gt;= point[i].y) &#123;</span><br><span class="line">      <span class="keyword">if</span>(point[<span class="number">0</span>].y == point[i].y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(point[<span class="number">0</span>].x &gt; point[i].x) swap(point[i], point[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> swap(point[<span class="number">0</span>], point[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(point+<span class="number">1</span>, point+n, cmp);</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  st[top++] = <span class="number">0</span>, st[top++] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(top<span class="number">-2</span> &gt;= <span class="number">0</span> &amp;&amp; cross(point[st[top<span class="number">-2</span>]], point[st[top<span class="number">-1</span>]], point[i]) &lt;= <span class="number">0</span>) --top;</span><br><span class="line">    st[top++] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; top; i++) ret.emplace_back(point[st[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point a[maxn], b[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; conv1, conv2;</span><br><span class="line">LL n, m;</span><br><span class="line"></span><br><span class="line">LL na, nb;</span><br><span class="line">LL x[maxn];</span><br><span class="line">LL y[maxn];</span><br><span class="line">LL pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpre</span><span class="params">(LL *y, LL *pre)</span> </span>&#123;</span><br><span class="line">  LL j, k;</span><br><span class="line">  <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="number">-1</span>));</span><br><span class="line">  pre[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  j = <span class="number">0</span>; k = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(j &lt; nb) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">-1</span> || y[j] == y[k]) &#123;</span><br><span class="line">      j++; k++;</span><br><span class="line">      <span class="keyword">if</span>(y[j] != y[k]) pre[j] = k;</span><br><span class="line">      <span class="keyword">else</span> pre[j] = pre[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> k = pre[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  LL i = <span class="number">0</span>;</span><br><span class="line">  LL j = <span class="number">0</span>;</span><br><span class="line">  getpre(y, pre);</span><br><span class="line">  <span class="keyword">while</span>(i &lt; na) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">-1</span> || x[i] == y[j]) &#123;</span><br><span class="line">      i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> j = pre[j];</span><br><span class="line">    <span class="keyword">if</span>(j == nb) ans++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="keyword">sizeof</span>(y));</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;b[i].x,&amp;b[i].y);</span><br><span class="line">    conv1.clear(); conv2.clear();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n; i++) point[i] = a[i];</span><br><span class="line">    graham(n, conv1);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; m; i++) point[i] = b[i];</span><br><span class="line">    graham(m, conv2);</span><br><span class="line">    <span class="keyword">if</span>(conv1.size() != conv2.size()) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      na = conv1.size() * <span class="number">6</span>, nb = conv2.size() * <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; conv1.size(); i++) &#123;</span><br><span class="line">        x[i*<span class="number">3</span>] = dis(conv1[i],conv1[(i+<span class="number">1</span>)%conv1.size()]);</span><br><span class="line">        x[i*<span class="number">3</span>+<span class="number">1</span>] = cross(conv1[(i+<span class="number">1</span>)%conv1.size()],conv1[i],conv1[(i+<span class="number">2</span>)%conv1.size()]);</span><br><span class="line">        x[i*<span class="number">3</span>+<span class="number">2</span>] = dis(conv1[(i+<span class="number">1</span>)%conv1.size()],conv1[(i+<span class="number">2</span>)%conv1.size()]);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x[i*3]&lt;&lt;" "&lt;&lt;x[i*3+1]&lt;&lt;" "&lt;&lt;x[i*3+2]&lt;&lt;" ";</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; conv1.size(); i++) &#123;</span><br><span class="line">        x[i*<span class="number">3</span>+na/<span class="number">2</span>] = x[i*<span class="number">3</span>];</span><br><span class="line">        x[i*<span class="number">3</span>+<span class="number">1</span>+na/<span class="number">2</span>] = x[i*<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line">        x[i*<span class="number">3</span>+<span class="number">2</span>+na/<span class="number">2</span>] = x[i*<span class="number">3</span>+<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x[i*3+na/2]&lt;&lt;" "&lt;&lt;x[i*3+1+na/2]&lt;&lt;" "&lt;&lt;x[i*3+2+na/2]&lt;&lt;" ";</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; conv2.size(); i++) &#123;</span><br><span class="line">        y[i*<span class="number">3</span>] = dis(conv2[i],conv2[(i+<span class="number">1</span>)%conv2.size()]);</span><br><span class="line">        y[i*<span class="number">3</span>+<span class="number">1</span>] = cross(conv2[(i+<span class="number">1</span>)%conv2.size()],conv2[i],conv2[(i+<span class="number">2</span>)%conv2.size()]);</span><br><span class="line">        y[i*<span class="number">3</span>+<span class="number">2</span>] = dis(conv2[(i+<span class="number">1</span>)%conv2.size()],conv2[(i+<span class="number">2</span>)%conv2.size()]);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; y[i*3]&lt;&lt;" "&lt;&lt;y[i*3+1]&lt;&lt;" "&lt;&lt;y[i*3+2]&lt;&lt;" ";</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">      LL ret = kmp();</span><br><span class="line">      <span class="keyword">if</span>(ret) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://codeforces.com/contest/1017/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1017/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给你两组点，问你这两组点的凸包是不是同构的。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="计算几何" scheme="https://vincentxwd.github.io/blog/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="凸包" scheme="https://vincentxwd.github.io/blog/tags/%E5%87%B8%E5%8C%85/"/>
    
      <category term="KMP" scheme="https://vincentxwd.github.io/blog/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1017A-D] Codeforces Round 502 (Div.1+Div.2)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/09/Codeforces1017A-D-Codeforces-Round-502-Div-1-Div-2/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/09/Codeforces1017A-D-Codeforces-Round-502-Div-1-Div-2/</id>
    <published>2018-08-08T17:31:42.000Z</published>
    <updated>2018-08-08T17:43:26.486Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1017" target="_blank" rel="noopener">http://codeforces.com/contest/1017</a></p><p><strong>这把肯定要上分的，结果因为服务器爆炸，unrated了好气。。</strong></p><a id="more"></a><p>A：太水了不多说。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> P = struct &#123;</span><br><span class="line">  <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">  <span class="keyword">int</span> s, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">P p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; p[i].a&gt;&gt;p[i].b&gt;&gt;p[i].c&gt;&gt;p[i].d;</span><br><span class="line">      p[i].s = p[i].a+p[i].b+p[i].c+p[i].d;</span><br><span class="line">      p[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, [](P a, P b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.s == b.s ? a.id &lt; b.id : a.s &gt; b.s;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(p[i].id == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>给你两个01串，要求你交换第一个串中的任意两个数，使得这两个串“或”操作后的结果和原始的不一样，问多少种换法。</strong></p><p>手写一下会发现导致变化的a、b串某一位置的组合是“10”（用0换掉第一个1）和“00”（用1换掉第一个0），我们统计这样的位置，以及0、1的出现次数，把这两种结果加起来，再减掉一次10和00出现的组合乘积就行了（因为10中的1和00中的0会多进行一次）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line">LL tot;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    LL o = <span class="number">0</span>, z = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      vis[a[i]-<span class="string">'0'</span>]++;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="string">'1'</span>) o++;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="string">'0'</span>) z++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[<span class="number">0</span>] == n || vis[<span class="number">1</span>] == n) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="string">'0'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) x++;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="string">'1'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) y++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; o*x+z*y-x*y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>构造一个长度为n排列，使得这个排列的LIS和LDS长度之和最小。</strong></p><p>遇事不决打个表：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/CF1017C.png" alt="img"></p><p>我们发现一个规律：当要构造长度为n的排列时，我们可以找到第一个比n大的平方数$k^2$，然后我们依次放入$k^2-k+1,…k^2-1,k^2,…,1,2,…,k$，当要放的数比n大的时候不输出就ok了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line">LL n, nn;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp, gen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    gen.clear();</span><br><span class="line">    LL nn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(nn * nn &lt; n) nn++;</span><br><span class="line">    LL circle = nn;</span><br><span class="line">    nn = nn * nn;</span><br><span class="line">    LL del = nn - n;</span><br><span class="line">    <span class="keyword">while</span>(nn) &#123;</span><br><span class="line">      tmp.clear();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; circle; i++, nn--) tmp.emplace_back(nn);</span><br><span class="line">      reverse(tmp.begin(), tmp.end());</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp) gen.emplace_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : gen) <span class="keyword">if</span>(x &lt;= n) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打表代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] &gt; a[j]) f[i] = max(f[i], f[j]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = max(ret, f[i]);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] &lt; a[j]) f[i] = max(f[i], f[j]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = max(ret, f[i]);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = i, b[i] = i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> tmp = lis() + lds();</span><br><span class="line">      <span class="keyword">if</span>(tmp &lt;= ret) &#123;</span><br><span class="line">        ret = tmp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: "</span>, ret);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">          b[i] = a[i];</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(a+<span class="number">1</span>, a+n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d: "</span>, ret);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：<strong>两个01串有个匹配的价值，对应位相同的话就要加上那位的价值。给你一些询问串，问有多少串和它的匹配价值不超过k。</strong>  </p><p>这题n给的很小，考虑预处理出任意串和所给串的价值，然后统计当前串这个价值下的字符串数，维护一个前缀和，然后查询就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> wu[<span class="number">4096</span>][<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">int</span> ret[<span class="number">4096</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">500500</span>];</span><br><span class="line"><span class="keyword">char</span> tmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">conv</span><span class="params">(<span class="keyword">char</span> *x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]); </span><br><span class="line">  <span class="keyword">int</span> nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, tmp);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      x += tmp[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nn; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nn; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(((<span class="number">1</span>&lt;&lt;k)&amp;i) == ((<span class="number">1</span>&lt;&lt;k)&amp;j)) &#123;</span><br><span class="line">          tmp += w[n<span class="number">-1</span>-k];</span><br><span class="line">          <span class="keyword">if</span>(tmp &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(tmp &lt;= <span class="number">100</span>) ret[i][tmp] += vis[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nn; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">100</span>; k++) &#123;</span><br><span class="line">      ret[i][k] += ret[i][k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,tmp,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      x += tmp[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret[x][k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://codeforces.com/contest/1017&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1017&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这把肯定要上分的，结果因为服务器爆炸，unrated了好气。。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="规律" scheme="https://vincentxwd.github.io/blog/tags/%E8%A7%84%E5%BE%8B/"/>
    
      <category term="构造" scheme="https://vincentxwd.github.io/blog/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="预处理" scheme="https://vincentxwd.github.io/blog/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>[AtCoderARC100D] Equal Cut (枚举, 二分)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/08/AtCoderARC100D-Equal-Cut-%E6%9E%9A%E4%B8%BE-%E4%BA%8C%E5%88%86/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/08/AtCoderARC100D-Equal-Cut-枚举-二分/</id>
    <published>2018-08-07T17:00:12.000Z</published>
    <updated>2018-08-07T17:03:45.746Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://arc100.contest.atcoder.jp/tasks/arc100_b" target="_blank" rel="noopener">https://arc100.contest.atcoder.jp/tasks/arc100_b</a></p><p><strong>给你n个数，要求你不改变顺序将这n个数字切分成4段，问四段中各段求和后最大和与最小和之间的差</strong></p><a id="more"></a><p>切三刀，可以首先枚举中间拿刀，然后再在两边分别二分各自的那一刀，让各自拆分成的两个集合的和的差值最小，这样才能保证整体的差值最小。这题对我来说挺难写的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; a, s;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1E18</span>, tmp = <span class="number">1E18</span>;</span><br><span class="line">  <span class="keyword">int</span> lo = <span class="number">1</span>, hi = id, s1 = <span class="number">1</span>, s2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">1E18</span> || tmp &gt; (LL)<span class="built_in">abs</span>(s[id]-s[mid]-s[mid])) &#123;</span><br><span class="line">      tmp = (LL)<span class="built_in">abs</span>(s[id]-s[mid]-s[mid]);</span><br><span class="line">      s1 = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[id]-s[mid]&lt;s[mid]) hi = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lo = id + <span class="number">1</span>, hi = n, tmp = <span class="number">1E18</span>;</span><br><span class="line">  <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">1E18</span> || tmp &gt; (LL)<span class="built_in">abs</span>(s[n]-s[mid]-(s[mid]-s[id]))) &#123;</span><br><span class="line">      tmp = (LL)<span class="built_in">abs</span>(s[n]-s[mid]-(s[mid]-s[id]));</span><br><span class="line">      s2 = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[n]-s[mid]&lt;s[mid]-s[id]) hi = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LL L = min(&#123;s[s1], s[id]-s[s1], s[s2]-s[id], s[n]-s[s2]&#125;);</span><br><span class="line">  LL R = max(&#123;s[s1], s[id]-s[s1], s[s2]-s[id], s[n]-s[s2]&#125;);</span><br><span class="line">  ret = min(ret, R-L);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    a.resize(n+<span class="number">1</span>); s.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">      s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">1E18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ret = min(ret, gao(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://arc100.contest.atcoder.jp/tasks/arc100_b" target="_blank" rel="noopener">https://arc100.contest.atcoder.jp/tasks/arc100_b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://arc100.contest.atcoder.jp/tasks/arc100_b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arc100.contest.atcoder.jp/tasks/arc100_b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给你n个数，要求你不改变顺序将这n个数字切分成4段，问四段中各段求和后最大和与最小和之间的差&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
      <category term="枚举" scheme="https://vincentxwd.github.io/blog/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="二分" scheme="https://vincentxwd.github.io/blog/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[POJ3744] Scout YYF I（概率, DP, 矩阵优化）</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/07/POJ3744-Scout-YYF-I%EF%BC%88%E6%A6%82%E7%8E%87-DP-%E7%9F%A9%E9%98%B5%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/07/POJ3744-Scout-YYF-I（概率-DP-矩阵优化）/</id>
    <published>2018-08-07T15:08:37.000Z</published>
    <updated>2018-08-07T15:17:10.568Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://cn.vjudge.net/problem/POJ-3744" target="_blank" rel="noopener">https://cn.vjudge.net/problem/POJ-3744</a></p><p><strong>一个人在一条线上走，线上有n个点有地雷，这个人每次有一定概率$p$走一步，也有$1-p$的概率跳两步。问这个人不踩地雷的概率是多少</strong>。</p><a id="more"></a><p>我们根据题意能推出递推式：$f(i)$表示走到$i$处的概率为多少。$f(1)=1$，$f(i)=p×f(i-1)+(1-p)×f(i-2)$。</p><p>由于线很长，但是地雷很少。我们观察这个递推式是线性的，于是可以用矩阵快速幂优化，构造矩阵：<br>$$<br>\begin{pmatrix}f(n)\f(n-1)\end{pmatrix}=\begin{pmatrix}p&amp;1-p\1&amp;0\end{pmatrix}\begin{pmatrix}f(n-1)\f(n-2)\end{pmatrix}<br>$$<br>对于每一个雷的位置进行分段，计算到那个地方不踩中的概率，递推所有段走到雷处不中的概率，用乘法原理就能求出来结果了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> m[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;Matrix;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">mul</span><span class="params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">  Matrix ret;</span><br><span class="line">  <span class="built_in">memset</span>(ret.m, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret.m));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b.m[j][k] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ret.m[i][k] += a.m[i][j] * b.m[j][k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">M</span><span class="params">(Matrix a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  Matrix ret;</span><br><span class="line">  <span class="built_in">memset</span>(ret.m, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret.m));</span><br><span class="line">  ret.m[<span class="number">0</span>][<span class="number">0</span>] = ret.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  Matrix tmp = a;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ret = mul(ret, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    tmp = mul(tmp, tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">    sort(x, x+n);</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">double</span> tot = <span class="number">1.0</span>;</span><br><span class="line">    Matrix p;</span><br><span class="line">    p.m[<span class="number">0</span>][<span class="number">0</span>] = q, p.m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>-q;</span><br><span class="line">    p.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, p.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    ret = M(p, x[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">    tot *= (<span class="number">1</span> - ret.m[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(x[i] == x[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      ret = M(p, x[i]-x[i<span class="number">-1</span>]<span class="number">-1</span>);</span><br><span class="line">      tot *= (<span class="number">1</span> - ret.m[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7f\n"</span>, tot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://cn.vjudge.net/problem/POJ-3744&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.vjudge.net/problem/POJ-3744&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个人在一条线上走，线上有n个点有地雷，这个人每次有一定概率$p$走一步，也有$1-p$的概率跳两步。问这个人不踩地雷的概率是多少&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/POJ/"/>
    
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
      <category term="概率" scheme="https://vincentxwd.github.io/blog/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="矩阵快速幂" scheme="https://vincentxwd.github.io/blog/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>[AtCoderSoundHound18D] Saving Snuuk （最短路）</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/07/AtCoderSoundHound18D-Saving-Snuuk-%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/07/AtCoderSoundHound18D-Saving-Snuuk-（最短路）/</id>
    <published>2018-08-07T12:04:40.000Z</published>
    <updated>2018-08-07T15:08:55.971Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_d" target="_blank" rel="noopener">https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_d</a></p><p><strong>有n个城市，一个人从s出发到t。手里一开始有1E15日元，现在有两种货币，这个人只能将日元兑换成另一种货币，并且是全部兑换。每到一个城市，这人就会在该城市呆一年。城市之间有火车，火车票价格是$a_i$yen或$b_i$snuuk，在每一个城市$i$，第$i$年的时候可以在该城市将yen兑换成snuuk。现在希望让这人剩的snuuk最多，问这人在1~n年内剩最多为多少snuuk。</strong></p><a id="more"></a><p>我们首先关注火车票的花费，希望snuuk剩的最多，只有在买火车票时才会花费，因此直接将火车票花费最小化就可以。</p><p>我们做两次最短路：$s$到各点，使用yen做货币，价格为$d1_i$；$t$到各点，使用snuuk做货币，价格为$d2_i$。这样我们可以获得每一个点的总计花费就是$d1_i+d2_i$。</p><p>然后再考虑每一年，这人要在每一个城市呆最少一年，最长无限。那么按照城市的兑换开始时间倒着扫一遍，用年份多的剩的多的更新前几年的就可以了。</p><p>（流下了不会写C++的眼泪）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;LL, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> Edge = tuple&lt;<span class="keyword">int</span>, LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; d1, d2;</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; ret;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; G;</span><br><span class="line">priority_queue&lt;pli, <span class="built_in">vector</span>&lt;pli&gt;, greater&lt;pli&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">  d1[s] = <span class="number">0</span>; pq.emplace(<span class="number">0</span>, s);</span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  LL w, tw;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    tie(tw, u) = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(d1[u] &lt; tw) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> edge : G[u]) &#123;</span><br><span class="line">      tie(v, w, ignore) = edge;</span><br><span class="line">      <span class="keyword">if</span>(d1[v] &gt; d1[u] + w) &#123;</span><br><span class="line">        d1[v] = d1[u] + w;</span><br><span class="line">        pq.emplace(d1[v], v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">  d2[t] = <span class="number">0</span>; pq.emplace(<span class="number">0</span>, t);</span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  LL w, tw;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    tie(tw, u) = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(d2[u] &lt; tw) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> edge : G[u]) &#123;</span><br><span class="line">      tie(v, ignore, w) = edge;</span><br><span class="line">      <span class="keyword">if</span>(d2[v] &gt; d2[u] + w) &#123;</span><br><span class="line">        d2[v] = d2[u] + w;</span><br><span class="line">        pq.emplace(d2[v], v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  LL a, b;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t) &#123;</span><br><span class="line">    G.resize(n+<span class="number">1</span>); ret.resize(n+<span class="number">1</span>);</span><br><span class="line">    d1.resize(n+<span class="number">1</span>); d1.assign(d1.size(), numeric_limits&lt;LL&gt;::max());</span><br><span class="line">    d2.resize(n+<span class="number">1</span>); d2.assign(d2.size(), numeric_limits&lt;LL&gt;::max());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; a &gt;&gt; b;</span><br><span class="line">      G[u].emplace_back(v, a, b);</span><br><span class="line">      G[v].emplace_back(u, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    gao1(); gao2();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret[i] = d1[i] + d2[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--) ret[i] = min(ret[i], ret[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; (LL)<span class="number">1E15</span> - ret[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有n个城市，一个人从s出发到t。手里一开始有1E15日元，现在有两种货币，这个人只能将日元兑换成另一种货币，并且是全部兑换。每到一个城市，这人就会在该城市呆一年。城市之间有火车，火车票价格是$a_i$yen或$b_i$snuuk，在每一个城市$i$，第$i$年的时候可以在该城市将yen兑换成snuuk。现在希望让这人剩的snuuk最多，问这人在1~n年内剩最多为多少snuuk。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
      <category term="最短路" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[AtCoderSoundHound18C] Ordinary Beauty（概率, 期望）</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/07/AtCoderSoundHound18C-Ordinary-Beauty%EF%BC%88%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B%EF%BC%89/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/07/AtCoderSoundHound18C-Ordinary-Beauty（概率-期望）/</id>
    <published>2018-08-07T08:52:12.000Z</published>
    <updated>2018-08-07T09:00:37.953Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_c" target="_blank" rel="noopener">https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_c</a></p><p><strong>给你1~n这n个数，现在允许你随机在m个位置上方这n个数，问你放好后的数组中，相邻两个数字的差为d的数对的概率。</strong></p><a id="more"></a><p>m个位置存在m-1对数，由于期望的线性可加性，我们知道答案为$(m-1)</p><p>×在m个数字中挑选出一对差为d的概率$。</p><p>当$d=0$时，相邻两个数字相同的时候才会有贡献，则有一对数字相同的概率为$\frac{n}{n^2}$。</p><p>当$d≠0$时，我们有$(1,d+1),…,(n-d,n)$和$(d+1,1),…,(n,n-d)$这些可能，共有$2×(n-d-d-1+1)=2(n-d)$种，因此一对数字相同的概率是$\frac{2(n-d)}{n^2}$。</p><p>求期望的话，乘上$m-1$就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> n, m, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; d) &#123;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%.15f\n"</span>, (m<span class="number">-1</span>)/n);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.15f\n"</span>, <span class="number">2.0</span>*(n-d)*(m<span class="number">-1</span>)/n/n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给你1~n这n个数，现在允许你随机在m个位置上方这n个数，问你放好后的数组中，相邻两个数字的差为d的数对的概率。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
      <category term="概率" scheme="https://vincentxwd.github.io/blog/tags/%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>[POJ2096] Collecting Bugs （期望, DP）</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/07/POJ2096-Collecting-Bugs-%EF%BC%88%E6%9C%9F%E6%9C%9B-DP%EF%BC%89/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/07/POJ2096-Collecting-Bugs-（期望-DP）/</id>
    <published>2018-08-07T07:32:54.000Z</published>
    <updated>2018-08-07T08:04:54.581Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://cn.vjudge.net/problem/POJ-2096" target="_blank" rel="noopener">https://cn.vjudge.net/problem/POJ-2096</a></p><p><strong>有一个程序员要在$s$个子系统里找$n$个不同的BUG，问在$s$种子系统里找到$n$个BUG的天数期望。</strong></p><a id="more"></a><p>这题是求期望的入门经典，我想拿这道题来做一个总结。</p><p>首先是最重要的、也就是期望的一些性质：</p><p>1：当$X$和$Y$两个<strong>并不一定相互独立</strong>随机变量时，我们有如下性质：<br>$$<br>E(aX+bY)=aE(X)+bE(Y)<br>$$<br>上述性质称为<strong>期望的线性性（可加性）</strong>，证明很容易，略。</p><p>2：<strong>全期望公式</strong>：<br>$$<br>E(Y)=E(E(Y|X))=\sum_{i}P(X=x_i)E(Y|X=x_i)<br>$$<br>当期望存在条件时，可以类比全概率公式获得全期望公式。</p><p>以及解决期望问题的常用方法：</p><p>解决期望问题有两种方法：<strong>高斯消元</strong>或者<strong>DP</strong>。</p><p>1：高斯消元不必多说，我们根据题意枚举出所有状态，并根据状态列出期望方程组，使用高斯消元求得各个状态的期望解。</p><p>2：当所求状态的期望之间存在一定关系的时候，可以使用<strong>动态规划</strong>解决期望问题：首先做的事自然是找准<strong>递推状态</strong>，这是肯定的。找到状态后，接下来要枚举出所有的<strong>状态转移</strong>，同时计算出转移的<strong>条件</strong>和<strong>代价</strong>。我们描述一下上述步骤执行后应该得到的结果：状态$i$、状态$i$下的期望$E(i)$、状态$i$下的递推状态$(j|j由i转移得到)$，每一种状态转移所需的代价$w_i$。</p><p>我们可以由状态i下递推出来的状态j获得i状态的期望：$\sum w_jE(j)$。我们利用<strong>期望的可加性</strong>，就可以得到$i$的期望了。</p><p>对于本题，我们可以设$f(i,j)$表示在$j$个系统中找到$i$个BUG后期望天数。很明显，当$n$天$s$个系统中找到BUG后，该天的期望$E(n,s)=0$。</p><p>接下来我们以找到一个BUG为转移条件，由$(i,j)$可以转移出四个不同的状态：</p><p>$(i,j)$表示在$j$个系统中没有再找到新BUG，转移代价为$p_1=\frac{i}{n} × \frac{j}{s}$。</p><p>$(i+1,j)$表示在$j$个系统中找到了一个新BUG，转移代价为$p_2=\frac{n-i}{n} × \frac{j}{s}$。</p><p>$(i,j+1)$表示在一个新系统中找到了一个已有BUG，转移代价为$p_3=\frac{i}{n} × \frac{s-j}{s}$。</p><p>$(i+1,j+1)$表示在一个新系统中找到了一个新BUG，转移代价为$p_4=\frac{n-i}{n} × \frac{s-j}{s}$。</p><p>我们可以列出状态$(i,j)$的期望等式：<br>$$<br>E(i,j)=p_1E(i,j)+p_2E(i+1,j)+p_3E(i,j+1)+p_4E(i+1,j+1)<br>$$<br>移项得：<br>$$<br>E(i,j)=\frac{p_2E(i+1,j)+p_3E(i,j+1)+p_4E(i+1,j+1)}{1-p_1}<br>$$<br>我们由$(n,s)$倒着递推，递推到$(0,0)$时即为要在s个系统中找到n个BUG的期望了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">double</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;s)) &#123;</span><br><span class="line">    f[n][s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> q = n * s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = s; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n &amp;&amp; j == s) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">double</span> p1 = <span class="keyword">double</span>(i * j) / q;</span><br><span class="line">        <span class="keyword">double</span> p2 = <span class="keyword">double</span>((n - i) * j) / q;</span><br><span class="line">        <span class="keyword">double</span> p3 = <span class="keyword">double</span>(i * (s - j)) / q;</span><br><span class="line">        <span class="keyword">double</span> p4 = <span class="keyword">double</span>((n - i) * (s - j)) / q;</span><br><span class="line">        f[i][j] = (p2*f[i+<span class="number">1</span>][j]+p3*f[i][j+<span class="number">1</span>]+p4*f[i+<span class="number">1</span>][j+<span class="number">1</span>]+<span class="number">1.</span>)/(<span class="number">1.0</span>-p1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4f\n"</span>, f[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://cn.vjudge.net/problem/POJ-2096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.vjudge.net/problem/POJ-2096&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有一个程序员要在$s$个子系统里找$n$个不同的BUG，问在$s$种子系统里找到$n$个BUG的天数期望。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/POJ/"/>
    
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
      <category term="概率" scheme="https://vincentxwd.github.io/blog/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="算法总结" scheme="https://vincentxwd.github.io/blog/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>[HDOJ6351] 18多校05 Beautiful Now (暴力，全排列，置换群)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/06/HDOJ6351-18%E5%A4%9A%E6%A0%A105-Beautiful-Now-%E6%9A%B4%E5%8A%9B%EF%BC%8C%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E7%BD%AE%E6%8D%A2%E7%BE%A4/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/06/HDOJ6351-18多校05-Beautiful-Now-暴力，全排列，置换群/</id>
    <published>2018-08-06T14:55:40.000Z</published>
    <updated>2018-08-06T16:26:11.902Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6351" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6351</a></p><p><strong>给你一个数字$n$和交换次数$k$，问你最多交换$k$次，这个数最大能变为多大，最小能变为多小。</strong></p><a id="more"></a><p>暴力枚举这个数字的全排列，然后计算和之前数字之间的交换次数。用置换的方法，总计的最少交换次数为所有环的长度-1的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; perm[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">9</span>; t++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">      a[i] = i;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        now = now * <span class="number">10</span> + a[i];</span><br><span class="line">      <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        <span class="keyword">if</span>(vis[i] != now)</span><br><span class="line">        &#123;</span><br><span class="line">          vis[i] = now;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = a[i]; j != i; j = a[j])</span><br><span class="line">          &#123;</span><br><span class="line">            vis[j] = now;</span><br><span class="line">            tmp++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      perm[t][tmp].push_back(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(next_permutation(a + <span class="number">1</span>, a + t + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(mask)</span><br><span class="line">  &#123;</span><br><span class="line">    ret += a[mask % <span class="number">10</span>] * tmp;</span><br><span class="line">    mask /= <span class="number">10</span>;</span><br><span class="line">    tmp *= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> n[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> t, k, mn, mx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, n, &amp;k);</span><br><span class="line">  t = <span class="built_in">strlen</span>(n);</span><br><span class="line">  <span class="keyword">if</span>(t == <span class="number">10</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1000000000 1000000000\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(k &gt;= t)</span><br><span class="line">    k = t - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">    a[i] = n[i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">  mn = <span class="number">1000000000</span>;</span><br><span class="line">  mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> lj = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t; i++)</span><br><span class="line">    lj *= <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = perm[t][i].begin(); it != perm[t][i].end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> now = apply(*it);</span><br><span class="line">      <span class="keyword">if</span>(now &lt; lj)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      now &lt; mn ? mn = now : <span class="number">0</span>;</span><br><span class="line">      now &gt; mx ? mx = now : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, mn, mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> t1 = <span class="number">1</span>; t1 &lt;= T; t1++)</span><br><span class="line">    solve();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6351&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=6351&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给你一个数字$n$和交换次数$k$，问你最多交换$k$次，这个数最大能变为多大，最小能变为多小。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018杭电多校" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="暴力" scheme="https://vincentxwd.github.io/blog/tags/%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="置换群" scheme="https://vincentxwd.github.io/blog/tags/%E7%BD%AE%E6%8D%A2%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>[HDOJ6354] 18多校05 Everything Has Changed (计算几何)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/06/HDOJ6354-18%E5%A4%9A%E6%A0%A105-Everything-Has-Changed-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/06/HDOJ6354-18多校05-Everything-Has-Changed-计算几何/</id>
    <published>2018-08-06T14:51:21.000Z</published>
    <updated>2018-08-06T16:26:08.512Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6354" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6354</a></p><p><strong>给你一个圆和互不相交的n个小圆，让你计算这个大圆被n个小圆切割后的周长，大圆内部的不计算。</strong></p><a id="more"></a><p>很容易发现小圆和大圆相交以后，周长增加了小圆的弧长-大圆的弧长。用余弦定理计算一下大小圆关于交处的角度，然后用弧长公式算一下即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x, y, r;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">Node p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gao</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b.x &lt; <span class="number">0</span>) b.x = -b.x;</span><br><span class="line">  <span class="keyword">if</span>(b.y &lt; <span class="number">0</span>) b.y = -b.y;</span><br><span class="line">  <span class="keyword">double</span> d = dis(a, b);</span><br><span class="line">  <span class="keyword">double</span> theta1 = <span class="number">2.0</span> * <span class="built_in">acos</span>((d*d+a.r*a.r-b.r*b.r)/(<span class="number">2</span>*d*a.r));</span><br><span class="line">  <span class="keyword">double</span> theta2 = <span class="number">2.0</span> * <span class="built_in">acos</span>((d*d+b.r*b.r-a.r*a.r)/(<span class="number">2</span>*d*b.r));</span><br><span class="line">  <span class="keyword">double</span> L1 = theta1 * a.r;</span><br><span class="line">  <span class="keyword">double</span> L2 = theta2 * b.r;</span><br><span class="line">  <span class="keyword">return</span> L2 - L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">2</span> * pi * r;</span><br><span class="line">    Node o = &#123;<span class="number">0</span>, <span class="number">0</span>, r&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">double</span> d = dis(o, p[i]);</span><br><span class="line">      <span class="keyword">double</span> R = o.r, r = p[i].r;</span><br><span class="line">      <span class="keyword">if</span>(d &gt;= R + r) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(d == R - r) &#123;</span><br><span class="line">        ret += p[i].r * pi * <span class="number">2.0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(R - r &lt; d &amp;&amp; d &lt; R + r) &#123;</span><br><span class="line">        ret += gao(o, p[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.15f\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6354&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=6354&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给你一个圆和互不相交的n个小圆，让你计算这个大圆被n个小圆切割后的周长，大圆内部的不计算。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018杭电多校" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="计算几何" scheme="https://vincentxwd.github.io/blog/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>[AtCoderABC103D] Islands War (贪心，思维)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/06/AtCoderABC103D-Islands-War-%E8%B4%AA%E5%BF%83%EF%BC%8C%E6%80%9D%E7%BB%B4/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/06/AtCoderABC103D-Islands-War-贪心，思维/</id>
    <published>2018-08-06T09:55:41.000Z</published>
    <updated>2018-08-06T16:27:18.272Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://abc103.contest.atcoder.jp/tasks/abc103_d" target="_blank" rel="noopener">https://abc103.contest.atcoder.jp/tasks/abc103_d</a></p><p><strong>有n个岛练成一条线，每两个岛之间有一个桥。现在有m个岛之间发生了冲突，发生冲突的岛就不能连通了，问最少要切断几座桥？</strong></p><a id="more"></a><p>这题很有意思，贪心地去考虑，希望切到的边影响尽可能地大，可以考虑贪心地将发生冲突的右端点从小到大排，然后从左到右开始切。</p><p>可以反证一下：假如选中的某次冲突的右端点不是最优的解，那么可能存在一个在此点左侧的点待切，显然存在的左侧点不是最优点，因为左侧已经统计完将此点之前发生冲突的点对分割开的桥数，再添加一条是冗余的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">pii p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].first,&amp;p[i].second);</span><br><span class="line">      <span class="keyword">if</span>(p[i].first &gt; p[i].second) swap(p[i].first, p[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p+<span class="number">1</span>, p+m+<span class="number">1</span>, [](pii x, pii y)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x.second != y.second) <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">      <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = p[<span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pre &gt; p[i].first) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        tot++;</span><br><span class="line">        pre = p[i].second;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://abc103.contest.atcoder.jp/tasks/abc103_d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://abc103.contest.atcoder.jp/tasks/abc103_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有n个岛练成一条线，每两个岛之间有一个桥。现在有m个岛之间发生了冲突，发生冲突的岛就不能连通了，问最少要切断几座桥？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="思维" scheme="https://vincentxwd.github.io/blog/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>[AtCoderABC104D] We Love ABC (DP, 计数)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/06/AtCoderABC104D-We-Love-ABC-DP-%E8%AE%A1%E6%95%B0/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/06/AtCoderABC104D-We-Love-ABC-DP-计数/</id>
    <published>2018-08-06T03:16:29.000Z</published>
    <updated>2018-08-06T16:27:13.789Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://abc104.contest.atcoder.jp/tasks/abc104_d" target="_blank" rel="noopener">https://abc104.contest.atcoder.jp/tasks/abc104_d</a></p><p><strong>给一个只含有ABC?四种字符的字符串，?可以替换成ABC中的任意一个字符，现在要你统计所有的ABC的组合个数。</strong></p><a id="more"></a><p><em>这题比赛时间内写搓了，因为误读了题目的统计结果，比如?ABC，答案应该是4（AABC BABC CABC）。</em></p><p>我们可以考虑枚举B的位置，并以这个B为链接，那么问题就变成了统计左侧A的个数和右侧C的个数。这里也不能是简单地将左右两侧的A?和C?的个数乘起来，因为固定了某一对A、C后其他字符的变化也是要算作不同组合的。<br>我们将每一个B的位置的计数结果拆成四项来统计，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A、B、C</span><br><span class="line">?、B、C</span><br><span class="line">A、B、?</span><br><span class="line">?、B、?</span><br></pre></td></tr></table></figure><p>第一项很好统计，由于不存在?所以可以直接计数。<br>第二、三项的本质是相同的，我们在B的某一侧存在?时，要枚举任意一个?（让这个?作为A或C出现），那么其他位置的?则是任意的，那么每一个位置对答案的贡献是$3^{k-1}$，其中$k$为?的左侧或右侧总数。<br>第四项和第二、三项也是一样的，但是要在左右两边各取一个?，假设左侧有$x_1$个?，右侧有$x_2$个?，那么计数结果为$3^{x_1-1}×3^{x_2-1}$，整理为$3^{x_1+x_2-2}$。<br>这样我们就推出了每一个B对总体答案的分步贡献，我们维护A、C、?出现次数的前缀和，之后就可以分类讨论了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line">LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line">LL f[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ret *= x; ret %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    x *= x; x %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      f[i][<span class="number">0</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>] + (s[i] == <span class="string">'A'</span>);</span><br><span class="line">      f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">1</span>] + (s[i] == <span class="string">'C'</span>);</span><br><span class="line">      f[i][<span class="number">2</span>] = f[i<span class="number">-1</span>][<span class="number">2</span>] + (s[i] == <span class="string">'?'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'B'</span> || s[i] == <span class="string">'?'</span>) &#123;</span><br><span class="line">        LL q = f[n][<span class="number">2</span>] - (s[i] == <span class="string">'?'</span>);</span><br><span class="line">        ret += mul(<span class="number">3L</span>L, q) * (f[i<span class="number">-1</span>][<span class="number">0</span>] * (f[n][<span class="number">1</span>] - f[i][<span class="number">1</span>]) % mod);</span><br><span class="line">        ret %= mod;</span><br><span class="line">        <span class="keyword">if</span>(q &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">          ret += mul(<span class="number">3L</span>L, q<span class="number">-1</span>) * (f[i<span class="number">-1</span>][<span class="number">0</span>] * (f[n][<span class="number">2</span>] - f[i][<span class="number">2</span>]) % mod);</span><br><span class="line">          ret %= mod;</span><br><span class="line">          ret += mul(<span class="number">3L</span>L, q<span class="number">-1</span>) * (f[i<span class="number">-1</span>][<span class="number">2</span>] * (f[n][<span class="number">1</span>] - f[i][<span class="number">1</span>]) % mod);</span><br><span class="line">          ret %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">          ret += mul(<span class="number">3L</span>L, q<span class="number">-2</span>) * (f[i<span class="number">-1</span>][<span class="number">2</span>] * (f[n][<span class="number">2</span>] - f[i][<span class="number">2</span>]) % mod);</span><br><span class="line">          ret %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://abc104.contest.atcoder.jp/tasks/abc104_d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://abc104.contest.atcoder.jp/tasks/abc104_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给一个只含有ABC?四种字符的字符串，?可以替换成ABC中的任意一个字符，现在要你统计所有的ABC的组合个数。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>[2018百度之星] 资格赛1003 整数规划 (最大匹配)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1003-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1003-整数规划-最大匹配/</id>
    <published>2018-08-05T14:09:51.000Z</published>
    <updated>2018-08-06T16:27:53.142Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1003" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1003</a></p><a id="more"></a><p>希望最大化目标函数，事实上满足 Kuhn–Munkres algorithm 求解最小权匹配过程中的顶标的定义，现在就是要计算最大顶标和，而这正好就是最小权匹配 ，按照$x_i$和$y_i$给定的约束条件连边，同时边权置为负值。然后跑最大匹配，输出结果的相反数。</p><p>这题一般的KM算法是过不了的，因为网上流传的KM代码都到不了$O(n^3)$。于是去UOJ上扒了一份KM模版……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">405</span>;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> lx[N], ly[N];</span><br><span class="line"><span class="keyword">int</span> lmatch[N], rmatch[N];</span><br><span class="line"><span class="keyword">bool</span> lvis[N], rvis[N];</span><br><span class="line"><span class="keyword">int</span> slack[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dt = INF, ru;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">if</span> (!rvis[j] &amp;&amp; slack[j] &lt; dt) &#123;</span><br><span class="line">            dt = slack[j];</span><br><span class="line">            ru = j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lvis[i]) lx[i] -= dt;</span><br><span class="line">        <span class="keyword">if</span> (rvis[i])</span><br><span class="line">            ly[i] += dt;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            slack[i] -= dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ru;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; u; swap(u, lmatch[pre[u]])) rmatch[u] = pre[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    lvis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp;</span><br><span class="line">                <span class="keyword">if</span> (rvis[v] || (tmp = lx[u] + ly[v] - w[u][v]) &gt; slack[v])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                pre[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!rmatch[v]) <span class="keyword">return</span> match(v);</span><br><span class="line">                    rvis[v] = lvis[rmatch[v]] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(rmatch[v]);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    slack[v] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        u = update(n);</span><br><span class="line">        <span class="keyword">if</span> (!rmatch[u]) <span class="keyword">return</span> match(u);</span><br><span class="line">        rvis[u] = lvis[rmatch[u]] = <span class="literal">true</span>;</span><br><span class="line">        q.push(rmatch[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">KM</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        lmatch[i] = rmatch[i] = lx[i] = ly[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            lx[i] = max(lx[i], w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            slack[j] = INF;</span><br><span class="line">            lvis[j] = rvis[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res += lx[i] + ly[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T_T, _ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T_T);</span><br><span class="line">  <span class="keyword">while</span>(T_T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i][j]);</span><br><span class="line">        w[i][j] = -w[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %I64d\n"</span>, ++_, -KM(n));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;amp;pid=1003&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;amp;pid=1003&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018百度之星" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F/"/>
    
    
      <category term="匹配问题" scheme="https://vincentxwd.github.io/blog/tags/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[2018百度之星] 资格赛1005 序列计数 (DP, 树状数组, 随机)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1005-%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0-DP-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E9%9A%8F%E6%9C%BA/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1005-序列计数-DP-树状数组-随机/</id>
    <published>2018-08-05T03:34:48.000Z</published>
    <updated>2018-08-06T16:27:24.645Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1005" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1005</a></p><p><strong>这题随机给你一个1~n的排列，要你统计这1~n的排列中长度为1~n的上升子序列的个数分别是多少。</strong></p><a id="more"></a><p>由于数据是随机的，因此这个序列中的LIS满足下面这个工作：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/2018astar1005.jpg" alt="img"></p><p>LIS的长度大概是$2\sqrt{N}$，当$N=10000$时，LIS的最长长度大约为$200$。</p><p>我们很容易就推出LIS的计数公式：<br>$$<br>f(i,k) += (p_i &gt; p_j)? f(j,k-1) : 0<br>$$<br>可以考虑枚举LIS的长度$l$，用bit维护到第$i$个位置的数字$p[i]$、长度为$l-1$的上升子序列的总数，这样每次扫一个位置的时候，就可以直接查前缀和了。</p><p>由于要更新bit，所以维护一个滚动的dp数组，在查询长度为$l-1$的计数结果的同时，更新答案以及$l$的计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL n;</span><br><span class="line">LL p[maxn];</span><br><span class="line">LL bit[maxn];</span><br><span class="line">LL f[<span class="number">2</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">lowbit</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(LL x, LL val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(LL i = x; i &lt;= n; i+=lowbit(i)) &#123;</span><br><span class="line">    bit[i] += val; bit[i] %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(LL i = x; i; i-=lowbit(i)) &#123;</span><br><span class="line">    ret += bit[i];</span><br><span class="line">    ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL T, _ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    LL x = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%I64d:"</span>, ++_);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %I64d"</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(LL l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">      x = !x;</span><br><span class="line">      LL ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">        <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">          f[x][i] = sum(p[i] - <span class="number">1</span>);</span><br><span class="line">          ret += f[x][i]; ret %= mod;</span><br><span class="line">          add(p[i], f[!x][i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(ret == <span class="number">0</span>) flag = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">" %I64d"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;amp;pid=1005&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;amp;pid=1005&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这题随机给你一个1~n的排列，要你统计这1~n的排列中长度为1~n的上升子序列的个数分别是多少。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018百度之星" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F/"/>
    
    
      <category term="树状数组" scheme="https://vincentxwd.github.io/blog/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>[2018百度之星] 资格赛1006 三原色图 (最小生成树)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1006-%E4%B8%89%E5%8E%9F%E8%89%B2%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1006-三原色图-最小生成树/</id>
    <published>2018-08-04T16:37:14.000Z</published>
    <updated>2018-08-06T16:27:21.757Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1006" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1006</a></p><a id="more"></a><p>这题很简单，按照RG、BG的组合分别跑最小生成树，假如某一种情况无法构造出则抛弃那一种情况。同时给边打标记，最后再取k-(n+1)条最短的未添加到生成树里的边就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id, u, v, w;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Node a, Node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, eid;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; G[maxn];</span><br><span class="line">priority_queue&lt;Node&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  x = find(x); y = find(y);</span><br><span class="line">  <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    pre[y] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; gao1(<span class="keyword">int</span> k) &#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) pre[i] = i;</span><br><span class="line">  <span class="keyword">while</span> (!pq.empty()) pq.pop();</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(G[i][j].c == <span class="string">'R'</span> || G[i][j].c == <span class="string">'G'</span>) &#123;</span><br><span class="line">        pq.push(G[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    Node p = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(unite(p.u, p.v)) &#123;</span><br><span class="line">      tot++;</span><br><span class="line">      ret += p.w;</span><br><span class="line">      vis[p.id] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[G[i][j].id]) pq.push(G[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ret += pq.top().w; pq.pop(); pq.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> make_pair(ret, tot == n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; gao2(<span class="keyword">int</span> k) &#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) pre[i] = i;</span><br><span class="line">  <span class="keyword">while</span> (!pq.empty()) pq.pop();</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(G[i][j].c == <span class="string">'B'</span> || G[i][j].c == <span class="string">'G'</span>) &#123;</span><br><span class="line">        pq.push(G[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    Node p = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(unite(p.u, p.v)) &#123;</span><br><span class="line">      tot++;</span><br><span class="line">      ret += p.w;</span><br><span class="line">      vis[p.id] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[G[i][j].id]) pq.push(G[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ret += pq.top().w; pq.pop(); pq.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> make_pair(ret, tot == n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">  <span class="keyword">char</span> c[<span class="number">5</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    eid = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d%s"</span>,&amp;u,&amp;v,&amp;w,c);</span><br><span class="line">      G[u].push_back(&#123;eid, u, v, w, c[<span class="number">0</span>]&#125;);</span><br><span class="line">      G[v].push_back(&#123;eid++, v, u, w, c[<span class="number">0</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++_);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(k &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> ret = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">      tmp = gao1(k);</span><br><span class="line">      <span class="keyword">if</span>(tmp.second) &#123;</span><br><span class="line">        ret = min(ret, tmp.first);</span><br><span class="line">      &#125;</span><br><span class="line">      tmp = gao2(k);</span><br><span class="line">      <span class="keyword">if</span>(tmp.second) &#123;</span><br><span class="line">        ret = min(ret, tmp.first);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(ret == <span class="number">0x7f7f7f7f</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;amp;pid=1006&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;amp;pid=1006&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018百度之星" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F/"/>
    
    
      <category term="最小生成树" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
</feed>
