<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kirai</title>
  
  <subtitle>Keep going</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://vincentxwd.github.io/blog/"/>
  <updated>2018-12-15T11:02:59.903Z</updated>
  <id>https://vincentxwd.github.io/blog/</id>
  
  <author>
    <name>Kirai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用JS实现UCAS半自动评教脚本</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/15/ucas-pingjiao/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/15/ucas-pingjiao/</id>
    <published>2018-12-15T10:53:56.000Z</published>
    <updated>2018-12-15T11:02:59.903Z</updated>
    
    <content type="html"><![CDATA[<p>自用，同学们有需要的话也可以拿去用。</p><p>打开你的评教页面，chrome按F12调出“检查”，打开Console选项后将下面代码粘贴并回车，保存退出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> td = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'td'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; td.length;i++) &#123;</span><br><span class="line">td[i].getElementsByTagName(<span class="string">"input"</span>)[<span class="number">0</span>].checked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">"input[name='starFlag']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"checked"</span>,<span class="string">"checked"</span>);</span><br><span class="line">$(<span class="string">"textarea[id='merit']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"value"</span>,<span class="string">"课程特色鲜明，内容取舍合理，组织严密，逻辑性强。重点突出，难点讲解清楚。拓展学生知识面，培养分析能力，引导创新。"</span>);</span><br><span class="line">$(<span class="string">"textarea[id='flaw']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"value"</span>,<span class="string">"无"</span>);</span><br><span class="line">$(<span class="string">"textarea[id='suggest']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"value"</span>,<span class="string">"无"</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自用，同学们有需要的话也可以拿去用。&lt;/p&gt;
&lt;p&gt;打开你的评教页面，chrome按F12调出“检查”，打开Console选项后将下面代码粘贴并回车，保存退出。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="工具" scheme="https://vincentxwd.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1084D] The Fair Nut and the Best Path（树DP）</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/11/cf1084d/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/11/cf1084d/</id>
    <published>2018-12-11T03:39:09.000Z</published>
    <updated>2018-12-11T06:33:52.940Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1084/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1084/problem/D</a></p><p><strong>有一棵树，每一个点和边都有权值。一个人希望从一个点走到另一个点，要求在走的过程中点权和不小于边权和。求最大的点权和与边权和之差。</strong></p><a id="more"></a><hr><p>首先可以知道的是，如果两个点之间是任意可达的话，那么走这两个点的时候点权和与边权和之差一定比只选中单个点更大；如果两个点中有一个点比边权小，那选最大的那一个点的收益一定会比全选要更大。</p><p>所以实际上不需要考虑某一个点到另一个点不可达的情况，因为反过来即使可达那也不会是最优的，因此实际上路径是没有必要考虑逆方向的。</p><p>根据上述规则，就可以确定考虑将答案拆成两种：</p><p>一种是当前点为端点的一条链的情况，这种情况需要维护随后可以走的差值最大的链。</p><p>另一种是以当前点为中间点，分别从两个子树中走过来的情况，这时候需要同时维护差值最大和次大的链。</p><p>于是我们相当于是在选转折点，这个并且在这个转折点上选两个权值和最大的子链，使得点权和-边权和最大。就有个问题了，选子链的时候，都是从子链走向转折点，而题目中实际上是应该有一个子链走向转折点，而另一个子链是转折点走过去的。考虑最大连续子序列和，当扫到&lt;0的前缀和时，那么会把当前的dp值设为0，和这个问题实际上是一样的，因此不需要考虑方向的问题了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300300</span>;</span><br><span class="line">LL dp1[maxn], dp2[maxn], d[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  dp1[u] = <span class="number">0</span>, dp2[u] = <span class="number">0</span>;</span><br><span class="line">  LL a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : G[u]) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = x.first, w = x.second;</span><br><span class="line">    <span class="keyword">if</span>(p == v) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    <span class="keyword">if</span>(dp1[v] - w &gt; a) &#123;</span><br><span class="line">      b = a;</span><br><span class="line">      a = dp1[v] - w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dp1[v] - w &gt; b) &#123;</span><br><span class="line">      b = dp1[v] - w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dp1[u] = max(dp1[u], a+d[u]);</span><br><span class="line">  dp2[u] = max(dp2[u], a+b+d[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;d[i]);</span><br><span class="line">      G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span> dp1);</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">0</span>, <span class="keyword">sizeof</span> dp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v, w;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      G[u].emplace_back(v, w);</span><br><span class="line">      G[v].emplace_back(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ret = max(ret, dp2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1084/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1084/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有一棵树，每一个点和边都有权值。一个人希望从一个点走到另一个点，要求在走的过程中点权和不小于边权和。求最大的点权和与边权和之差。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="dp" scheme="https://vincentxwd.github.io/blog/tags/dp/"/>
    
      <category term="树" scheme="https://vincentxwd.github.io/blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[BZOJ4017] [Noi2008]志愿者招募（单纯形法）</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/09/bzoj1061/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/09/bzoj1061/</id>
    <published>2018-12-08T16:11:28.000Z</published>
    <updated>2018-12-09T08:40:07.666Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1061" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=1061</a><br>申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要N 天才能完成，其中第i 天至少需要Ai 个人。 布布通过了解得知，一共有M 类志愿者可以招募。其中第i 类可以从第Si 天工作到第Ti天，招募费用是每人Ci 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。</p><a id="more"></a><hr><p>学习了一个学长的博客，真的很棒：<a href="https://www.hrwhisper.me/introduction-to-simplex-algorithm/" target="_blank" rel="noopener">https://www.hrwhisper.me/introduction-to-simplex-algorithm/</a></p><p>首先这题一定是规划问题，我们根据题意列出优化方程。比如测试样例：</p><p>3 3<br>2 3 4<br>1 2 2<br>2 3 5<br>3 3 2</p><p>我们设第$i$类志愿者招$x_i$个，那么目标是：<br>$$<br>\min 2x_1+5x_2+2x_3<br>$$<br>需要满足：<br>$$<br>x_1\geq 2<br>$$</p><p>$$<br>x_1+x_2\geq 3<br>$$</p><p>$$<br>x_2+x_3\geq 4<br>$$</p><p>对于这类$\min (CX); s.t.\ AX\geq Y$的问题，其对偶问题是：<br>$$<br>\max (YX’);s.t.\ A^TX’\leq C<br>$$<br>然后就会发现这个形式跟输入的格式完全一致了。</p><p>PS：至于为什么这个问题的线性规划一定保证是整数解，因为我们构造的矩阵是全幺模矩阵，有人出现则是1，不出现则是0，由全幺模矩阵的一个定理：对于任何整数向量b，方程组A的所有基本解为整数向量的充分条件是A为幺模矩阵。所以我们可以使用单纯形法解决这个整数规划问题。</p><p>套下模版。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Simplex &#123;</span><br><span class="line">  <span class="comment">// s.t. ax≤b</span></span><br><span class="line">  <span class="comment">// MAX cx</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10010</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1E-9</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1E18</span>;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="keyword">double</span> a[maxm][maxn], b[maxm], c[maxn], v;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    b[l] /= a[l][e];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j != e) a[l][j] /= a[l][e];</span><br><span class="line">    &#125;</span><br><span class="line">    a[l][e] = <span class="number">1</span> / a[l][e];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(a[i][e]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        b[i] -= a[i][e] * b[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(j != e) a[i][j] -= a[i][e] * a[l][j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i][e] = -a[i][e] * a[l][e];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v += c[e] * b[l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j != e) c[j] -= c[e] * a[l][j];</span><br><span class="line">    &#125;</span><br><span class="line">    c[e] = -c[e] * a[l][e];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> e = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(e = <span class="number">1</span>; e &lt;= n; e++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[e] &gt; eps) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(e == n + <span class="number">1</span>) <span class="keyword">return</span> v;</span><br><span class="line">      <span class="keyword">double</span> mn = inf;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][e] &gt; eps &amp;&amp; mn &gt; b[i] / a[i][e]) &#123;</span><br><span class="line">          mn = b[i] / a[i][e];</span><br><span class="line">          l = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(mn == inf) <span class="keyword">return</span> inf;</span><br><span class="line">      pivot(l, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxm], f[maxm], c[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="comment">// freopen("out", "w", stdout);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    Simplex::n = n, Simplex::m = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">      Simplex::c[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s[i],&amp;f[i],&amp;c[i]);</span><br><span class="line">      Simplex::b[i] = c[i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = s[i]; j &lt;= f[i]; j++) &#123;</span><br><span class="line">        Simplex::a[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(Simplex::simplex()+<span class="number">0.5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1061&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.lydsy.com/JudgeOnline/problem.php?id=1061&lt;/a&gt;&lt;br&gt;申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要N 天才能完成，其中第i 天至少需要Ai 个人。 布布通过了解得知，一共有M 类志愿者可以招募。其中第i 类可以从第Si 天工作到第Ti天，招募费用是每人Ci 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="单纯形法" scheme="https://vincentxwd.github.io/blog/tags/%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95/"/>
    
      <category term="线性规划" scheme="https://vincentxwd.github.io/blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder308E] tokitsukaze and Similar String (字符串哈希, 打表)</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/07/nowcoder308e/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/07/nowcoder308e/</id>
    <published>2018-12-07T15:42:49.000Z</published>
    <updated>2018-12-07T15:51:18.477Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/308/e" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/308/e</a></p><p>tokitsukaze获得了一个长度为n，由a-z小写字母组成的字符串。<br>我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。<br>操作是这样的：选择一个字符串，把字符串的每个字母都替换为字母表上的下一个字母，同时，我们认为z的下一个字母为a，比如选择”acdz”，操作一次后变为”bdea”。<br>现在tokitsukaze从字符串中任取两个子串，她想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。</p><a id="more"></a><hr><p>字符串哈希，好久没见到了。<br>这题可以预处理出变换26次的所有串，我们希望快速查询子串，于是想到用字符串哈希。<br>对于字符串$s$，我们预处理$hash[i]$为$s[1]\to s[i]$这个字符串前缀的哈希值，可以这样求：<br>$$<br>hash[i]=hash[i-1]*M+s[i]<br>$$<br>于是我们希望知道$s[i]\to s[j]$的哈希值，就可以：<br>$$<br>hash[j]-hash[i-1]\times M^{j-i+1}<br>$$<br>不用管hash的具体值，任其自然溢出就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ULL = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ULL m1 = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line">ULL vis[<span class="number">27</span>][maxn];</span><br><span class="line">ULL mul[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mul[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">    mul[i] = mul[i<span class="number">-1</span>] * m1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">int</span> x, y, len;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(t+<span class="number">1</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        vis[i][j] = vis[i][j<span class="number">-1</span>] * m1 + t[j] - <span class="string">'a'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        t[j] = <span class="string">'a'</span> + ((t[j] - <span class="string">'a'</span> + <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;len);</span><br><span class="line">      <span class="keyword">if</span>(x + len - <span class="number">1</span> &gt; n || y + len - <span class="number">1</span> &gt; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> ret = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[<span class="number">0</span>][x+len<span class="number">-1</span>]-vis[<span class="number">0</span>][x<span class="number">-1</span>]*mul[len] == vis[i][y+len<span class="number">-1</span>]-vis[i][y<span class="number">-1</span>]*mul[len]) &#123;</span><br><span class="line">          ret = min(ret, min(i, <span class="number">26</span>-i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret==<span class="number">0x7f7f7f7f</span>?<span class="number">-1</span>:ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>供复习使用：<a href="https://blog.csdn.net/richard_for_oi/article/details/79306985" target="_blank" rel="noopener">https://blog.csdn.net/richard_for_oi/article/details/79306985</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/308/e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/308/e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;tokitsukaze获得了一个长度为n，由a-z小写字母组成的字符串。&lt;br&gt;我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。&lt;br&gt;操作是这样的：选择一个字符串，把字符串的每个字母都替换为字母表上的下一个字母，同时，我们认为z的下一个字母为a，比如选择”acdz”，操作一次后变为”bdea”。&lt;br&gt;现在tokitsukaze从字符串中任取两个子串，她想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="字符串" scheme="https://vincentxwd.github.io/blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希" scheme="https://vincentxwd.github.io/blog/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="打表" scheme="https://vincentxwd.github.io/blog/tags/%E6%89%93%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder315E] 勇敢的妞妞 (思维，状压，记忆化搜索)</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/06/nowcoder315e/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/06/nowcoder315e/</id>
    <published>2018-12-06T13:15:55.000Z</published>
    <updated>2018-12-06T13:26:51.923Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/315/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/315/E</a></p><p>美丽的牛家庄受到了外星人的侵略, 勇敢的妞妞要上战场抵御侵略。</p><p>在妞妞上战场前, 村长牛牛给了妞妞N件装备, 妞妞需要选择其中的K件,装备在身上提升自己的战斗力。每件装备有5种属性增幅值,对于第i件装备它的属性增幅值为(ri1, ri2, ri3, ri4, ri5), 分别代表该装备对不同的属性值增幅。</p><p>当妞妞装备多件装备的时候,由于装备之前会互相影响, 对于每种属性值的增幅并不是所有装备该属性值之和, 而是该种属性值下所有装备中最大的属性值。而妞妞最终增加的战斗力为这5种属性值增幅之和。</p><p>妞妞一定要保卫牛家庄, 所以她希望她能提升尽可能多的战斗力, 请你帮帮她计算她最多能增加多少战斗力。</p><a id="more"></a><p>首先能想到的是当$K\geq 5$时，只要在N件装备里选出5种属性中分别的最大值即可。</p><p>由于只有5种属性，我们可以关心每件装备对不同属性组合的贡献，于是可以状态压缩，比如我只关心第1、3属性的装备谁最大，那么这个状态就是$(10100)_2$，我们记录每种状态下都是哪个装备能提供最大幅度的增长，维护这个数组$hi$.</p><p>接下来希望尝试不同子状态的组合，比如$(10100)_2$和$(01001)_2$可以组合成$(11101)_2$，那么他们对答案的贡献就是$hi(10100_2)+hi(01001_2)$。所以我们直接先写个爆搜。</p><p>发现这个爆搜的状态重复了，于是记忆化一下就可以剪掉一部分搜索分支了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, ret;</span><br><span class="line"><span class="keyword">int</span> hi[<span class="number">1</span>&lt;&lt;<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> r[maxn][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">6</span>][<span class="number">1</span>&lt;&lt;<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">int</span> done, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(~dp[cnt][done]) <span class="keyword">return</span> dp[cnt][done];</span><br><span class="line">  <span class="keyword">if</span>(cnt == k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>((i &amp; done)) <span class="keyword">continue</span>;</span><br><span class="line">    ret = max(ret, dfs(cnt+<span class="number">1</span>, done|i, i+<span class="number">1</span>) + hi[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[cnt][done] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;r[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="built_in">memset</span>(hi, <span class="number">0</span>, <span class="keyword">sizeof</span> hi);</span><br><span class="line">    <span class="keyword">if</span>(k &gt; <span class="number">5</span>) k = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> st = <span class="number">0</span>; st &lt; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); st++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(st &amp; (<span class="number">1</span> &lt;&lt; j)) tmp += r[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        hi[st] = max(hi[st], tmp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/315/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/315/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;美丽的牛家庄受到了外星人的侵略, 勇敢的妞妞要上战场抵御侵略。&lt;/p&gt;
&lt;p&gt;在妞妞上战场前, 村长牛牛给了妞妞N件装备, 妞妞需要选择其中的K件,装备在身上提升自己的战斗力。每件装备有5种属性增幅值,对于第i件装备它的属性增幅值为(ri1, ri2, ri3, ri4, ri5), 分别代表该装备对不同的属性值增幅。&lt;/p&gt;
&lt;p&gt;当妞妞装备多件装备的时候,由于装备之前会互相影响, 对于每种属性值的增幅并不是所有装备该属性值之和, 而是该种属性值下所有装备中最大的属性值。而妞妞最终增加的战斗力为这5种属性值增幅之和。&lt;/p&gt;
&lt;p&gt;妞妞一定要保卫牛家庄, 所以她希望她能提升尽可能多的战斗力, 请你帮帮她计算她最多能增加多少战斗力。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="思维" scheme="https://vincentxwd.github.io/blog/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="状压" scheme="https://vincentxwd.github.io/blog/tags/%E7%8A%B6%E5%8E%8B/"/>
    
      <category term="记忆化搜索" scheme="https://vincentxwd.github.io/blog/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder272D] Where are you (最小生成树，缩点，割边)</title>
    <link href="https://vincentxwd.github.io/blog/2018/12/03/nowcoder272d/"/>
    <id>https://vincentxwd.github.io/blog/2018/12/03/nowcoder272d/</id>
    <published>2018-12-03T09:52:01.000Z</published>
    <updated>2018-12-03T11:24:14.472Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/272/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/272/D</a></p><p>求无向图中必然在最小生成树上出现的边的条数。<br><a id="more"></a></p><p>根据最小生成树的构造方法可以知道，当最小生成树不唯一时，可以用某一条边替换树上相同权值的边。<br>考虑kruskal算法，我们按照相同的边进行分组，每次处理一个组，并把这组边加到之前已经处理好的连通块上后跑tarjan求桥。在这个组里如果有某条边是桥，那么这条边一定是会选中的就可以计数，之后清理一下标记就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">int</span> w;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">202001</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  pre[find(x)] = find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tarjan</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, next;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">  &#125;;</span><br><span class="line">  Edge edge[maxn];</span><br><span class="line">  <span class="keyword">int</span> ecnt, d, Y;</span><br><span class="line">  <span class="keyword">int</span> head[maxn], bridge[maxn];</span><br><span class="line">  <span class="keyword">int</span> low[maxn], dfn[maxn];</span><br><span class="line"></span><br><span class="line">  Tarjan() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(bridge, <span class="number">0</span>, <span class="keyword">sizeof</span> bridge);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    ecnt = <span class="number">0</span>; d = <span class="number">0</span>; Y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[ecnt].u = u, edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].idx = Y;</span><br><span class="line">    edge[ecnt].next = head[u]; head[u] = ecnt++;</span><br><span class="line">    edge[ecnt].u = v, edge[ecnt].v = u;</span><br><span class="line">    edge[ecnt].idx = Y++;</span><br><span class="line">    edge[ecnt].next = head[v]; head[v] = ecnt++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i=edge[i].next) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">      <span class="keyword">int</span> idx = edge[i].idx;</span><br><span class="line">      <span class="keyword">if</span>(p == idx) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">        dfs(v, idx);</span><br><span class="line">        low[u] = min(low[u], low[v]);</span><br><span class="line">        <span class="keyword">if</span>(low[v] == dfn[v]) &#123;</span><br><span class="line">          bridge[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Tarjan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;p)) &#123;</span><br><span class="line">    Tarjan t;</span><br><span class="line">    e.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      e.emplace_back(Edge(&#123;u,v,w&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e.begin(), e.end(), [](Edge a, Edge b) &#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = i;</span><br><span class="line">      <span class="keyword">while</span>(k &lt; m &amp;&amp; e[k].w == e[i].w) k++;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">        u = find(e[j].u), v = find(e[j].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        t.adde(u, v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">        u = find(e[j].u), v = find(e[j].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t.dfn[u]) t.dfs(u, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!t.dfn[v]) t.dfs(v, <span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">        u = find(e[j].u), v = find(e[j].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        t.dfn[u] = t.dfn[v] = <span class="number">0</span>;</span><br><span class="line">        t.low[u] = t.low[v] = <span class="number">0</span>;</span><br><span class="line">        t.head[u] = t.head[v] = <span class="number">-1</span>;</span><br><span class="line">        unite(u, v);</span><br><span class="line">      &#125;</span><br><span class="line">      i = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.ecnt; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(t.bridge[i]) ret++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/272/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/272/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求无向图中必然在最小生成树上出现的边的条数。&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="最小生成树" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="缩点" scheme="https://vincentxwd.github.io/blog/tags/%E7%BC%A9%E7%82%B9/"/>
    
      <category term="割边" scheme="https://vincentxwd.github.io/blog/tags/%E5%89%B2%E8%BE%B9/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder272B] Xor Path(树，异或，计数)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/30/nowcoder272b/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/30/nowcoder272b/</id>
    <published>2018-11-30T14:08:29.000Z</published>
    <updated>2018-12-03T09:52:25.761Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/272/B" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/272/B</a></p><p>给定一棵n个点的树，每个点有权值$A_i$. 定义$path(i,j)$表示$i$到$j$的最短路径上，所有点的点权异或和。对于$i=1\to n-1,j=i+1 \to n$，求所有$path(i,j)$的异或和。</p><a id="more"></a><p>考虑到这个问题只和每个点权的出现次数的奇偶有关系，那么我们可以分情况讨论下每个点在任意两点间的路径中都是如何出现的。</p><ul><li>对于叶子节点，只有n-1次（与其他点直连）。</li><li>对于非叶节点，则有：<ul><li>与其他点直连，出现n-1次。</li><li>这个点的子树中的任意两点进行连接，出现$\sum_{1\leq i&lt;j\leq n} child_i\times child_j$次，其中$child_i$表示第$i$个儿子为根节点的总点数（包括自己）。</li><li>这个点将子树和非子树分成两部分，这两部分互相连接。那么贡献是两部分点数的乘积。</li></ul></li></ul><p>只有一个地方的计算需要优化，那就是$k$个数任意取2个数的乘积之和，维护一个前缀和随便弄一下就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500500</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL w[maxn], son[maxn], cnt[maxn];</span><br><span class="line">LL out[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  son[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum, val;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    son[u] += son[v];</span><br><span class="line">    sum.emplace_back(son[v]);</span><br><span class="line">    val.emplace_back(son[v]);</span><br><span class="line">    tot++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) &#123;</span><br><span class="line">    sum[i] += sum[i<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">    out[u] += ((val[i] * (sum[tot<span class="number">-1</span>] - sum[i]))) % <span class="number">2</span>;</span><br><span class="line">    out[u] %= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">    <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span> son);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt[i] = (n - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">      cnt[i] += ((son[i] - <span class="number">1</span>) * (n - son[i])) % <span class="number">2</span>;</span><br><span class="line">      cnt[i] += out[i] % <span class="number">2</span>;</span><br><span class="line">      cnt[i] %= <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(cnt[i] &amp; <span class="number">1</span>) ret ^= w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/272/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/272/B&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一棵n个点的树，每个点有权值$A_i$. 定义$path(i,j)$表示$i$到$j$的最短路径上，所有点的点权异或和。对于$i=1\to n-1,j=i+1 \to n$，求所有$path(i,j)$的异或和。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="异或" scheme="https://vincentxwd.github.io/blog/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="计数" scheme="https://vincentxwd.github.io/blog/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>[POJ2887] Big String（块状链表）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/29/poj2887/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/29/poj2887/</id>
    <published>2018-11-29T10:34:14.000Z</published>
    <updated>2018-11-29T10:38:43.352Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2887" target="_blank" rel="noopener">http://poj.org/problem?id=2887</a><br><strong>给一个字符串，要求两个操作：</strong><br><strong>I ch p：在这个字符串第p个字符前插入字符ch</strong><br><strong>Q p：查询第p个位置的字符</strong><br><a id="more"></a></p><p>第一次写块状链表，还挺顺利的。。。<br>就是块大小调了几次wa了好几发。。。<br>块状链表比数组分块多了一个操作就是可以用拆分操作来支持插入操作。对于这个题来说就是当某个块中插入元素是块大小的2倍时，我们就可以把这个块拆成2个了。<br>我用的list可能常数可能比较大，但是非常好实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> bsize, len;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; be;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1001000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator p = be.begin(); p != be.end(); p++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;size() &gt;= <span class="number">2</span> * bsize) &#123;</span><br><span class="line">      <span class="built_in">string</span> a = p-&gt;substr(<span class="number">0</span>, bsize);</span><br><span class="line">      <span class="built_in">string</span> b = p-&gt;substr(bsize, p-&gt;length()-bsize);</span><br><span class="line">      <span class="comment">// cout &lt;&lt;*p&lt;&lt;" split: "&lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">      *p = b;</span><br><span class="line">      be.insert(p, a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator p = be.begin(); p != be.end(); p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; tot + p-&gt;size()) &#123;</span><br><span class="line">      tot += p-&gt;size();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos == tot+<span class="number">1</span>) <span class="keyword">return</span> (*p)[i];</span><br><span class="line">      <span class="keyword">else</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">char</span>* tmp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator p = be.begin(); p != be.end(); p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; tot + p-&gt;size()) &#123;</span><br><span class="line">      tot += p-&gt;size();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos -= tot;</span><br><span class="line">    p-&gt;insert(pos, tmp);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  len++;</span><br><span class="line">  maintain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">char</span> cmd[<span class="number">5</span>], tmp[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> pos;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  be.clear();</span><br><span class="line">  bsize = <span class="number">10000</span>;</span><br><span class="line">  be.push_back(s);</span><br><span class="line">  maintain();</span><br><span class="line">  <span class="keyword">int</span> q;</span><br><span class="line">  scan_d(q);</span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">    <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">      scan_d(pos);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, query(pos));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, tmp);</span><br><span class="line">      scan_d(pos);</span><br><span class="line">      pos--;</span><br><span class="line">      <span class="keyword">if</span>(pos &gt;= len) insert(len, tmp);</span><br><span class="line">      <span class="keyword">else</span> insert(pos, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=2887&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://poj.org/problem?id=2887&lt;/a&gt;&lt;br&gt;&lt;strong&gt;给一个字符串，要求两个操作：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;I ch p：在这个字符串第p个字符前插入字符ch&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Q p：查询第p个位置的字符&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/POJ/"/>
    
    
      <category term="分块" scheme="https://vincentxwd.github.io/blog/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="块状链表" scheme="https://vincentxwd.github.io/blog/tags/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1011] Round #499 (Div. 2)（树转RMQ+莫队 or 启发式合并）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/27/cf600E/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/27/cf600E/</id>
    <published>2018-11-27T04:07:15.000Z</published>
    <updated>2018-11-27T04:23:38.065Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/600/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/600/problem/E</a><br><strong>给一棵树，问从根节点开始每个节点的子树（包含这个节点）中的众数的和。</strong></p><a id="more"></a><p>一看到子树上的某种计数我就会非常自然地想到树转RMQ再做一些区间操作，当然这个题也不例外。。。</p><p>于是考虑把这棵树的查询转成区间查询，要查每一个节点的子树，那么就是有$n​$次查询。线段树是解决不了区间众数问题的，于是就想到去分块。但是这题的意思是众数如果出现多次那就要把他们都加起来，所以我们<strong>在维护每个数出现的次数的同时，还要维护每个次数对应的数字之和。</strong>更新的时候注意加加减减就可以了，还有就是每次更新当前最大次数$ret​$的时候遇到remove要判断一下当前这个出现次数是否已经没有数字了，遇到这种情况的时候，因为每次出现次数都-1，于是我们直接把$ret-1​$就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">using</span> Query = struct &#123; LL l, r, ret, id; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(LL &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v, n, sid, sz;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;LL&gt;&gt; G;</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; c, be, w;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Query&gt; q;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;LL, LL&gt; vis, tot;</span><br><span class="line">  <span class="keyword">while</span>(scan_d(n)) &#123;</span><br><span class="line">    G = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;LL&gt;&gt;(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;LL&gt;(<span class="number">0</span>));</span><br><span class="line">    c = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    w = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    q = <span class="built_in">vector</span>&lt;Query&gt;(n+<span class="number">1</span>);</span><br><span class="line">    sz = LL(<span class="built_in">sqrt</span>(n)); sid = <span class="number">0</span>;</span><br><span class="line">    vis.clear(); tot.clear();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      scan_d(c[i]);</span><br><span class="line">      tot[<span class="number">0</span>] += c[i];</span><br><span class="line">      be.emplace_back(i / sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      scan_d(u);</span><br><span class="line">      scan_d(v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(LL, LL)&gt; dfs = [&amp;](LL u, LL p) &#123;</span><br><span class="line">      q[u].l = ++sid; w[sid] = c[u]; q[u].id = u;</span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        LL&amp; v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">      &#125;</span><br><span class="line">      q[u].r = sid;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    sort(q.begin(), q.end(), [&amp;](Query a, Query b) &#123;</span><br><span class="line">      <span class="keyword">return</span> be[a.l] == be[b.l] ? a.r &lt; b.r : a.l &lt; b.l;</span><br><span class="line">    &#125;);</span><br><span class="line">    function&lt;<span class="keyword">void</span>(LL, LL&amp;)&gt; add = [&amp;](LL x, LL&amp; ret) &#123;</span><br><span class="line">      tot[vis[x]] -= x;</span><br><span class="line">      vis[x]++;</span><br><span class="line">      tot[vis[x]] += x;</span><br><span class="line">      ret = max(ret, vis[x]);</span><br><span class="line">    &#125;;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(LL, LL&amp;)&gt; remove = [&amp;](LL x, LL&amp; ret) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ret == vis[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot[vis[x]] - x == <span class="number">0</span>) &#123;</span><br><span class="line">          ret = vis[x] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      tot[vis[x]] -= x;</span><br><span class="line">      vis[x]--;</span><br><span class="line">      tot[vis[x]] += x;</span><br><span class="line">    &#125;;</span><br><span class="line">    LL L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span>(L &lt; q[i].l) &#123; remove(w[L], ret); L++; &#125;</span><br><span class="line">      <span class="keyword">while</span>(L &gt; q[i].l) &#123; L--; add(w[L], ret); &#125;</span><br><span class="line">      <span class="keyword">while</span>(R &lt; q[i].r) &#123; R++; add(w[R], ret); &#125;</span><br><span class="line">      <span class="keyword">while</span>(R &gt; q[i].r) &#123; remove(w[R], ret); R--; &#125;</span><br><span class="line">      <span class="comment">// LL p = 0;</span></span><br><span class="line">      <span class="comment">// printf("(%lld, %lld) : ", q[i].l,q[i].r);</span></span><br><span class="line">      <span class="comment">// for(auto x : vis) &#123;</span></span><br><span class="line">      <span class="comment">//   printf("%lld %lld, ", x.first, x.second);</span></span><br><span class="line">      <span class="comment">//   p = max(p, x.second);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// printf("\n");</span></span><br><span class="line">      <span class="comment">// for(auto x : vis) &#123;</span></span><br><span class="line">      <span class="comment">//   if(x.second == p) q[i].ret += x.first;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// cout &lt;&lt; p &lt;&lt; " " &lt;&lt; ret &lt;&lt; endl;</span></span><br><span class="line">      q[i].ret = tot[ret];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q.begin(), q.end(), [=](Query a, Query b)&#123;</span><br><span class="line">      <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, q[i].ret, <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题其实就是想教大家<strong>在维护每个数出现的次数的同时，还要维护每个次数对应的数字之和。</strong>我们冷静分析以后，发现这个题可以直接DFS。</p><p>我们希望在每次DFS的时候把子树中的数字出现情况merge到当前这个父亲上，考虑对每个点维护上述两个数组，每次把小的树更新到大的树上，merge的具体操作跟上述莫队的更新一样。</p><p>如何保证小集合merge到大集合上的复杂度？</p><p>Tutorial是这么解释的：“every time when vertex <em>v</em> will be moved from one <em>map</em> to another the size of the new map will be at least two times larger. So each vertex can be moved not over than $\log n$ times.”</p><p>发现merge的时候大集合至少是小集合的2倍，实际上就是说每次每个集合被遍历的次数都会减半，相当于最坏情况下每个点被遍历$\log n$次，于是merge的复杂度就是$n\log n $. 整体复杂度就是$O(n\log^2 n)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">100100</span>;</span><br><span class="line">LL n, c[maxn], id[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; G[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; cnt[maxn], tot[maxn];</span><br><span class="line">LL ret[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(LL u, LL v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cnt[id[u]].size() &lt; cnt[id[v]].size()) swap(id[u], id[v]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt[id[v]]) &#123;</span><br><span class="line">    tot[id[u]][cnt[id[u]][x.first]] -=  x.first;</span><br><span class="line">    cnt[id[u]][x.first] += x.second;</span><br><span class="line">    tot[id[u]][cnt[id[u]][x.first]] +=  x.first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LL u, LL p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">    LL&amp; v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    gao(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  ret[u] = tot[id[u]].rbegin()-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt[i].clear();</span><br><span class="line">      tot[i].clear();</span><br><span class="line">      G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;c[i]);</span><br><span class="line">      id[i] = i;</span><br><span class="line">      cnt[i][c[i]] = <span class="number">1</span>;</span><br><span class="line">      tot[i][<span class="number">1</span>] = c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%I64d%c"</span>, ret[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/600/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/600/problem/E&lt;/a&gt;&lt;br&gt;&lt;strong&gt;给一棵树，问从根节点开始每个节点的子树（包含这个节点）中的众数的和。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="莫队算法" scheme="https://vincentxwd.github.io/blog/tags/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="离线" scheme="https://vincentxwd.github.io/blog/tags/%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="树转RMQ" scheme="https://vincentxwd.github.io/blog/tags/%E6%A0%91%E8%BD%ACRMQ/"/>
    
      <category term="启发式合并" scheme="https://vincentxwd.github.io/blog/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder283J] RMQ (线段树)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/25/nowcoder283j/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/25/nowcoder283j/</id>
    <published>2018-11-25T13:21:25.000Z</published>
    <updated>2018-11-25T13:35:12.940Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/283/J" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/283/J</a></p><p>小姐姐想要一种数据结构，支持如下操作： </p><p>  对于一个整数数组：     </p><p>  \1. 给定L和R，输出[L,R]中元素的和 </p><p>  \2. 给定L，R和X，将[L,R]中每个元素与X进行按位或运算 </p><p>  \3. 数组索引从1开始 </p><p>  按位或在C\C++、Java、Python中为’|’运算符</p><a id="more"></a><p>难点在于如何处理或操作。</p><p>做过异或线段树的题，这个或自然会想到拆位处理，针对每一位建一棵线段树，如果或的数字的某一位为1时，则这一位（假设是第$i$位）在区间$[l,r]$对于答案（sum）的贡献为$2^i\times(r-l+1)$.</p><p>认真写一下lazy标记的处理就好，蛮好写。注意线段树$sum[rt][i]$的顺序，惨遭卡常。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">2</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> add[maxn&lt;&lt;<span class="number">2</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUP</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  sum[rt][i] = sum[rt&lt;&lt;<span class="number">1</span>][i] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDOWN</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(add[rt][i]) &#123;</span><br><span class="line">    add[rt&lt;&lt;<span class="number">1</span>][i] |= add[rt][i];</span><br><span class="line">    add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i] |= add[rt][i];</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sum[rt&lt;&lt;<span class="number">1</span>][i] = m - l + <span class="number">1</span>;</span><br><span class="line">    sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i] = r - m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[l]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[l] &amp; <span class="number">1</span>) sum[rt][i] = <span class="number">1</span>;</span><br><span class="line">      i++;</span><br><span class="line">      a[l] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(lson);</span><br><span class="line">  build(rson);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    sum[rt][i] = sum[rt&lt;&lt;<span class="number">1</span>][i] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    add[rt][i] = <span class="number">1</span>;</span><br><span class="line">    sum[rt][i] = (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pushDOWN(rt, l, r, i);</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= m) update(L, R, c, lson, i);</span><br><span class="line">  <span class="keyword">if</span>(R &gt; m) update(L, R, c, rson, i);</span><br><span class="line">  pushUP(rt, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1L</span>L &lt;&lt; i) * sum[rt][i];</span><br><span class="line">  &#125;</span><br><span class="line">  pushDOWN(rt, l, r, i);</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= m) </span><br><span class="line">    ret += query(L, R, lson, i);</span><br><span class="line">  <span class="keyword">if</span>(m &lt; R) </span><br><span class="line">    ret += query(L, R, rson, i);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> a, b, c;</span><br><span class="line">  <span class="keyword">char</span> cmd[<span class="number">5</span>];</span><br><span class="line">  scan_d(n);</span><br><span class="line">  scan_d(q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    scan_d(::a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">    <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">'S'</span>) &#123;</span><br><span class="line">      scan_d(a);</span><br><span class="line">      scan_d(b);</span><br><span class="line">      LL ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        ret += query(a, b, <span class="number">1</span>, n, <span class="number">1</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      scan_d(a); scan_d(b); scan_d(c);</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c &amp; <span class="number">1</span>) update(a, b, <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i);</span><br><span class="line">        i++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/283/J&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/283/J&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小姐姐想要一种数据结构，支持如下操作： &lt;/p&gt;
&lt;p&gt;  对于一个整数数组：     &lt;/p&gt;
&lt;p&gt;  \1. 给定L和R，输出[L,R]中元素的和 &lt;/p&gt;
&lt;p&gt;  \2. 给定L，R和X，将[L,R]中每个元素与X进行按位或运算 &lt;/p&gt;
&lt;p&gt;  \3. 数组索引从1开始 &lt;/p&gt;
&lt;p&gt;  按位或在C\C++、Java、Python中为’|’运算符&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="线段树" scheme="https://vincentxwd.github.io/blog/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder283F] 出装方案 (状压DP or 费用流)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/25/nowcoder283f/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/25/nowcoder283f/</id>
    <published>2018-11-25T13:21:25.000Z</published>
    <updated>2018-11-25T13:25:52.022Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/283/F" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/283/F</a></p><p>众所周知，在各种对抗类游戏里装备都是很重要的一环，不同的出装方案会给玩家带来不同的强度。 </p><p>  dalao手里有N件装备，现在dalao要把装备分给N个队友，每个队友只能分一件装备，而每个队友穿上不同的装备会有不同程度的强度提升。  </p><p>  现在给出每个队友对每件装备的强度提升的值，请问dalao的所有分配方案里，<strong>最多</strong>能让团队的<strong>总</strong>强度提升多少呢？</p><a id="more"></a><p>这题可以DP也可以费用流。</p><p>DP可以维护$f(i,st)$表示处理到前$i$个人，并且当前已经拿了$st$个装备时的最佳方案，转移就从$st$中未标记的转移就可以。由于只和上一层的状态有关，因此存储空间可以压下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      f[<span class="number">0</span>][<span class="number">1</span>&lt;&lt;i] = a[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> st = <span class="number">1</span>; st &lt; nn; st++) &#123;</span><br><span class="line">          <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; j) &amp; st) <span class="keyword">continue</span>;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][st|(<span class="number">1</span>&lt;&lt;j)] = max(f[i&amp;<span class="number">1</span>][st|(<span class="number">1</span>&lt;&lt;j)], f[!(i&amp;<span class="number">1</span>)][st]+a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[(n<span class="number">-1</span>)&amp;<span class="number">1</span>][nn<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>费用流也十分好想，一边是装备一边是人，超级源连装备费用为0容量为1，人连超级汇费用为0容量为1，内部装备的费用为装备提升的相反数容量为1，跑最大费用最大流即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, next;</span><br><span class="line">  LL c, w;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">0x3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">const</span> LL inf = (<span class="number">1L</span>L&lt;&lt;<span class="number">55</span>);</span><br><span class="line"><span class="keyword">int</span> tot, head[maxn];</span><br><span class="line">LL dist[maxn];</span><br><span class="line">LL cost, flow;</span><br><span class="line">Node e[maxm];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> S, T, N;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S = T = N = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c:容量, w:费用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL c, LL w)</span> </span>&#123;</span><br><span class="line">  e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">  e[tot].u = v; e[tot].v = u; e[tot].c = <span class="number">0</span>; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dist[i] = inf;</span><br><span class="line">    visit[i] = <span class="number">0</span>;</span><br><span class="line">    pre[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">  Q.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  pre[s] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q.front();</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(e[j].c &gt; <span class="number">0</span> &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123;</span><br><span class="line">        dist[e[j].v] = dist[u] + e[j].w;</span><br><span class="line">        pre[e[j].v] = j;</span><br><span class="line">        <span class="keyword">if</span>(!visit[e[j].v]) &#123;</span><br><span class="line">          Q.push(e[j].v);</span><br><span class="line">          visit[e[j].v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return dist[t] &lt; 0; // 求可行流</span></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 求最小费用流</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ChangeFlow</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  LL det = mod;</span><br><span class="line">  <span class="keyword">int</span> u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    det = min(det, e[u].c);</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    e[u].c -= det;</span><br><span class="line">    e[u ^ <span class="number">1</span>].c += det;</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> det;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">MinCostFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  LL mincost, maxflow;</span><br><span class="line">  mincost = maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(spfa(s, t, n)) &#123;</span><br><span class="line">    LL det = ChangeFlow(t);</span><br><span class="line">    mincost += det * dist[t];</span><br><span class="line">    maxflow += det;</span><br><span class="line">  &#125;</span><br><span class="line">  cost = mincost;</span><br><span class="line">  flow = maxflow;</span><br><span class="line">  <span class="keyword">return</span> mincost;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> to[maxn][maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T_T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T_T);</span><br><span class="line">  <span class="keyword">while</span>(T_T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    init();</span><br><span class="line">    S = <span class="number">0</span>, T = <span class="number">2</span> * n + <span class="number">1</span>, N = T + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      adde(S, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      adde(n+i, T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;to[i][j]);</span><br><span class="line">        adde(i,n+j, <span class="number">1</span>, -to[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, -MinCostFlow(S, T, N));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/283/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/283/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;众所周知，在各种对抗类游戏里装备都是很重要的一环，不同的出装方案会给玩家带来不同的强度。 &lt;/p&gt;
&lt;p&gt;  dalao手里有N件装备，现在dalao要把装备分给N个队友，每个队友只能分一件装备，而每个队友穿上不同的装备会有不同程度的强度提升。  &lt;/p&gt;
&lt;p&gt;  现在给出每个队友对每件装备的强度提升的值，请问dalao的所有分配方案里，&lt;strong&gt;最多&lt;/strong&gt;能让团队的&lt;strong&gt;总&lt;/strong&gt;强度提升多少呢？&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="费用流" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="状压DP" scheme="https://vincentxwd.github.io/blog/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder283H] 图论一顿套模版 (最短路)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/25/nowcoder283h/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/25/nowcoder283h/</id>
    <published>2018-11-25T13:21:25.000Z</published>
    <updated>2018-11-25T13:31:46.700Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/283/H" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/283/H</a></p><p>有N栋楼和M条道路<strong>（单向）</strong>，每条路都有“不整洁度”W，现在校方想知道从S楼到T楼的所有路径中，“不整洁度”<strong>乘积最小</strong>是多少。 由于答案可能很大，所以你需要将最后的答案对10E9+7取模。</p><a id="more"></a><p>因为权值会很大，所以直接拿乘积算最短路是不可以的，因为取模后数值大小无法比较。</p><p>需要注意的是，题目保证每一个权都是2的幂，虽然我没注意。。</p><p>于是我维护了权值的每一位，计算的时候只管它们最终都是2的多少次幂。</p><p>于是可以堆优化最短路，在堆里维护2的幂次，这样就能保证一个大小顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  LL v, w, next;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">50050</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxm = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">1E18</span>;</span><br><span class="line">LL n, m, ee, s, t;</span><br><span class="line">LL d[maxn][<span class="number">64</span>];</span><br><span class="line">LL head[maxn];</span><br><span class="line">Edge e[maxm];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;PLL, <span class="built_in">vector</span>&lt;PLL&gt;, greater&lt;PLL&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; n; x=(x*x)%mod,n&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = (ret * x) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ee = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(LL u, LL v, LL w)</span> </span>&#123;</span><br><span class="line">  e[ee].v = v; e[ee].w = w; e[ee].next = head[u]; head[u] = ee++;</span><br><span class="line">  <span class="comment">// e[ee].v = u; e[ee].w = w; e[ee].next = head[v]; head[v] = ee++;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL v, LL u, LL w=<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  LL a = <span class="number">0</span>, b = <span class="built_in">ceil</span>(<span class="built_in">log</span>(w)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">    a += d[v][i] * i;</span><br><span class="line">    b += d[u][i] * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get</span><span class="params">(LL u)</span> </span>&#123;</span><br><span class="line">  LL a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">    a += d[u][i] * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(LL &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v;</span><br><span class="line">  LL w;</span><br><span class="line">  <span class="keyword">while</span>(scan_d(n)) &#123;</span><br><span class="line">    scan_d(m);</span><br><span class="line">    scan_d(s);</span><br><span class="line">    scan_d(t);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) d[i][j] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      scan_d(u);</span><br><span class="line">      scan_d(v);</span><br><span class="line">      scan_d(w);</span><br><span class="line">      adde(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">      d[s][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.push(PLL(get(s), s));</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">      PLL tmp = pq.top(); pq.pop();</span><br><span class="line">      LL pw = tmp.first, u = tmp.second;</span><br><span class="line">      <span class="keyword">if</span>(get(u) &lt; pw) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(LL i = head[u]; ~i; i=e[i].next) &#123;</span><br><span class="line">        LL v = e[i].v; LL w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(check(v, u, w)) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">            d[v][j] = d[u][j];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> cur = <span class="built_in">ceil</span>(<span class="built_in">log</span>(w)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">          d[v][cur]++;</span><br><span class="line">          pq.push(PLL(get(v), v));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[t][<span class="number">0</span>] == inf) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(d[t][i]) &#123;</span><br><span class="line">        ret *= mul(<span class="number">2L</span>L,(i*d[t][i])%mod) % mod;</span><br><span class="line">        ret %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/283/H&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/283/H&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有N栋楼和M条道路&lt;strong&gt;（单向）&lt;/strong&gt;，每条路都有“不整洁度”W，现在校方想知道从S楼到T楼的所有路径中，“不整洁度”&lt;strong&gt;乘积最小&lt;/strong&gt;是多少。 由于答案可能很大，所以你需要将最后的答案对10E9+7取模。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="最短路" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] EM算法</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/21/em/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/21/em/</id>
    <published>2018-11-21T10:17:33.000Z</published>
    <updated>2018-11-21T14:31:36.489Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）中EM算法部分的笔记，书上总结得很精炼，有很多细枝末节的东西需要填充。</p><p>PDF版：<a href="http://pcoln8jiu.bkt.clouddn.com/em.pdf" target="_blank" rel="noopener">http://pcoln8jiu.bkt.clouddn.com/em.pdf</a></p><a id="more"></a><hr><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>书中将EM算法总结为估计参数隐变量的方法，它是一种迭代式算法：</p><p>若参数$\Theta$已知，则根据训练数据$D$推断出最优隐变量$Z$；若$Z$的值已知，则可对$\Theta$求极大似然估计。</p><p>步骤简单地可以总结为下面两步：<br>E步：利用当前估计的参数值$\Theta$计算对数似然的期望。</p><p>M步：寻找可以使E步产生的似然期望最大的$\Theta$。</p><p>上面两个步骤交替执行，直至收敛。</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>强烈建议观看徐亦达教授的EM算法视频：<a href="https://www.bilibili.com/video/av23901379" target="_blank" rel="noopener">https://www.bilibili.com/video/av23901379</a></strong></p><p>这部分之前写的不是很清楚，于是我决定重新看一下徐老师的视频和PPT，认真把EM算法框架推导和证明过一遍，再推导出高斯混合模型带入框架中的具体形式。</p><hr><p>EM算法是一个非常好的解决计算困难问题的思路，巧妙地引入隐变量（latent variables）避开一些复杂计算。首先从高斯混合模型引入问题：</p><h2 id="高斯混合模型（Gaussian-Mixture-Model-GMM）"><a href="#高斯混合模型（Gaussian-Mixture-Model-GMM）" class="headerlink" title="高斯混合模型（Gaussian Mixture Model, GMM）"></a>高斯混合模型（Gaussian Mixture Model, GMM）</h2><p>基于贝叶斯估计通常首先假设数据中的特征之间独立同分布。我们遇到数据集的分布无法仅用一个Gaussian Distribution拟合时通常考虑使用混合模型，Gaussian mixture model就是将多个高斯模型加权求和达到对拟合数据的目的。使用GMM描述一个数据集的分布可以表示成：<br>$$<br>p(X)=\sum_{i=1}^k\alpha_iN(X|\mu_i,\Sigma_i)<br>$$</p><p>$$<br>\sum\alpha_i=1<br>$$</p><p>$k$为高斯分布个数，$\Theta$表示高斯混合模型，$\alpha$为每个高斯分布的权，$N$表示一个高斯分布的概率值，定义为$f(x;\theta_i)$，是参数为$\theta_i$的高斯分布概率密度函数$\dfrac{1}{\sqrt{2\pi}\Sigma_i}exp(-\dfrac{(x-\mu_i)^2}{2\Sigma_i^2})$。$\mu、\Sigma$分别为每个高斯分布的参数。</p><p>对于整个GMM $\Theta$，我们需要确定的参数有$2k-1$个，即$\mu_1,…,\mu_k,\Sigma_1,…,\Sigma_k,\alpha_1,…,\alpha_{k-1}$.</p><p>插一句关于$\alpha_i$的来历：因为数据分布（或者说宽度）并不一定非常平均，我随便搜了一张图来解释一下：</p><p><img src="http://f.hiphotos.baidu.com/zhidao/wh%3D450%2C600/sign=4e7ea7a347a98226b8942323bfb29537/314e251f95cad1c8023cd9f17b3e6709c83d5164.jpg" alt="img"></p><p>比如这个图，很明显两个高斯分布比例不一样，因此用权重更合适。</p><p>我思考为什么权值和是1，参考了问答[1]：因为GMM的定义本质上是一个概率密度函数，概率密度函数在负无穷到正无穷内的积分为1，因此我们首先要满足概率密度函数的性质。</p><p>我们希望GMM更好地拟合数据集，也就是希望$p(x)$尽可能地大，于是通常利用对数似然估计对高斯混合模型进行调参，使得拟合特定的数据集。</p><p>这里再插一句：为什么不用一般的极大似然估计(MAP)？</p><p>这是我和师兄同学在饭桌上讨论过的一个问题，总结一下，原因有两条：</p><ol><li>因为极大似然估计是把所有概率乘在一起，每个概率值都是小数，数据量大了小数位精度会丢得非常厉害。</li><li>将连乘换成对数和的形式，求导方便。</li></ol><p>针对高斯混合模型，我们构造损失函数$L(\Theta)$：<br>$$<br>L(\Theta|X)=\sum_{i=1}^n \log p(X)<br>$$<br>即：<br>$$<br>L(\Theta|X)=\sum_{i=1}^n \log \sum_{j=1}^k\alpha_jN(x_i|\mu_j,\Sigma_j)<br>$$<br>于是我们的优化目标就是：<br>$$<br>\Theta^{MLE}=\mathop{argmax}_\Theta L(\Theta|X)<br>$$<br>虽然上式可导，但是无法一步到位，计算过程过于复杂。</p><p>考虑是不是可以有一个迭代的方法，求得$\Theta^{(1)},\Theta^{(2)},…,\Theta^{(t)}$，使得我们最后收敛？</p><hr><p>这是推导EM需要的前置知识，摆在这里。</p><h2 id="Jensen不等式-2"><a href="#Jensen不等式-2" class="headerlink" title="Jensen不等式[2]"></a>Jensen不等式[2]</h2><p>设$f$是定义域为实数的函数，如果对于所有的实数$x$，$f(x)$的二次导数大于等于0，那么$f是$凸函数。当$x$是向量时，如果其Hessian矩阵H是半正定的，那么$f$是凸函数。如果只大于0，不等于0，那么称$f$是严格凸函数。</p><p>Jensen不等式表述如下：</p><p>如果f是凸函数，$X$是随机变量，那么：$E[f(X)]\geq f(E[X])$，特别地，如果$f$是严格凸函数，当且仅当$X$是常量时，上式取等号。</p><p><img src="http://img.my.csdn.net/uploads/201301/24/1359004230_7889.jpg" alt="img"></p><p>图中，实线$f$是凸函数，$X$是随机变量，有0.5的概率是$a$，有0.5的概率是$b$。$X$的期望值就是$a$和$b$的中值了，图中可以看到$E[f(X)]\geq f(E[X])$成立。</p><p><strong>顺便，中国数学界关于函数凹凸性定义和国外很多定义是反的。国内教材中的凹凸，是指曲线，而不是指函数，图像的凹凸与直观感受一致，却与函数的凹凸性相反[3].</strong></p><hr><h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><p>直接给出EM算法需要迭代解决的基本任务：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}_\Theta\int_z \log p(X,z|\Theta)p(z|X,\Theta^{(t)}) \mathop{dz}<br>$$<br>当然这是最普遍的定义，如果放在离散问题上，那么$z$的数量是有限的于是可以写成：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}<em>\Theta\sum</em>{i=1}^k\log p(X,z_i|\Theta)p(z_i|X,\Theta^{(t)})<br>$$<br><strong>接下来会一步一步地推出上面这个迭代式。</strong></p><p>我再摆一下原来的优化目标：<br>$$<br>\Theta^{MLE}=\mathop{argmax}<em>\Theta\log \sum</em>{j=1}^k\alpha_jN(X|\mu_j,\Sigma_j)<br>$$<br>我们发现有2个不一样的地方：</p><ol><li>怎么多了个变量$z$？</li><li>这个$\sum$怎么跑$\log$左边去了？</li></ol><h5 id="怎么多了个变量？这对原目标不会有影响么？"><a href="#怎么多了个变量？这对原目标不会有影响么？" class="headerlink" title="怎么多了个变量？这对原目标不会有影响么？"></a>怎么多了个变量？这对原目标不会有影响么？</h5><p>首先，其实$z$是辅助变量，称为隐变量（latent variable），引入这个东西是EM算法的一个亮点。我记得在数据挖掘课上徐君老师点评SVM算法，说这是一个典型的“看似化简为繁”的工作，但是有了这一步，后面的计算往往会更加简便。</p><p>这和EM算法异曲同工，EM算法的提出者也看得很远，他对需要优化的损失函数引入辅助变量，而且必须保证加和不加的分布相同（保证加了$z$之后的边缘分布与原分布一致），也就是说，给出数据的概率分布，必须保证有：<br>$$<br>p(X)=\sum_{i=1}^kp(X|\Theta,z_i)p(\Theta,z_i)<br>$$<br>$p(X|\Theta,z_i)$表示对数据判断的似然（对应GMM中的概率密度函数$N$）</p><p>$p(\Theta,z_i)$表示先验（对应GMM中的权重$\alpha_i$）</p><p>我们这么定义，因此合适的$p$都不会有影响。</p><h5 id="这个-sum-怎么跑-log-左边去了？"><a href="#这个-sum-怎么跑-log-左边去了？" class="headerlink" title="这个$\sum$怎么跑$\log$左边去了？"></a>这个$\sum$怎么跑$\log$左边去了？</h5><p>保留这个问题，首先分析我们的优化目标。由于是迭代的，那么最基本的要求就是我们每次迭代都要使当前结果更加接近最终结果，也就是：<br>$$<br>\log p(X|\Theta^{(t+1)})\geq \log p(X|\Theta^{(t)})<br>$$<br>我们的目标是推出这样一个式子，此时已经没有隐变量$z$了。我们希望通过优化目标下式来得到上式的结果：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}<em>\Theta\sum</em>{i=1}^k\log p(X,z_i|\Theta)p(z_i|X,\Theta^{(t)})<br>$$<br>这个假设非常大胆，我们很轻易地发现这里其实蕴含了一个矛盾，我们定义$\Theta$是最终的优化结果，而$\Theta^{(t)}$却是当前步的最优目标，我们在计算过程中实际上并不知道$\Theta$，这完全是个Chicken and eggs problem。</p><p>如何处理并不是很显然，我们尝试推一下。首先知道：<br>$$<br>p(X)=\dfrac{p(X)p(XZ)}{p(XZ)}=\dfrac{p(XZ)}{p(Z|X)}<br>$$<br>于是：<br>$$<br>\log p(X|\Theta)=\log \dfrac{p(XZ|\Theta)}{p(Z|X\Theta)}= \log p(XZ|\Theta)-\log p(Z|X\Theta)<br>$$<br>那么它们在$Z$下的期望也一定相等，即：<br>$$<br>E_{p(Z|X\Theta^{(t)})}[\log p(X|\Theta)]= E_{p(Z|X\Theta^{(t)})}[\log p(XZ|\Theta)-\log p(Z|X\Theta)]<br>$$<br>等式左边展开期望的定义：<br>$$<br>E_{p(Z|X\Theta^{(t)})}[\log p(X|\Theta)]=\int_Z[\log p(X|\Theta)]p(z|X\Theta^{(t)})dz<br>$$</p><p>$$<br>=\log p(X|\Theta)\int_zp(z|X\Theta^{(t)})dz<br>$$</p><p>$$<br>=\log p(X|\Theta)<br>$$</p><p>等式右边，由期望可加性拆成两项差，期望定义展开：<br>$$<br>=\int_Z\log p(XZ|\Theta)p(z|X\Theta^{(t)})dz-\int_Z\log p(Z|X\Theta)p(z|X\Theta^{(t)})dz<br>$$<br><strong>这是整个EM算法里最tricky的部分（其次是引入latent variable）</strong>，仔细观察就会发现EM算法迭代优化的只是前面那个积分$\int_Z\log p(XZ|\Theta)p(Z|X\Theta^{(t)})dz$，所以接下来就是消掉后面这个积分，这个被消掉的过程是有点厉害的。。</p><p>前半部分定义给个记号：$Q(\Theta,\Theta^{(t)})$，后半部分定义为：$H(\Theta,\Theta^{(t)})$.</p><p>重申下我们的目标，希望推出最终优化目标为：<br>$$<br>\mathop{argmax}_{\Theta}[\int_Z\log p(XZ|\Theta)p(z|X\Theta^{(t)})dz]=\Theta^{(t)}<br>$$<br>那么到$t+1$步的时候，$Q$和$H$会变大还是变小？</p><p>讨论$Q$：（因为我们的最终目标就只包含Q，所以Q肯定单调增加啦）显然$Q(\Theta^{(t+1)},\Theta^{(t)})Q&gt;(\Theta,\Theta^{(t)})$.</p><p>讨论H：如果$H(\Theta^{(t)},\Theta^{(t)})\geq H(\Theta^{(t+1)},\Theta^{(t)})$，即$H$是单调递减的话就可以将优化目标的后半部分的积分约掉了，下面证明。</p><h5 id="证明-H-Theta-t-Theta-t-geq-H-Theta-Theta-t"><a href="#证明-H-Theta-t-Theta-t-geq-H-Theta-Theta-t" class="headerlink" title="证明$H(\Theta^{(t)},\Theta^{(t)})\geq H(\Theta,\Theta^{(t)})$"></a>证明$H(\Theta^{(t)},\Theta^{(t)})\geq H(\Theta,\Theta^{(t)})$</h5><p>$$<br>\int_z\log[p(z|X\Theta^{(t)})]p(z|X\Theta^{(t)})dz-\int_z\log[p(Z|X\Theta)]p(z|X\Theta^{(t)})dz<br>$$</p><p>即：<br>$$<br>\int_z\log[\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)}]p(z|X\Theta^{(t)})dz<br>$$<br>希望上式$\geq0$，ummmm…似乎做不下去了。</p><p>冷静分析，上面实际上是个函数的期望$E_Z(log[\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)}])$，里面有个$\log$实在太复杂，能不能把$\log$拿出来，比如写成$\log E(\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)})$.</p><p>我们再仔细考虑，诶？这个分子是$p(z|X\Theta^{(t)})$，跟$Z$下的概率一样嘛。于是保证这个函数的单调性的同时做一下变换：<br>$$<br>E_Z(log[\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)}])=E_Z(-log[\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}])<br>$$<br>我们要把$log$拿出来，于是作者想到了用Jensen不等式$E[f(X)]\geq f(E[X])$，函数的期望≥期望的函数，带进去就OK了：<br>$$<br>E_Z(-log[\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}])\geq -\log E_Z(\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})})<br>$$<br>展开不等式右边：<br>$$<br>-\log E_Z(\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})})=\int_Z \dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}p(z|X\Theta^{(t)})dz=-log(1)=0<br>$$<br>于是：<br>$$<br>E_Z(-log[\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}])\geq -\log E_Z(\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})})=0<br>$$<br>单调减的性质就证出来了。</p><p>所以我们的优化目标就是：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}<em>\Theta\sum</em>{i=1}^k\log p(X,z_i|\Theta)p(z_i|X,\Theta^{(t)})<br>$$<br>（$\sum$竟然跑到$\log$的左边去了）</p><hr><p>Reference：</p><p>徐老师的视频链接：<a href="https://www.bilibili.com/video/av23901379" target="_blank" rel="noopener">https://www.bilibili.com/video/av23901379</a></p><p>[1]. <a href="https://www.quora.com/Why-are-all-of-the-weights-in-Gaussian-mixture-models-supposed-to-be-positive" target="_blank" rel="noopener">https://www.quora.com/Why-are-all-of-the-weights-in-Gaussian-mixture-models-supposed-to-be-positive</a></p><p>[2]. <a href="https://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8537620</a></p><p>[3]. <a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7/4583322?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7/4583322?fr=aladdin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）中EM算法部分的笔记，书上总结得很精炼，有很多细枝末节的东西需要填充。&lt;/p&gt;
&lt;p&gt;PDF版：&lt;a href=&quot;http://pcoln8jiu.bkt.clouddn.com/em.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pcoln8jiu.bkt.clouddn.com/em.pdf&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[GCJKickstart2018RoundH] C. Let Me Count The Ways（容斥）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/18/GCJK2018HC/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/18/GCJK2018HC/</id>
    <published>2018-11-18T12:40:34.000Z</published>
    <updated>2018-11-18T13:12:08.947Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;a=2" target="_blank" rel="noopener">https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;a=2</a></p><p><strong>一共有$2n$个座位排成一排，现在有m对人去坐，每对人之间有顺序。每对人均不可以相邻，问一共有多少种坐法？</strong></p><a id="more"></a><p>考虑用总的排列数减去每对人都相邻的情况，于是我们发现后者的排列是可以容斥的。</p><p>设$f(k)$表示$k$对人均坐在一起的排列数，那么答案就是：<br>$$<br>\sum_{k=0}^m(-1)^kf(k)<br>$$<br>$f(k)$也比较容易算，可以由下面几个部分组合起来：</p><ol><li>$m$对中任取$k$对：$C(m,k)$</li><li>每对人有顺序，那么所有可能的排列就是$2^k$</li><li>在$2n​$个位置里面挑$k​$对位置，将两个相邻位置看成一个座位，那么相当于$2n-k​$个位置的排列，那么总计一共有$(2n-k)!​$种排列。</li></ol><p>于是$f(k)=C(m,k)2^k(2n-k)!$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod =(LL) <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8100001</span>;</span><br><span class="line">LL f[maxn];</span><br><span class="line">LL n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) f[i] = (f[i<span class="number">-1</span>] * i) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = (ret * x) % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    x = (x * x) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LL ret = exgcd(b, a%b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span> </span>&#123;</span><br><span class="line">  LL x, y;</span><br><span class="line">  exgcd(a, mod, x, y);</span><br><span class="line">  <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f[x] * inv(f[x-y]) % mod * inv(f[y]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL k = <span class="number">0</span>; k &lt;= m; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">ret += (f[<span class="number">2</span>*n-i]*C(m,i)%mod)*mul(<span class="number">2L</span>L,i)%mod;</span><br><span class="line">ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ret -= (f[<span class="number">2</span>*n-i]*C(m,i)%mod)*mul(<span class="number">2L</span>L,i)%mod;</span><br><span class="line">ret += mod;</span><br><span class="line">ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) ret += mod;</span><br><span class="line"><span class="keyword">return</span> ret % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="comment">// freopen("out", "w", stdout);</span></span><br><span class="line">init();</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _ &lt;&lt; <span class="string">" Done."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, gao());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;amp;a=2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;amp;a=2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一共有$2n$个座位排成一排，现在有m对人去坐，每对人之间有顺序。每对人均不可以相邻，问一共有多少种坐法？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Kickstart" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Kickstart/"/>
    
    
      <category term="组合数学， 容斥" scheme="https://vincentxwd.github.io/blog/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C-%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces521E] Thematic Contests(贪心)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/17/cf521E/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/17/cf521E/</id>
    <published>2018-11-16T18:05:11.000Z</published>
    <updated>2018-11-16T18:11:45.208Z</updated>
    
    <content type="html"><![CDATA[<p>赛后4min过题的感觉真不爽啊……</p><p>题目链接：<a href="http://codeforces.com/contest/1077/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1077/problem/E</a></p><p><strong>题意：要$n$个题出比赛，每一个题有一个类型$a_i$，要求每一天出的比赛都是同一种类型的题，并且每一种类型在这几天内只出现一次，并且当前一天出题数是前一天的2倍，问这些天最多出多少题。</strong></p><a id="more"></a><p>首先维护一下每一种题出现的次数，我们只需要操作这个次数就可以了。</p><p>对题目出现次数从大到小排个序，接下来我们考虑枚举题目的上界，然后往下枚举就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;LL,LL&gt; vis;</span><br><span class="line">LL n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL a;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n)) &#123;</span><br><span class="line">    vis.clear();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;a);</span><br><span class="line">      vis[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; cnt;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : vis) &#123;</span><br><span class="line">      cnt.emplace_back(x.second);</span><br><span class="line">      ret = max(ret, x.second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cnt.begin(), cnt.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      LL t = i;</span><br><span class="line">      LL tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt.size(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(cnt[j] &gt;= t) tmp += t;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[j] &lt; t) <span class="keyword">break</span>;</span><br><span class="line">        tmp += t;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ret = max(ret, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;赛后4min过题的感觉真不爽啊……&lt;/p&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1077/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1077/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意：要$n$个题出比赛，每一个题有一个类型$a_i$，要求每一天出的比赛都是同一种类型的题，并且每一种类型在这几天内只出现一次，并且当前一天出题数是前一天的2倍，问这些天最多出多少题。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 支持向量机（SVM）</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/16/svm/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/16/svm/</id>
    <published>2018-11-16T14:16:23.000Z</published>
    <updated>2018-11-17T09:01:00.923Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第六章（支持向量机）的笔记。支持向量机最根本的想法是利用数据集找到一个超平面，将两类的样本分隔开，并且这个超平面距离两类数据的支持向量最远。支持向量指的是距离超平面最近的几个点。</p><a id="more"></a><hr><p>HEXO特别坑，我的数学公式在typora中编辑正常，但是生成静态页面时就解析错误了，只好上传图片外加附PDF文件了：<a href="http://pcoln8jiu.bkt.clouddn.com/svm.pdf" target="_blank" rel="noopener">http://pcoln8jiu.bkt.clouddn.com/svm.pdf</a></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_1.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_2.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_3.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_4.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_5.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_6.Jpeg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第六章（支持向量机）的笔记。支持向量机最根本的想法是利用数据集找到一个超平面，将两类的样本分隔开，并且这个超平面距离两类数据的支持向量最远。支持向量指的是距离超平面最近的几个点。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces520D] Fun with Integers (规律，并查集)</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/16/cf520d/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/16/cf520d/</id>
    <published>2018-11-15T17:16:26.000Z</published>
    <updated>2018-11-15T17:43:12.470Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1062/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/D</a></p><p>给一个$n$，现在允许任意初始一个数$k$并给定一个操作：$ax=b$，$bx=a$当且仅当$a$为$b$的倍数或$b$为$a$的倍数时，可以将$a$变为$b$（可以是负数），同时获得分数$|x|$. 要求不允许有多次$a$到$b$或$b$到$a$的操作（每个$x$仅算一次），问最多能得多少分。</p><a id="more"></a><p>看到第一个样例就明白了：考虑一个数$x$和它的因数$p_i$，我们总可以由$x$转到所有$\pm p_i$的可能（从$x$转到$p_i$，再由$p_i$转到$-x$，然后是$-x$到$-p_i$，接着是$-p_i$到$x$），每一次的贡献是$4p_i$，于是我们考虑维护所有带有整除关系的连通块，然后计算它们的所有倍数和*4就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line">LL s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  pre[find(x)] = find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">        unite(i, i*j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">        s[find(i)] += (LL)j &lt;&lt; <span class="number">2L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = max(ret, s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1062/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1062/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给一个$n$，现在允许任意初始一个数$k$并给定一个操作：$ax=b$，$bx=a$当且仅当$a$为$b$的倍数或$b$为$a$的倍数时，可以将$a$变为$b$（可以是负数），同时获得分数$|x|$. 要求不允许有多次$a$到$b$或$b$到$a$的操作（每个$x$仅算一次），问最多能得多少分。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="规律" scheme="https://vincentxwd.github.io/blog/tags/%E8%A7%84%E5%BE%8B/"/>
    
      <category term="并查集" scheme="https://vincentxwd.github.io/blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] Bayes分类器</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/10/bayes/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/10/bayes/</id>
    <published>2018-11-10T14:08:12.000Z</published>
    <updated>2018-11-12T03:34:44.015Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）的笔记。</p><a id="more"></a><hr><h2 id="贝叶斯决策论"><a href="#贝叶斯决策论" class="headerlink" title="贝叶斯决策论"></a>贝叶斯决策论</h2><p>使用贝叶斯决策论解决问题时的目标实际上是“最小化总体风险”，可以形式化表示成下式：<br>$$<br>R(c_i|x)=\sum_{j=1}^{n}\lambda_{ij}P(c_j|x)<br>$$<br>$\lambda_{ij}$：$i$类误分类成$j$类的代价。</p><p>$P(c_i|x)$：样本$x$分类成$c_i$的概率。</p><p>贝叶斯决策论希望找到一个最小化总体风险的判别准则$h(x)$，对于分类任务则是一个分类准则（$h(x)$表示将$x$归类为$h(x)$类），使得上述总体风险最小：<br>$$<br>h(x)=\mbox{argmin}\ R(c|x)<br>$$</p><hr><h2 id="贝叶斯准则"><a href="#贝叶斯准则" class="headerlink" title="贝叶斯准则"></a>贝叶斯准则</h2><p>贝叶斯准则可以简单理解为“整体风险最小化=每个样本的风险最小化”，风险指的是（比如在分类问题中）被分成错误类的期望。</p><p>能够使用贝叶斯准则的前提是获得后验概率$P(c|x)$，贝叶斯分类器此类生成模型则会考虑使用贝叶斯定理来求解这个后验概率：<br>$$<br>P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}<br>$$<br>解释一下公式中的每一个量的意义：</p><p>$P(c|x)$：<strong>后验概率</strong>，认为$x$分类成$c$的概率。</p><p>$P(c)$：<strong>先验概率</strong>，从公式上直观上看就是“偏见”、“第一眼看到这个人就觉得他是坏人”这样的概率。</p><p>$P(x|c)$：$x$相对于$c$的类条件概率，也称<strong>似然</strong>。指的是已知某些观测所得到结果（类别是$c$）时，对有关事物的性质（恰好是样本$x$）的参数进行估计[1]。</p><p>$P(x)$：用于归一化的因子，$P(x)=\sum_{i=1}^{n}P(x|c=i)P(c=i)$.</p><p>贝叶斯定理实际上就是希望通过已知相当数量的训练数据集合$D$，我们希望找到一个合理的方法来估计$D$中的$P(c)$和$P(x|c)$：</p><p>我们假设训练集中的训练数据独立同分布，那么根据大数定律，$P(c)$可以用每一类样本的<strong>频率</strong>来估计。</p><p>$P(x|c)$很难使用频率估计，因为$D$中的样本$x$通常无法完全覆盖所有情况：未被数据集覆盖$\not=$出现概率为0。于是需要使用<strong>极大似然估计</strong>.</p><hr><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计(MLE)"></a>极大似然估计(MLE)</h2><p>书中首先在介绍Logistic回归的时候使用了MLE（对数似然），但是没有仔细介绍。</p><p>首先假设数据集符合某种概率分布$D(\theta_c)$，被分成不同类完全取决于参数向量$\theta_c$.训练模型的过程就是参数估计的过程。</p><p>极大似然估计（MLE）就是一种参数估计方法，估计方法完全写在名字里了：似然（$P(x|c)$）极大化。由于分类结果完全取决于$\theta_c$，因此这个似然可以表示成$P(x|\theta_c)$.介绍贝叶斯准则的时候也讲了，“整体风险最小化=每个样本的风险最小化”。因此$\theta_c$对于整个数据集$D​$的似然就是：<br>$$<br>P(D|\theta_c)=\prod_{x\in D}P(x|\theta_c)<br>$$<br>我们给它取对数（因为小数连乘会导致精度损失）：<br>$$<br>L(\theta_c)=logP(D|\theta_c)=\sum_{x\in D}\mbox{log}P(x|\theta_c)<br>$$<br>我们对$\theta_c$的估计为：<br>$$<br>\hat{\theta_c}=\mbox{argmax}_{\theta_c}L(\theta_c)<br>$$<br>分析到这里这个式子已经展不开了，因为每个样本具体的似然取决于<strong>我们假设的是哪个分布</strong>，比如概率密度函数服从正态分布$\N(\mu_c,\sigma^2_c)$，那么对于它的参数$\mu_c$和$\sigma_c^2$的极大似然估计分别为数据集的均值$\dfrac{\sum_{x\in D}x}{|D|}$和方差$\dfrac{\sum_{x\in D}(x-\hat{\mu_c})^2}{|D|}$。</p><p>（然而我认为通常这么随意假设数据分布是不科学的= =）</p><hr><h2 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h2><p>由于$P(x|c)$是所有属性的联合概率，难以估计属性之间的关系，为了避免计算上的问题，引入属性条件独立性假设。</p><p>属性条件独立性假设：假设所有属性（理解：样本$x$中的每一维）相互独立。</p><p>于是$P(c|x)$重写为：<br>$$<br>P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}=\dfrac{P(c)}{P(x)}\sum_{i=1}^dP(x_i|c)<br>$$<br>$d$为属性数，$x_i$为样本$x$在第$i$个属性的取值。对于每个类$c$，$P(x)$都一样。在计算过程中可以忽略，于是：<br>$$<br>h(x)=\mbox{argmin}\ R(c|x)<br>$$</p><p>$$<br>=\mbox{argmax}\ P(c|x)<br>$$</p><p>$$<br>=\mbox{argmax}\ P(c)\prod_{i=1}^dP(x_i|c)<br>$$</p><p>$P(c)$：可以由每类的样本出现<strong>频率</strong>获得。</p><p>$P(x_i|c)$：针对离散的情况，可以根据类别是$c$并且含有属性$x_i$的出现<strong>频率</strong>获得；针对连续的情况，用密度函数。</p><p>一句话：于是计算贝叶斯实际上就是算两个量：$P(c)$和$P(x_i|c)$，按照两个量对应样本的<strong>频率</strong>获得一个概率，然后再用$h(x)$的计算方法乘出不同属性对应不同分类的极大似然估计即可。</p><hr><h2 id="缺省值处理"><a href="#缺省值处理" class="headerlink" title="缺省值处理"></a>缺省值处理</h2><p>有时会遇到某个样本某个属性缺失的情况，但是又不至于将该样本删除，于是需要进行平滑处理。拉普拉斯修正。</p><hr><h2 id="半朴素贝叶斯"><a href="#半朴素贝叶斯" class="headerlink" title="半朴素贝叶斯"></a>半朴素贝叶斯</h2><p>适当考虑部分属性的相互依赖信息，半朴素贝叶斯使用<strong>“独依赖估计”</strong>，即每个属性至多依赖于一个其他属性。<br>$$<br>P(c|x) \propto P(c)\prod_{i=1}^dP(x_i|c_,pa_i)<br>$$<br>$pa_i$：$x_i$所依赖的属性（$x_i$的父属性），计算过程就是将任意两个属性之间的依赖信息$I(x_i,x_j)$为边权建图，跑最大生成树。</p><hr><h2 id="贝叶斯网"><a href="#贝叶斯网" class="headerlink" title="贝叶斯网"></a>贝叶斯网</h2><p>贝叶斯网是个有向无环图，用点表示属性，权值为属性发生的概率，边表示依赖关系，边权为条件概率。例如$A$有一条指向$B$的边，点权描述的是$P(A)$、$P(B)$，这条边的权描述的就是$P(B|A)$. 没有边相连的两个点之间是相互独立的。</p><p>有一个笔记[2]中的例子非常形象地描述了相互独立的性质：</p><p>一个聪明人，在一场很难的考试里拿了高分，却得到了一封很烂的推荐信，同时他SAT考试却是高分的概率是多少？</p><p>我们再隐藏一些细节，一个人推荐信很烂，他SAT高分的概率是多少？或者，一个人SAT低分，却手握牛推的概率是多少？</p><p>如果不考虑随机变量之间的依赖关系，上述内容是很难计算的。但是如果有一个构建好的概率图，上面的问题则可以转化为条件概率问题。</p><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>已知网络结构的话，那么贝叶斯网上的各种信息是很容易统计的，按照网络要求和训练数据统计不同<strong>频率</strong>即可。</p><p>若网络结构未知，将贝叶斯网的学习看作是一个数据压缩任务，目标是<strong>学习到一个能以最短编码长度描述训练数据的模型</strong>。定义评分函数：<br>$$<br>s(B|D)=f(\theta)|B|-L(B|D)<br>$$<br>s(B|D)：在数据集$D$条件下的贝叶斯网$B$的评分函数。</p><p>$|B|$：贝叶斯网的参数个数。</p><p>$f(\theta)$：描述每个参数$\theta$所需字节数</p><p>$L(B|D)$：贝叶斯网的对数似然。</p><p>我们最终的目的是寻找一个$B$使$s$(B|D)最小，$f(\theta)$可以取1或者$\dfrac{1}{2}\mbox{log}\ m$，分别称为AIC和BIC。</p><h4 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h4><p>不能直接根据贝叶斯网定义的联合概率分布来计算后验概率，因为网络节点多的稠密图推理是NP-hard的。于是可以借助<strong>近似推断</strong>，常用Gibbs采样完成，先跳过了= =、</p><hr><p>Reference：</p><p>[1]. <a href="https://blog.csdn.net/lwq1026/article/details/70161857" target="_blank" rel="noopener">https://blog.csdn.net/lwq1026/article/details/70161857</a></p><p>[2].  <a href="https://www.cnblogs.com/ironstark/p/5087081.html" target="_blank" rel="noopener">https://www.cnblogs.com/ironstark/p/5087081.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记] Bias-Variance Dilemma</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/05/BiasVarianceTradeoff/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/05/BiasVarianceTradeoff/</id>
    <published>2018-11-05T04:08:12.000Z</published>
    <updated>2018-11-08T14:26:18.237Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Deliberate Practice$\ ^{[1]}$：to identify your weakest areas and direct a massive effort on improving those areas without worrying about areas in which you are already good.</strong></p><p>这是我在阅读西瓜书第二章时的一个遗留问题，是关于偏差-方差窘境（Bias-Variance Dilemma）的内容。</p><a id="more"></a><p>首先要解释Bias-Variance Tradeoff，也就是偏差-方差权衡，譬如当前有一个拟合任务，需要构造一个多项式函数去拟合它，函数可以构造成这样：<br>$$<br>y=a_0+a_1x+a_2x^2+…+a_nx^n<br>$$<br>如何确定$n$的大小就是一个偏差-方差的权衡问题，。图像上直观地看则是为了确定这条曲线的“弯曲程度”。</p><p>曲线拟合和机器学习：前者是利用数据尽可能地拟合出一条完美的曲线；后者则是在有限的数据规模内进行学习，目的是遇到未知数据时能够做出最好的判断。</p><p>模型的泛化能力可以由泛化误差来描述，泛化误差越小，模型的期望泛化能力越强。模型$f$在数据集$D$上的泛化误差可以分解为偏差$bias$、方差$var$、噪声$\epsilon$之和：<br>$$<br>E(f;D)=\mbox{bias}^2(x)+\mbox{var}(x)+\epsilon^2<br>$$<br>递推可以在西瓜书P45翻到。</p><p>噪声指的是学习算法本身固有的误差（系统误差）和数据集的噪声。当保证数据集十分纯净的时候，人为可控的部分就只有偏差和方差了。于是机器学习中存在偏差-方差窘境：<strong>偏差(bias)描述的是模型的拟合能力，偏差过大可以认为是欠拟合；方差(variance)则描述的是数据集的情况，方差过大可以认为是在数据集上过拟合。</strong>二者无法同时达到最小，只能取一个平衡点。    </p><p>总结一下特点：</p><ul><li>高偏差的模型：训练集的错误率高，验证集和训练集的错误率类似。</li><li>高方差的模型：训练集错误率低，验证集高。</li></ul><p>下图描述了一些简单的处理方法：<br><img src="https://www.learnopencv.com/wp-content/uploads/2017/02/Machine-Learning-Workflow.png" alt="img"></p><hr><p><strong>Reference</strong></p><p>[1]. <a href="https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/" target="_blank" rel="noopener">https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Deliberate Practice$\ ^{[1]}$：to identify your weakest areas and direct a massive effort on improving those areas without worrying about areas in which you are already good.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是我在阅读西瓜书第二章时的一个遗留问题，是关于偏差-方差窘境（Bias-Variance Dilemma）的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[读书笔记-西瓜书] 决策树</title>
    <link href="https://vincentxwd.github.io/blog/2018/11/04/decision_tree/"/>
    <id>https://vincentxwd.github.io/blog/2018/11/04/decision_tree/</id>
    <published>2018-11-04T07:08:12.000Z</published>
    <updated>2018-11-04T16:25:40.294Z</updated>
    
    <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第四章（决策树）的笔记，因为决策树是比较简单的算法，没有什么数学公式的推导，书中也是简单介绍了下信息熵的定义。</p><p>简单总结一下这一章的要点：</p><p>这一章介绍决策树，决策树的特点就是每一个节点作为一个选择分支，用于判断某一个样本是否含有这个属性。</p><p>决策树是递归定义的，因此属性个数理论上讲可以是无限多个。</p><p>在选择某个节点的代表属性时，引入利用信息增益为准则的ID3、C4.5和CART算法，这是三种较为类似的决策树的学习算法。</p><p>为了防止过拟合，还对决策树使用了剪枝操作。</p><p>处理连续值的方法是离散化后设定划分点。</p><p>遇到缺失值时利用无缺失的值进行估计，计算对应的信息增益再进行划分。</p><p>决策树的每一个节点还可以考虑不止一个属性，譬如使用多个属性值的线性组合的形式（多变量决策树），即允许存在斜的划分边界。甚至可以在每一个节点放一个感知机（感知机树）。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是阅读周志华教授《机器学习》中第四章（决策树）的笔记，因为决策树是比较简单的算法，没有什么数学公式的推导，书中也是简单介绍了下信息熵的定义。&lt;/p&gt;
&lt;p&gt;简单总结一下这一章的要点：&lt;/p&gt;
&lt;p&gt;这一章介绍决策树，决策树的特点就是每一个节点作为一个选择分支，用于判断某一个样本是否含有这个属性。&lt;/p&gt;
&lt;p&gt;决策树是递归定义的，因此属性个数理论上讲可以是无限多个。&lt;/p&gt;
&lt;p&gt;在选择某个节点的代表属性时，引入利用信息增益为准则的ID3、C4.5和CART算法，这是三种较为类似的决策树的学习算法。&lt;/p&gt;
&lt;p&gt;为了防止过拟合，还对决策树使用了剪枝操作。&lt;/p&gt;
&lt;p&gt;处理连续值的方法是离散化后设定划分点。&lt;/p&gt;
&lt;p&gt;遇到缺失值时利用无缺失的值进行估计，计算对应的信息增益再进行划分。&lt;/p&gt;
&lt;p&gt;决策树的每一个节点还可以考虑不止一个属性，譬如使用多个属性值的线性组合的形式（多变量决策树），即允许存在斜的划分边界。甚至可以在每一个节点放一个感知机（感知机树）。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Machine Learning" scheme="https://vincentxwd.github.io/blog/tags/Machine-Learning/"/>
    
  </entry>
  
</feed>
