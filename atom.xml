<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kirai</title>
  
  <subtitle>Keep going</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://vincentxwd.github.io/blog/"/>
  <updated>2018-10-12T02:29:47.127Z</updated>
  <id>https://vincentxwd.github.io/blog/</id>
  
  <author>
    <name>Kirai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[读书笔记] Neural Networks and Deep Learning Chapter 1</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/08/nndl_ch1/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/08/nndl_ch1/</id>
    <published>2018-10-08T01:28:00.000Z</published>
    <updated>2018-10-12T02:29:47.127Z</updated>
    
    <content type="html"><![CDATA[<p>这是我阅读在线书籍《Neural Networks and Deep Learning》的笔记，这篇博文是第一章的。没什么营养，因为大部分都知道了，于是草草略过。</p><p>章节链接： <a href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html</a></p><a id="more"></a><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h3><p>科普。</p><h3 id="words"><a href="#words" class="headerlink" title="words"></a><strong>words</strong></h3><ol><li>effortlessly：毫不费力地</li><li>deceptive：欺骗性的</li><li>superbly：雄伟地（文中表程度大）</li><li>astoundingly：令人惊讶地</li><li>stupendously：（同上）</li></ol><hr><p>科普。。</p><p><strong>words</strong></p><ol><li>morass：沼泽、困境</li><li>caveats：警告</li></ol><hr><p>科普。。。讲下NN可以从一堆数据中学习到一些特征，然后去预测一些没见过的数据。并且数据越多效果越好。</p><hr><p>介绍第一章要搞什么（手撸一个NN，用来识别手写数字，就74行），随后的章节要搞什么（想一些trick提升NN的acc之类）。</p><p><strong>words</strong></p><ol><li>intervention：介入、调停</li></ol><hr><p>手写数字识别这个问题简单，非常适合用来举例（大概这样可以把注意力更多地集中到NN本身之类？）。<em>it’s challenging - it’s no small feat to recognize handwritten digits - but it’s not so difficult as to require an extremely complicated solution, or tremendous computational power.</em><br>(这是一项具有挑战性的工作——识别手写的数字绝非易事——但是拥有一个极其复杂的解决方案，或者是巨大的计算能力的话就不难了)，之后会讲一些扩展。</p><p><strong>words</strong></p><ol><li>throughout：自始至终</li></ol><hr><p>这章的重点：</p><p>两类神经元：<strong>感知机（Perceptrons）</strong>和<strong>sigmoid函数</strong>。</p><p>神经网络的标准训练方法：<strong>随机梯度下降（Stochastic gradient descent, SGD）</strong></p><p><em>Amongst the payoffs, by the end of the chapter we’ll be in position to understand what deep learning is, and why it matters.</em>最后会讨论一下DL为什么会matters。</p><hr><h3 id="Perceptrons"><a href="#Perceptrons" class="headerlink" title="Perceptrons"></a><strong>Perceptrons</strong></h3><p>感知机（<a href="http://books.google.ca/books/about/Principles_of_neurodynamics.html?id=7FhRAAAAMAAJ）是一类人工神经元，由科学家Frank" target="_blank" rel="noopener">http://books.google.ca/books/about/Principles_of_neurodynamics.html?id=7FhRAAAAMAAJ）是一类人工神经元，由科学家Frank</a> Rosenblatt在上世纪50到60年代间完成。</p><p>不过目前非常流行的一类模型是神经网络（Neural Network），最重要的一部分是sigmoid（就个非线性函数）。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz0.png" alt="img"></p><p>上图是个最原始感知机的神经元，嗯。</p><p>假设这个perceptron有三个输入$x_1,x_2,x_3$，中间的圈里一系列权重$w_1,w_2,w_3$。输入来的时候，我们首先做向量乘法$sum=\sum_i w_ix_i$，然后要和一个阈值$threshold$比较得到$output$：<br>$$<br>\begin{eqnarray}<br>output&amp;=&amp;<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ sum \leq threshold \<br>1, \ \ otherwise.<br>\end{array}<br>\right.<br>\end{eqnarray}<br>$$</p><hr><p>举个例子。</p><p><strong>words</strong></p><ol><li>transit：公共交通</li><li>adore：崇拜、爱慕</li><li>loathe：讨厌</li></ol><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz1.png" alt="img"></p><p>每一列称之为<strong>层（Layer）</strong>，第一层的三个神经元对输入分别以自己的权重进行处理（每层的处理就是向量乘积，最后获得<strong>一个值</strong>），得到的输出（可能不用threshold判断）再分别给第二层的每一个神经元，第二层的决策会更加复杂，因为第二层的输入是通过第一层抽象过的结果。</p><p>实际上每个神经元的输入可以有很多，但是输出都是一个。这么画是为了说明层与层之间是如何联系起来的。</p><p><strong>words</strong></p><ol><li>plausible：可信的</li><li>subtle：微妙的</li><li>engage：从事，参与</li><li>sophisticated：复杂的</li><li>incidentally：顺便，附带地</li></ol><hr><p>把上述神经元的计算过程简化下：<br>$$<br>\begin{eqnarray}<br>output&amp;=&amp;<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ \omega\cdot x+b \leq 0 \<br>1, \ \ otherwise.<br>\end{array}<br>\right.<br>\end{eqnarray}<br>$$<br>$b$就是bias，也是threshold。表示一种“输出1”的测量(<em>the bias as a measure of how easy it is to get the perceptron to output a 1.</em> )。</p><p><strong>words</strong></p><ol><li>cumbersome：冗杂的，累赘的</li><li>notation：标志、符号、记号</li><li>reminder：剩下的</li></ol><hr><p>举了个简单的例子，说明感知机可以做与、或、非之类的逻辑操作：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz2.png" alt="img"></p><p>上图就是一个与非门，实际上感知机能做任何逻辑操作（因为这东西可以实现一切基本逻辑操作，那么就像连电路一样把那些门都连起来就行了）。</p><p>这是为了说明，感知机可以和其他计算设备一样强大。然而并非仅此而已，我们还可以在这个简单的模型上使用学习算法，使这个模型可以自己调整每一个神经元中的weights和bias，这种调节来自外部刺激（external stimuli），而非手动调整。</p><p><strong>words</strong></p><ol><li>equivalent：等价物</li><li>notable：值得注意的</li></ol><hr><p><strong>Sigmoid Neurons</strong></p><p>先介绍更新权重的时候，可以表示成$\omega+\Delta\omega$的形式，这样就可以学习了（当然都是向量）。也就是，我们希望每次output反过头过来传个值，然后更新这个网络。</p><p>但是上述的naïve perceptron在输出的时候都会经过一个突变函数（非零即一），通过这个门以后后面的神经元就完全没法恒量差别了（就像雅思）。</p><p>引出sigmoid：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz9.png" alt="img"></p><p>这里output为$\sigma(z) \equiv\dfrac{1}{1+e^{-z}}=\dfrac{1}{1+exp(-\sum_jw_jx_j-b)}$。</p><p>这样做的好处是对之前用的step function做了平滑处理，使得变化看起来不会过于激烈。看看原文是如何解释的：</p><p><em>The smoothness of $\sigma$ means that small changes $\Delta w_j$ in the weights and $\Delta b$ in the bias will produce a small change $\Delta output$ in the output from the neuron.</em></p><p>就是说变化后的w和b在处理完输入接着输出到output的时候，使得output的变化不至于太剧烈，output可以近似为下面的值：<br>$$<br>\begin{eqnarray}<br>  \Delta \mbox{output} \approx \sum_j \frac{\partial \, \mbox{output}}{\partial w_j}<br>  \Delta w_j + \frac{\partial \, \mbox{output}}{\partial b} \Delta b<br>\end{eqnarray}<br>$$<br>确实可以用微分来解释，因为$\mbox{output}$是一个n元一次线性方程，那么对它微分就是各项偏导之和，而微分的几何意义就是表示偏移量（变化量）的。</p><p>我们需要有一个平滑函数$\sigma$来简化运算，由于指数在微分时的性质（无限可微），所以构造了sigmoid函数作为激活函数（sigmoid还有一个著名性质就是导数可以用自身表达）。</p><p>如何解释经过sigmoid的输出？</p><p>最大的不同是：经过sigmoid平滑后，输出由原来的0或1变为[0,1]中任意实数（希望变成0 1的话直接设阈值max一下就ok）。</p><p><strong>words</strong></p><ol><li>terrific：可怕的</li><li>property：性质、性能</li><li>occasionally：偶尔、偶然地、不定期地</li><li>legitimate：合法的</li><li>convention：约定</li></ol><hr><p><strong>Exercises</strong></p><p>part I：证明感知机中所有w、b都乘一个大于0的常数c，这个网络的输出不会改变。</p><p>证：$\begin{eqnarray}<br>\mbox{output}&amp;=&amp;<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ \omega\cdot x+b \leq 0 \<br>1, \ \ otherwise.<br>\end{array}<br>\right.<br>\end{eqnarray}$，乘一个整数不会影响。</p><p>part II：给一个感知机，对于任意输入$x$，都有$\omega\cdot x+b \not=0$。现在把所有神经元都替换成sigmoid神经元，再乘一个大于0的常数c，证明假如c趋于无穷大的时候，有sigmoid神经元的模型就会退化成没有sigmoid的网络。假如$\omega\cdot x+b =0$的时候又会有什么不同？</p><p>(1). 证：$c \to +\infty,c&gt;0$时，可以分别将$lim$带入上述$\sigma$函数中求极限，发现分别收敛于0和1。</p><p>(2). 结果会输出0，而sigmoid会输出0.5，是不一样的。</p><hr><h3 id="The-architecture-of-neural-networks"><a href="#The-architecture-of-neural-networks" class="headerlink" title="The architecture of neural networks"></a><strong>The architecture of neural networks</strong></h3><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz10.png" alt="img"></p><p>上图是一个网络，从左到右开始，第1层叫输入层（input layer），每个元素叫输入神经元；第2层叫隐层（hidden layer），未必只有一层；第3层叫输出层（output layer）。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz11.png" alt="img"></p><p>有多层的网络有时候也被称作“多层感知机”，这是有历史原因的。所以现在完全可以认为NN=MLP（MLP里的感知层（简单的线性操作）换成sigmoid）。</p><p>然后介绍识别手写数字的任务，提到最简单的构建NN的方法就是把一张图片（例如$64\times 64$）的灰度信息直接保存（输入直接是$4096$维，当然要把灰度归一化到[0,1]内），然后走一遍网络取argmax。同时，hidden layer的设计会非常多样。</p><p>前馈神经网络：通常定义只允许前面的层向后面的层输出，不允许反过来（不允许有环）。但是现在已经有一些可以带环的网络（RNN）。</p><p><strong>words</strong></p><ol><li>terminology：术语</li><li>philosophical：哲学的</li><li>rules of thumb：经验法则（大拇指规则）</li><li>heuristics：启发、尝试（法）</li></ol><hr><h3 id="A-simple-network-to-classify-handwritten-digits"><a href="#A-simple-network-to-classify-handwritten-digits" class="headerlink" title="A simple network to classify handwritten digits"></a><strong>A simple network to classify handwritten digits</strong></h3><p>本科做过了这段懒得读了。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz12.png" alt="img"></p><p>这个图挺帅，意思就是用一层hidden，然后输入是$28\times 28=784$维，然后最后输出10个分类的logits。</p><p>这里讨论了一个很有趣的问题：为什么输出是10个而不是4个（因为$2^4=16&gt;10$可以表示所有我们希望的数字情况）？</p><p>个人认为隐层中每次处理后都会提取图像中的某一部分的特征，预测的时候被激活与否的影响因素为某部分是不是有这个特征，有某种特征对应0-9这十个数是很容易的，然而要对应二进制编码则很难表示。</p><p><strong>words</strong></p><ol><li>sake：利益、理由</li></ol><p>Exercise懒得做了，只要对应好四个位置给权值就行了。</p><hr><h3 id="Learning-with-gradient-descent"><a href="#Learning-with-gradient-descent" class="headerlink" title="Learning with gradient descent"></a><strong>Learning with gradient descent</strong></h3><p>介绍mnist数据集，同时设计一些必要的环节：</p><p>$\mbox{cost function}$：$\begin{eqnarray}  C(w,b) \equiv \frac{1}{2n} \sum_x | y(x) - a|^2\end{eqnarray}.$（均方误差），训练过程中的目标是最小化$\mbox{cost function}$。</p><p>然后讲梯度下降：</p><p>$\begin{eqnarray}    \Delta C \approx \frac{\partial C}{\partial v_1} \Delta v_1 +   \frac{\partial C}{\partial v_2} \Delta v_2. \end{eqnarray}$ 我们的目标是希望使$\Delta C$变负，$\Delta v_1,\Delta v_2$分别是两个不同方向的偏移量。因此可以说$\Delta C$是两个方向偏移量的叠加。</p><p>定义梯度向量：$\begin{eqnarray}    \nabla C \equiv \left( \frac{\partial C}{\partial v_1},    \frac{\partial C}{\partial v_2} \right)^T. \end{eqnarray}$</p><p>所以化简后，变化量可以表示成：$\begin{eqnarray}    \Delta C \approx \nabla C \cdot \Delta v. \end{eqnarray}$</p><p>定义$\begin{eqnarray}    \Delta v = -\eta \nabla C\end{eqnarray}$，$\eta$是一个极小的正数（学习率），$\Delta C \approx -\eta \nabla C \cdot \nabla C = -\eta |\nabla C|^2$，$\Delta C \leq0$恒成立知，$C$是一个只减不增的值，于是我们在算出的$\Delta C$（我们希望让$\Delta C$一直是负数，也就是$C$一直下降）的同时，算出$v$移动后的位置$v’=v-\eta \nabla C$。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/valley_with_ball.png" alt="img"></p><p>就像这个绿球一直往地势低的地方滚，直到最低点（极低点）为止。</p><p>到$m$维的向量空间，$\nabla C$的定义会得到扩展：<br>$$<br>\begin{eqnarray}<br>  \nabla C \equiv \left(\frac{\partial C}{\partial v_1}, \ldots,<br>  \frac{\partial C}{\partial v_m}\right)^T<br>\end{eqnarray}<br>$$<br>（对于$\Delta v$中的每维变量，都会有一个对应的梯度去更新它。）</p><p>通常训练神经网络的工作都是面对这样一个最优化问题，梯度下降算法可以看做是一个采用最少步骤使得$C$下降的一个方法。</p><p><strong>words</strong></p><ol><li>quadratic：二次的</li><li>ah-doc：特别的</li><li>recap：翻造、重申</li><li>distract：转移、分心</li><li>lurk：潜伏、埋伏、隐藏</li></ol><hr><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a><strong>Exercise</strong></h3><p><a href="http://neuralnetworksanddeeplearning.com/chap1.html#exercises_647181" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html#exercises_647181</a></p><p>Part I. 证明上述的假设，即：当$\left|v\right| = \epsilon, \Delta v =-\eta \nabla C$时，其中$\epsilon &gt;0$为很小的一个数，且当$\eta =\dfrac{\epsilon}{\left| \nabla C\right|}$时，$\Delta C=\nabla C \cdot \Delta v$可以取到最小值。（也就是要证给定步长，我们沿着梯度的方向总能找到最小值）</p><p>证明：当$\Delta C = \nabla C \cdot \Delta v$且$\left|v\right|=\epsilon$时，令$\Delta v=-\eta \nabla C=(-\epsilon/\left|\Delta C\right|)\nabla C$，则有：<br>$$<br>\begin{align<em>}<br>\Delta C &amp;= \nabla C \cdot \Delta v \<br>&amp;=  \nabla C \cdot  ( -\epsilon/\left|\nabla C\right| ) \nabla C \<br>&amp;= \nabla C ^2 ( -\epsilon/\left|\nabla C\right| ) \<br>&amp;= \left|\nabla C\right| ^2 ( -\epsilon/\left|\nabla C\right| ) \<br>&amp;= -\epsilon \left|\nabla C\right| \<br>&amp;= -\left|\Delta v\right|\left|\nabla C\right|<br>\end{align</em>}<br>$$<br>由柯西-施瓦兹不等式，$\left|u\right|\left|v\right| \ge \left|u \cdot v\right|$得，$\left|\Delta v\right|\left|\nabla C\right|\ge \left| \Delta v \cdot \nabla C \right|$，$-\left|\Delta v\right|\left|\nabla C\right|$必为最小值。</p><p>Part II. 给出一个在多维和一维情况下梯度下降的几何解释。</p><p>答：一维的话就退化成函数求导问题了，就是在一个曲线上找极小值，也就是一个圆点往地势低的地方滚。</p><hr><p>接近物理学球下滚模拟的变种算法不可避免地需要求二阶偏微分，十分复杂。因此书中会引出一些方法来避免这个问题（梯度下降）。</p><p>梯度下降的目标是最小化$\mbox{cost function}\begin{eqnarray}  C(w,b) \equiv   \frac{1}{2n} \sum_x | y(x) - a|^2 \nonumber\end{eqnarray}$.</p><p>反向更新的时候，这样来更新weights和biases：<br>$$<br>\begin{eqnarray}<br>  w_k &amp; \rightarrow &amp; w_k’ = w_k-\eta \frac{\partial C}{\partial w_k} \<br>  b_l &amp; \rightarrow &amp; b_l’ = b_l-\eta \frac{\partial C}{\partial b_l}.<br>\end{eqnarray}<br>$$<br>但是有一个问题，原始的梯度下降里，这个目标函数实际上是在求$C​$在不同$x​$取值时的均值，也就是要把整个dataset都迭代一遍后再去反向传播。</p><p>随机梯度下降（Stochastic gradient descent，SGD）每次选取指定规模的mini-batch去做梯度下降，在mini-batch的大小$m$满足：<br>$$<br>\begin{eqnarray}<br>  \frac{\sum_{j=1}^m \nabla C_{X_{j}}}{m} \approx \frac{\sum_x \nabla C_x}{n} = \nabla C,<br>\end{eqnarray}<br>$$<br>即$m$个输入的平均值要接近于全体输入的平均值，SGD才可近似于naïve GD。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/1539092769209.png" alt="1539092769209"></p><p>带入权值和偏移更新中，公式变成这样：<br>$$<br>\begin{eqnarray}<br>  w_k &amp; \rightarrow &amp; w_k’ = w_k-\frac{\eta}{m}<br>  \sum_j \frac{\partial C_{X_j}}{\partial w_k} \<br>  b_l &amp; \rightarrow &amp; b_l’ = b_l-\frac{\eta}{m}<br>  \sum_j \frac{\partial C_{X_j}}{\partial b_l},<br>\end{eqnarray}<br>$$<br>在SGD时，称把整个数据集经过mini-batch训练一遍为一个epoch，通常要来好几个epoch。</p><p>在算目标函数的时候不要忘记$\frac{1}{n}$（用mini-batch的时候是$\frac{1}{m}$），做一下平均（因为有可能后来添加数据，就是说数据规模不一定的时候会影响到）。</p><p><strong>words</strong></p><ol><li>incidentally：顺便地，偶然一提地</li><li>convention：惯例，约定</li><li>omit：省略、疏忽</li></ol><hr><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a><strong>Exercise</strong></h3><p>提到了mini-batch size=1的时候的一种极限情况。</p><hr><h3 id="Implementing-our-network-to-classify-digits"><a href="#Implementing-our-network-to-classify-digits" class="headerlink" title="Implementing our network to classify digits"></a><strong>Implementing our network to classify digits</strong></h3><p>介绍数据集，和要实现的神经网络。稍微读下代码，其他没什么好看的。</p><hr><h3 id="Toward-deep-learning"><a href="#Toward-deep-learning" class="headerlink" title="Toward deep learning"></a><strong>Toward deep learning</strong></h3><p>又是一些废话。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我阅读在线书籍《Neural Networks and Deep Learning》的笔记，这篇博文是第一章的。没什么营养，因为大部分都知道了，于是草草略过。&lt;/p&gt;
&lt;p&gt;章节链接： &lt;a href=&quot;http://neuralnetworksanddeeplearning.com/chap1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://neuralnetworksanddeeplearning.com/chap1.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vincentxwd.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Deep Learning" scheme="https://vincentxwd.github.io/blog/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder199A] 分组(dfs，拉姆齐定理, 随机)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/07/Nowcoder-199A/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/07/Nowcoder-199A/</id>
    <published>2018-10-07T13:25:20.000Z</published>
    <updated>2018-10-07T14:02:47.494Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/199/A" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/199/A</a></p><p><strong>意思就是给你一个无向图染色，每个点最多有一个相邻点可以染成同色。</strong></p><a id="more"></a><p>我们证明一下解一定存在：</p><p>首先考虑$n&lt;4$，无论如何都能有解，显然成立。</p><p>我们可以画一下最极端的情况是什么样子的…</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/1538920651987.png" alt="1538920651987"></p><p>在这个情况下无法再想这个完全图内加边加点，因此这是个最极端的情况，但是它是有解的。</p><p>那么我们其他的符合条件的图都可以由这个图通过删边加点加边的方式获得并且他们是一个连通图（每个人都认识聚会中的一些人）。</p><p>于是这题就可以解了：</p><p>直接dfs，但是题目最后有个备注很蛋疼，那就是有10%的数据，有一组数据存在某个组里每个人都互相不认识。</p><p>所以我们考虑尽可能先处理那个分组里的点，这个分组里的点尽量首先安排。但是我们又不能知道那个组都有哪些个点，因此我们考虑把每一个点的边打乱一下保存再dfs，最后再加个特判就ok。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  vis[u] = id;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(!vis[v]) dfs(v, u, <span class="number">3</span>-vis[u]);</span><br><span class="line">    <span class="keyword">if</span>(vis[v] == vis[u]) cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span>) vis[u] = <span class="number">3</span> - vis[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      random_shuffle(G[i].begin(), G[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) dfs(i, <span class="number">-1</span>, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt2 == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,vis[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,vis[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">      <span class="keyword">if</span>(vis[i] == <span class="number">1</span>) cnt1++;</span><br><span class="line">      <span class="keyword">else</span> cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/199/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/199/A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;意思就是给你一个无向图染色，每个点最多有一个相邻点可以染成同色。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="dfs" scheme="https://vincentxwd.github.io/blog/tags/dfs/"/>
    
      <category term="随机" scheme="https://vincentxwd.github.io/blog/tags/%E9%9A%8F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder208A] Birthday(最小费用最大流)</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/06/Nowcoder-208A/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/06/Nowcoder-208A/</id>
    <published>2018-10-06T13:51:47.000Z</published>
    <updated>2018-10-07T13:29:46.467Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/206/A" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/206/A</a></p><p><strong>题意很简单，给你n个球，m个桶。现在每个球最多可以丢到两个桶中的一个，同时规定每个桶中球的平方和为代价。现在希望你找一个方案，使得代价最小。</strong></p><a id="more"></a><p>一开始random_shuffle后回溯在60%左右T掉。。</p><p>回溯的时候往一个当前有$x$个球的桶里丢一个球的时候，代价的增幅为$(x+1)^2-x^2$，于是来了灵感。</p><p>我们可以把丢球的过程看作节点，每次往一个当前有$x$个球的桶里多丢一个球的时候，意味着代价增加了$(x+1)^2-x^2$，而且这个代价是单调递增的。</p><p>我们考虑建图，超级源、汇中间有n个代表球的节点和m个代表桶中球数量的节点：</p><p>由源点出发，n个节点代表球，各连接一条，流量为1，费用为0的边。</p><p>接着从n个节点向m个节点出发，代表球可以向某两个桶里丢，流量为1，费用为0。</p><p>接着由m个桶向汇点连边，每个桶连n条边，流量为1，费用为该桶+1个球后代价的涨幅。由于涨幅是递增的，因此在求最小费用最大流的时候肯定从小到大流。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, next;</span><br><span class="line">  LL c, w;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">7070</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">0x3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">const</span> LL inf = (<span class="number">1L</span>L&lt;&lt;<span class="number">55</span>);</span><br><span class="line"><span class="keyword">int</span> tot, head[maxn];</span><br><span class="line">LL dist[maxn];</span><br><span class="line">LL cost, flow;</span><br><span class="line">Node e[maxm];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> S, T, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S = T = N = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c:容量, w:费用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL c, LL w)</span> </span>&#123;</span><br><span class="line">  e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">  e[tot].u = v; e[tot].v = u; e[tot].c = <span class="number">0</span>; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dist[i] = inf;</span><br><span class="line">    visit[i] = <span class="number">0</span>;</span><br><span class="line">    pre[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">  Q.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  pre[s] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q.front();</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(e[j].c &gt; <span class="number">0</span> &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123;</span><br><span class="line">        dist[e[j].v] = dist[u] + e[j].w;</span><br><span class="line">        pre[e[j].v] = j;</span><br><span class="line">        <span class="keyword">if</span>(!visit[e[j].v]) &#123;</span><br><span class="line">          Q.push(e[j].v);</span><br><span class="line">          visit[e[j].v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return dist[t] &lt; 0; // 求可行流</span></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 求最小费用流</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ChangeFlow</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  LL det = mod;</span><br><span class="line">  <span class="keyword">int</span> u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    det = min(det, e[u].c);</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    e[u].c -= det;</span><br><span class="line">    e[u ^ <span class="number">1</span>].c += det;</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> det;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">MinCostFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  LL mincost, maxflow;</span><br><span class="line">  mincost = maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(spfa(s, t, n)) &#123;</span><br><span class="line">    LL det = ChangeFlow(t);</span><br><span class="line">    mincost += det * dist[t];</span><br><span class="line">    maxflow += det;</span><br><span class="line">  &#125;</span><br><span class="line">  cost = mincost;</span><br><span class="line">  flow = maxflow;</span><br><span class="line">  <span class="keyword">return</span> mincost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    init();</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>; N = T + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) adde(S, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">      adde(i, n+a, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      adde(i, n+b, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        adde(i+n, T, <span class="number">1</span>, j*j-(j<span class="number">-1</span>)*(j<span class="number">-1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, MinCostFlow(S, T, N));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/206/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/206/A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意很简单，给你n个球，m个桶。现在每个球最多可以丢到两个桶中的一个，同时规定每个桶中球的平方和为代价。现在希望你找一个方案，使得代价最小。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="最小费用最大流" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>[总结] 反素数</title>
    <link href="https://vincentxwd.github.io/blog/2018/10/05/emirp/"/>
    <id>https://vincentxwd.github.io/blog/2018/10/05/emirp/</id>
    <published>2018-10-05T09:23:10.000Z</published>
    <updated>2018-10-07T16:09:56.868Z</updated>
    
    <content type="html"><![CDATA[<p><strong>素数</strong>的定义可以为：因子只有2个的数（一个是1，另一个是本身），也就是因子最少的数。</p><p>那么，<strong>反素数</strong>可以定义成<strong>因子数最多的数，假如因子个数相同那么是最小的那个数</strong>，反素数是相对于一个集合来说的（比如在$n$个数以内的数）。</p><p>简而言之，<strong>因素最多并且值最小的数，就是反素数</strong>。</p><a id="more"></a><p>朴素求法：利用整数唯一分解定理若$x=p_1^{k_1}p_2^{k_2}…p_n^{k_n}$，那么$x$就有$(k_1+1)(k_2+1)…(k_n+1)$个因数。给某个集合扫一遍求下$max$即可。</p><p>反素数有两个特点：</p><ol><li>反素数肯定是从$2$开始的连续素数的幂次形式的乘积。</li><li>数值小的素数的幂次大于等于数值大的素数：$x=p_1^{k_1}p_2^{k_2}…p_n^{k_n}$，那么有$k1 \geq k2 \geq…k_n$。    </li></ol><p>解释：</p><ol><li>反证，若存在不从$2$开始的连续素数之积$p$，那么必然存在一个从2开始的连续素数之积$q$，除了一个$2$以外，其他值均与$p$相等，而此时$q &lt; p$。</li><li>若存在$k_i, k_j$，使得$i&lt;j,k_i&gt;k_j$成立。那么我们可以交换一下$p_i$与$p_j$，使得这个数更小。</li></ol><p>想要求给定自然数$n$，求$[1,n]$内的反素数。这个问题似乎没有什么更加牛X的解决方法，实际上还是要通过<strong>枚举</strong>的方法，为了解决这个问题，我们再提出两个问题：</p><ol><li><strong>对于给定的$n$，要枚举到哪一个素数</strong>：枚举到$\leq n$的素数就可以。</li><li><strong>枚举多少次幂</strong>：实际上枚举到最小素数$p$的$k$次幂，使得$p^k&gt;n$，那么枚举到的最大幂次肯定要小于$k$。</li></ol><p>一般这类问题都是DFS+一些分支限界枚举答案的。</p><hr><p>练习1：<a href="http://codeforces.com/contest/27/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/27/problem/E</a></p><p>题意：找含有$n$个因子的最小的那个数，这个数不超过1E18。</p><p>分析：</p><ol><li>设这个数字是$m$，那么可以设$m=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$，其中$(k_1+1)(k_2+1)…(k_r+1)=n$。我们由上述<strong>结论1</strong>可以求出来$p_i$的上界：取$k_1=$2，那么最多也就是$\lceil log_21000 \rceil=10$个不同的素数，贪心取最小的前10个素数就可以。<del>分析到这里就可以打表了。</del></li><li>再考虑这个数在1E18内的问题，也就是$k$的取值范围。取最小的$p=2$，那么顶多是60层。</li></ol><p>于是我们就可以DFS，在每层（即每个素数）暴力枚举这个数选取次数，然后维护上一层的数值以及因数个数就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[maxn] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;;</span><br><span class="line">ull ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, ull cur, <span class="keyword">int</span> cnt, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(depth &gt;= <span class="number">11</span> || cnt &gt; n) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(cnt == n) &#123;</span><br><span class="line">    ret = min(ret, cur);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt * (i + <span class="number">1</span>) &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    cur *= (ull)p[depth];</span><br><span class="line">    dfs(depth+<span class="number">1</span>, cur, cnt*(i+<span class="number">1</span>), i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    ret = <span class="number">1E18</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;素数&lt;/strong&gt;的定义可以为：因子只有2个的数（一个是1，另一个是本身），也就是因子最少的数。&lt;/p&gt;
&lt;p&gt;那么，&lt;strong&gt;反素数&lt;/strong&gt;可以定义成&lt;strong&gt;因子数最多的数，假如因子个数相同那么是最小的那个数&lt;/strong&gt;，反素数是相对于一个集合来说的（比如在$n$个数以内的数）。&lt;/p&gt;
&lt;p&gt;简而言之，&lt;strong&gt;因素最多并且值最小的数，就是反素数&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="算法总结" scheme="https://vincentxwd.github.io/blog/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="总结" scheme="https://vincentxwd.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="数论" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder190H] CSL的校园卡</title>
    <link href="https://vincentxwd.github.io/blog/2018/09/15/nowcoder190h/"/>
    <id>https://vincentxwd.github.io/blog/2018/09/15/nowcoder190h/</id>
    <published>2018-09-15T15:10:34.000Z</published>
    <updated>2018-09-15T15:17:52.279Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/190/H" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/190/H</a></p><p><strong>中文题面不解释。</strong></p><a id="more"></a><p>很容易想到dp，但是要仔细设计一下状态。</p><p>两个人一起走，可以直接定义状态为dp(ax,ay,bx,by)，但是要维护每个可行点都遍历过，那么可以二进制位压。状态记成dp(sta,ax,ay,bx,by)，然后常规dfs就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ax, ay, bx, by, st;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, es;</span><br><span class="line"><span class="keyword">char</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">16</span>][maxn][maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; (G[x][y] == <span class="string">'S'</span> || G[x][y] == <span class="string">'O'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">  <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">  dp[<span class="number">1</span>&lt;&lt;id(sx, sy)][sx][sy][sx][sy] = <span class="number">0</span>;</span><br><span class="line">  q.push(&#123;sx, sy, sx, sy, <span class="number">1</span> &lt;&lt; id(sx, sy)&#125;);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    Node t = q.front(); q.pop();</span><br><span class="line">    <span class="keyword">if</span>(t.st == es) <span class="keyword">return</span> dp[es][t.ax][t.ay][t.bx][t.by];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> ax = t.ax + dx[i], ay = t.ay + dy[i];</span><br><span class="line">      <span class="keyword">if</span>(!ok(ax, ay)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bx = t.bx + dx[j], by = t.by + dy[j];</span><br><span class="line">        <span class="keyword">if</span>(!ok(bx, by)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> st = t.st | (<span class="number">1</span> &lt;&lt; id(ax, ay));</span><br><span class="line">        st |= (<span class="number">1</span> &lt;&lt; id(bx, by));</span><br><span class="line">        <span class="keyword">if</span>(dp[st][ax][ay][bx][by] == <span class="number">-1</span>) dp[st][ax][ay][bx][by] = dp[t.st][t.ax][t.ay][t.bx][t.by] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        q.push(&#123;ax, ay, bx, by, st&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    es = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[i][j] == <span class="string">'O'</span>) es |= (<span class="number">1</span> &lt;&lt; id(i, j));</span><br><span class="line">        <span class="keyword">if</span>(G[i][j] == <span class="string">'S'</span>) &#123;</span><br><span class="line">          x = i, y = j;</span><br><span class="line">          es |= (<span class="number">1</span> &lt;&lt; id(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs(x, y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/190/H&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/190/H&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中文题面不解释。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="bfs" scheme="https://vincentxwd.github.io/blog/tags/bfs/"/>
    
      <category term="dp" scheme="https://vincentxwd.github.io/blog/tags/dp/"/>
    
      <category term="状态压缩" scheme="https://vincentxwd.github.io/blog/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>[Nowcoder180D] xor序列 (线性基)</title>
    <link href="https://vincentxwd.github.io/blog/2018/09/08/Nowcoder-180D/"/>
    <id>https://vincentxwd.github.io/blog/2018/09/08/Nowcoder-180D/</id>
    <published>2018-09-08T09:43:18.000Z</published>
    <updated>2018-09-08T12:33:25.566Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/180/D" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/180/D</a></p><p><strong>题意就是给你$n$个数和$q$次询问，每次问你一个数$x$能不能被上述$n$个数之间随意异或得到。</strong></p><a id="more"></a><p>这题可以想到构造一组32个异或方程的方程组，每一个方程代表数位中某一位的异或结果。我们需要判断这个方程组是否有解。考虑方程组有无解实际上就是判断这个方程组的参数矩阵构成的一组基底能否表示每次查询的$x$，因此我们可以用线性基的技术解决这个问题。</p><p>关于线性基可以学习这篇blog：<a href="https://blog.sengxian.com/algorithms/linear-basis" target="_blank" rel="noopener">https://blog.sengxian.com/algorithms/linear-basis</a></p><p>由于我们不关心这组方程中最大线性无关组具体是什么，因此我们可以直接向无关组中判断插入每一个方程（就是每一个数字）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, x, y;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">31</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(!a[j]) &#123;</span><br><span class="line">            a[j] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          x ^= a[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">      x ^= y;</span><br><span class="line">      <span class="built_in">memcpy</span>(b, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">31</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(!b[j]) &#123;</span><br><span class="line">            b[j] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          x ^= b[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, x == <span class="number">0</span> ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/180/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/180/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意就是给你$n$个数和$q$次询问，每次问你一个数$x$能不能被上述$n$个数之间随意异或得到。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Nowcoder" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Nowcoder/"/>
    
    
      <category term="线性基" scheme="https://vincentxwd.github.io/blog/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>你好，UCAS</title>
    <link href="https://vincentxwd.github.io/blog/2018/09/04/Hello-UCAS/"/>
    <id>https://vincentxwd.github.io/blog/2018/09/04/Hello-UCAS/</id>
    <published>2018-09-04T09:37:15.000Z</published>
    <updated>2018-09-04T10:33:16.034Z</updated>
    
    <content type="html"><![CDATA[<p>70多公里，坐了一小时左右的车，终于到这里了。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/tsg.jpg" alt="img"></p><a id="more"></a><p>还真是蛮激动的，毕竟在所里的时候就听师兄师姐们说雁栖湖环境特别好。我来报到的这一天还在下雨，空气极度清晰。</p><p>坐车在学校绕了好久才找到了宿舍，宿舍可以说完全就是在山脚下。。。</p><p>这是宿舍的“客厅”。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/kt.jpg" alt="img"></p><p>一个屋子里一共有9个套间，每个套间只住一个人（单人间好评）。</p><p>套间是这样的。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/ss.jpg" alt="img"></p><p>有一个小窗户，我这里的位置不算太好，但是靠近向左看还是可以看到骆驼山的。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/ch.jpg" alt="img"></p><p>袋子里的全部东西（手写学生证预定）。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/zb.jpg" alt="img"></p><p>简单收拾了一下 ，于是跑路去买被窝还有一些日常用品了。由于太拥挤，并没有拍食堂。</p><p>下午在学校里转了转，感觉校园有点大啊。。晚上跑回宿舍洗衣服洗澡写论文。</p><hr><p>以上是报到当天的实况，然而最近有点自闭。大概是因为突然到一个新环境，有点不适应吧…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;70多公里，坐了一小时左右的车，终于到这里了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcoln8jiu.bkt.clouddn.com/tsg.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="只言片语" scheme="https://vincentxwd.github.io/blog/categories/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>SG函数学习笔记</title>
    <link href="https://vincentxwd.github.io/blog/2018/09/04/Note-of-Learning-SG-Function/"/>
    <id>https://vincentxwd.github.io/blog/2018/09/04/Note-of-Learning-SG-Function/</id>
    <published>2018-09-04T09:29:57.856Z</published>
    <updated>2018-09-04T09:35:33.320Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这是之前学习SG函数时所记的笔记。</strong></p><a id="more"></a><p><img src="http://pcoln8jiu.bkt.clouddn.com/sgfunction.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这是之前学习SG函数时所记的笔记。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法总结" scheme="https://vincentxwd.github.io/blog/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="博弈" scheme="https://vincentxwd.github.io/blog/tags/%E5%8D%9A%E5%BC%88/"/>
    
      <category term="总结" scheme="https://vincentxwd.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>[Codeforces1029E] Tree with Small Distances (贪心)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/27/CF1029E-Tree-with-Small-Distances-%E8%B4%AA%E5%BF%83/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/27/CF1029E-Tree-with-Small-Distances-贪心/</id>
    <published>2018-08-27T09:41:34.000Z</published>
    <updated>2018-08-27T09:52:31.559Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1029/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1029/problem/E</a></p><p><strong>给你一棵树，让你从根节点1向其他点上加边，最少加多少边可以让根节点到所有节点的距离≤2。</strong></p><a id="more"></a><p>考虑贪心，假如一个点n到根节点的距离＞2，显然直接连着两个点不如连这个点的父亲和根来的合算。于是我们贪心地连距离最远的点的父亲，并且更新距离可以了。</p><p>先dfs出距离，之后把不满足≤2的点的信息入堆处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == v) <span class="keyword">continue</span>;</span><br><span class="line">        dp[v] = dp[u] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[v] &gt; <span class="number">2</span>) q.push(make_tuple(dp[v], v, u));</span><br><span class="line">        dfs(v, u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">      tie(w, v, u) = q.top(); q.pop();</span><br><span class="line">      <span class="keyword">if</span>(dp[v] &lt;= <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">      ret++;</span><br><span class="line">      dp[u] = <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) dp[v] = min(dp[u]+<span class="number">1</span>, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://codeforces.com/contest/1029/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1029/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给你一棵树，让你从根节点1向其他点上加边，最少加多少边可以让根节点到所有节点的距离≤2。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="DFS" scheme="https://vincentxwd.github.io/blog/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>[HDOJ6425] Rikka with Badminton (组合数学)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/20/HDOJ6425-Rikka-with-Badminton/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/20/HDOJ6425-Rikka-with-Badminton/</id>
    <published>2018-08-20T14:01:21.000Z</published>
    <updated>2018-08-21T04:22:33.135Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6425" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6425</a></p><p><strong>$n$个人去打羽毛球，其中$a$个人没球没拍，$b$个人只有拍，$c$个人只有球，$d$个人什么都有。现在规定只要有两个人有拍，一个人有球就能去打。问有多少种组合不能去打。</strong></p><a id="more"></a><p>JLS给的解居然是个dp，惊了。</p><p>直接考虑有几种情况不能去打：球和拍都不够、球够拍不够、拍够球不够。</p><p>($a$个白嫖哥去不去都无所谓，因此他们对答案的整体贡献是$2^a$。)</p><p>球和拍都不够：分两种情况，完全没有拍和只有一个拍。第一种的贡献只有$a$出，第二种贡献从$a$和$b$里出。因此总体答案是$2^a+2^a×C_{b}^{1}$。</p><p>球够拍不够：这个贡献可以拆分成$a$和$c$、$a$和$b$、$a$和$b$和$d$里出。第一种（没有拍子）$c$类人随意去就可以（不能不去），贡献是$2^{a}×(2^{c}-1)$。第二种（只有一个拍子，$b$类人出拍子，$c$类人出球），贡献是$2^{a}×C_{b}^{1}×(2^c-1)$。第三种（只有一个拍子，$d$类人出拍子），贡献是$2^{a}×C_{d}^{1}×2^c$。</p><p>拍够球不够：只有$b$类人，且至少去$2$个，贡献是$2^a×C_{b}^{2}$。</p><p>全加起来就完事了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">LL a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = x * ret % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    x = x * x % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">    LL p1 = mul(<span class="number">2L</span>L, a) * (b + <span class="number">1</span>) % mod;</span><br><span class="line">    LL p2 = mul(<span class="number">2L</span>L, a) * (mul(<span class="number">2L</span>L, c) - <span class="number">1</span>) % mod;</span><br><span class="line">       p2 += ((mul(<span class="number">2L</span>L, a) * b % mod) * (mul(<span class="number">2L</span>L, c) - <span class="number">1</span>)) % mod; p2 %= mod;</span><br><span class="line">       p2 +=(( mul(<span class="number">2L</span>L, a) * d % mod) * mul(<span class="number">2L</span>L, c)) % mod; p2 %= mod;</span><br><span class="line">    LL p3 = (mul(<span class="number">2L</span>L, a) * (mul(<span class="number">2L</span>L, b) - b - <span class="number">1</span> + mod) % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (((p1+p2)%mod)+p3)%mod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6425&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=6425&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$n$个人去打羽毛球，其中$a$个人没球没拍，$b$个人只有拍，$c$个人只有球，$d$个人什么都有。现在规定只要有两个人有拍，一个人有球就能去打。问有多少种组合不能去打。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="组合" scheme="https://vincentxwd.github.io/blog/tags/%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>[HDOJ6418] Rikka with Stone-Paper-Scissors (纳什均衡)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/20/HDOJ6418-Rikka-with-Stone-Paper-Scissors/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/20/HDOJ6418-Rikka-with-Stone-Paper-Scissors/</id>
    <published>2018-08-20T13:48:02.000Z</published>
    <updated>2018-08-20T14:03:02.805Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6418" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6418</a></p><p><strong>A和B玩剪子石头布，每个人要出$n$步，现在给你它们剪子、石头、布分别出的次数，每赢一次，获胜方得一分。已知A会随机出，现在求B的分数的最大期望。</strong></p><a id="more"></a><p>一共玩$n$局，每一次出不同的手势，得分的概率和对方守中对应手势的数目有关系，直接把能赢和能输的概率加加减减就OK。证明涉及纳什均衡，JLS直播讲的也没太听懂orz。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL a,b,c,a1,b1,c1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;a1,&amp;b1,&amp;c1);</span><br><span class="line">    LL n = a + b + c;</span><br><span class="line">    LL m = -a*c1-b*a1-c*b1+a1*c+b1*a+c1*b;</span><br><span class="line">    <span class="keyword">if</span>(m % n == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, m / n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>, m/__gcd((LL)<span class="built_in">abs</span>(m),n), n/__gcd((LL)<span class="built_in">abs</span>(m),n));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6418&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=6418&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A和B玩剪子石头布，每个人要出$n$步，现在给你它们剪子、石头、布分别出的次数，每赢一次，获胜方得一分。已知A会随机出，现在求B的分数的最大期望。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="博弈" scheme="https://vincentxwd.github.io/blog/tags/%E5%8D%9A%E5%BC%88/"/>
    
      <category term="期望" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>[CF1025] Codeforces Round #504 (Div.1+Div.2)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/20/CF1025-Codeforces-Round-504-Div-1-Div-2/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/20/CF1025-Codeforces-Round-504-Div-1-Div-2/</id>
    <published>2018-08-20T05:16:51.000Z</published>
    <updated>2018-08-20T06:37:44.766Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1025" target="_blank" rel="noopener">http://codeforces.com/contest/1025</a></p><p><strong>这一场大家fst得都好惨啊。</strong></p><a id="more"></a><p>A：水题不多解释，注意$n=1$的时候输出Yes。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">222</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,s)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) vis[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(vis[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ok = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>有$n$个数对，让你找到一个大于1的数字，使得这个数字为这个$n$对数中任意一个数的因数。</strong></p><p>这个数一定是每一对数中某个数的因数，不妨建一个队列，把第一对中两个数的所有质因数去重后压到队里，看看队首的数是不是接下来的数对中任意一个数的因数。如果不是就出队，到最后看看有没有剩下数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">160600</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">  LL a, b;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    vis.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;a,&amp;b);</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= a; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a % j == <span class="number">0</span>) &#123;</span><br><span class="line">            q.push(j);</span><br><span class="line">            vis.insert(j);</span><br><span class="line">            <span class="keyword">while</span>(a % j == <span class="number">0</span>) a /= j;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        q.push(a);</span><br><span class="line">          vis.insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= b; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(b % j == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(vis.find(j) == vis.end()) &#123;</span><br><span class="line">          vis.insert(j);</span><br><span class="line">            q.push(j);</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">while</span>(b % j == <span class="number">0</span>) b /= j;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(vis.find(b) == vis.end()) &#123;</span><br><span class="line">          vis.insert(b);</span><br><span class="line">        q.push(b);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a % q.front() == <span class="number">0</span> || b % q.front() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!q.empty()) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, q.front());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>给你一个只有b和w两种字符的串s，希望让你通过一个操作获得尽可能长的bw交替的子串。这个操作是选中某一个位置切分，让两边都翻转。</strong></p><p>考虑这个操作的本质，两头翻转以后，原本在串两端的字符接到了一起，中间的到了两端。再选一个位置也是这样，那么实际上两头是可以通过这个操作接到一起的。于是我们把整个串看成一个环，找最长的不超过字符串本身长度的bw串就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150500</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)) &#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      s[i+n] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">2</span> * n) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'b'</span>) &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; <span class="number">2</span> * n &amp;&amp; s[i+<span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">          t++; i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(ret, t+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">2</span> * n) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'w'</span>) &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; <span class="number">2</span> * n &amp;&amp; s[i+<span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">          t++; i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(ret, t+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(n, ret));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：<strong>给你n个数，问你能不能构成一棵二叉排序树，并且每2个相邻节点之间的gcd不是1。</strong></p><p>首先想到了暴力枚举每一层的根节点，但是这样复杂度是$O(n^{logn})$的，显然不科学。</p><p>注意到一个点作为根的时候与它和它的儿子具体是谁有关系，我们考虑区间dp，维护$dp(i,j,k)$，表示$[i,j]$区间内的第$k$个数字能否做根，这个关系可以用bitset维护。</p><p>于是我们枚举长度和起止端点，特判端点作为根的时候能否成立，区间里面的数则直接枚举位置，看看这个k是否能分别做左右两棵树的根，如果能的话，直接给大区间做标记。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">707</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;maxn&gt; ok[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">bitset</span>&lt;maxn&gt; dp[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(a[i], a[j]) != <span class="number">1</span>) &#123;</span><br><span class="line">          ok[i][j] = ok[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((ok[i] &amp; dp[i+<span class="number">1</span>][j]).any()) &#123;</span><br><span class="line">          dp[i][j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((ok[j] &amp; dp[i][j<span class="number">-1</span>]).any()) &#123;</span><br><span class="line">          dp[i][j][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(dp[i][k][k] &amp;&amp; dp[k][j][k]) &#123;</span><br><span class="line">            dp[i][j][k] = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[<span class="number">1</span>][n]!=<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://codeforces.com/contest/1025&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1025&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这一场大家fst得都好惨啊。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="DP" scheme="https://vincentxwd.github.io/blog/tags/DP/"/>
    
      <category term="规律" scheme="https://vincentxwd.github.io/blog/tags/%E8%A7%84%E5%BE%8B/"/>
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>[BZOJ4017] 小Q的无敌异或（异或, 树状数组）</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/19/BZOJ4017-%E5%B0%8FQ%E7%9A%84%E6%97%A0%E6%95%8C%E5%BC%82%E6%88%96/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/19/BZOJ4017-小Q的无敌异或/</id>
    <published>2018-08-19T09:54:32.000Z</published>
    <updated>2018-08-19T17:25:41.493Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4017" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=4017</a></p><p><strong>（这是一道好题）给你n个数，分别问这n个数中任意两个区间的异或和的加和是多少、任意两个区间的和的异或和是多少。</strong></p><a id="more"></a><p><strong>Task 1：求异或的和</strong></p><p>针对第一问，我们首先分析出两个性质：</p><ol><li><strong>设$[1,i]$的异或和为$xor[i]$，那么区间$[l,r]$内数字的异或和为$xor[l-1]⨁xor[r]$。</strong></li><li><strong>某个在数字第k位有贡献的子区间$[l,r]$，它们的前缀异或和$xor[l]$与$xor[r]$的值一定不同。而且很显然，这个区间的贡献为$2^k$。</strong></li></ol><p>有上述的两个性质，我们的目标其实就是拆分数位，针对每个数位，找到整个$[1,n]$区间内有多少对前缀异或和结果不同。假设在$[1,n]$中的第$k$位数字有$x$个数该位是$1$，那么就有$n-x$个位置是$0$。这样只是找到了区间长度≥2的贡献，但是题目规定单个数字也算贡献，不妨再加上一个$x$，问题转化成在两个数字集合中分别挑选一个数字，问有多少对数字，因此第$k$位总体贡献是$x(n-x+1)2^k$。</p><p>实现就很简单，我们针对每一位$k$，求异或和的每一步时，更新这个$x$，最后算一下贡献就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">gao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cur ^= (a[i] &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(cur == <span class="number">1</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += cnt * (n - cnt + <span class="number">1</span>) % mod * (<span class="number">1L</span>L &lt;&lt; k) % mod;</span><br><span class="line">    ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Task 2：求和的异或</strong></p><p>考虑和第一问一样的做法，要求的答案为异或和，考虑这个和的第$k$位什么时候为$1$：当出现的在这一位为$1$时的区间$[l,r]$内数字之和为奇数个的时候贡献为$2^k$。</p><p>我们又能发现一个规律：当区间[l,r]的和的第k位是奇数时，有：<br>$$<br>(s[r]-s[l-1])\ mod \ 2^{k+1}\ ≥\ 2^k<br>$$<br>针对每一位$k$，我们可以预处理出来前i项的和$s[i]$，离散化这个$s$以后用树状数组维护每个位置$i$左右两侧是否满足上述条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;LL&gt; bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, LL v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i+=lowbit(i)) &#123;</span><br><span class="line">    bit[i] ^= v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i-=lowbit(i)) &#123;</span><br><span class="line">    ret ^= bit[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; s(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; h(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> id = [&amp;](LL cur) &#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(h.begin(), h.end(), cur) - h.begin() + <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++) &#123;</span><br><span class="line">    LL tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      h[i] = s[i] &amp; ((<span class="number">1L</span>L &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(h.begin(), h.end());</span><br><span class="line">    bit = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      LL cur = s[i] &amp; ((<span class="number">1L</span>L &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">      add(id(cur), <span class="number">1L</span>L);</span><br><span class="line">      tmp ^= sum(id(cur-(<span class="number">1L</span>L&lt;&lt;k))) ^ sum(id(cur+(<span class="number">1L</span>L&lt;&lt;k))) ^ sum(id(cur));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">1</span>) ret |= (<span class="number">1L</span>L &lt;&lt; k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个题，学到了要去讨论所求结果和计算过程的特点这样的思路。例如本题的两个问就是要针对区间内的异或和或答案的异或和中的每一位做讨论。</p><p>于是，遇到异或和考虑到先讨论一下每一位的贡献就对啦~</p><p>提交的时候报了CE，emmm懒得改就这样吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">998244353L</span>L;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cur ^= (a[i] &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(cur == <span class="number">1</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += cnt * (n - cnt + <span class="number">1</span>) % mod * (<span class="number">1L</span>L &lt;&lt; k) % mod;</span><br><span class="line">    ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, LL v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i+=lowbit(i)) &#123;</span><br><span class="line">    bit[i] ^= v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i-=lowbit(i)) &#123;</span><br><span class="line">    ret ^= bit[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; s(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; h(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> id = [&amp;](LL cur) &#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(h.begin(), h.end(), cur) - h.begin() + <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++) &#123;</span><br><span class="line">    LL tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      h[i] = s[i] &amp; ((<span class="number">1L</span>L &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(h.begin(), h.end());</span><br><span class="line">    bit = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      LL cur = s[i] &amp; ((<span class="number">1L</span>L &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">      add(id(cur), <span class="number">1L</span>L);</span><br><span class="line">      tmp ^= sum(id(cur-(<span class="number">1L</span>L&lt;&lt;k))) ^ sum(id(cur+(<span class="number">1L</span>L&lt;&lt;k))) ^ sum(id(cur));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">1</span>) ret |= (<span class="number">1L</span>L &lt;&lt; k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    a.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, gao1(), gao2());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=4017&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.lydsy.com/JudgeOnline/problem.php?id=4017&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（这是一道好题）给你n个数，分别问这n个数中任意两个区间的异或和的加和是多少、任意两个区间的和的异或和是多少。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="树状数组" scheme="https://vincentxwd.github.io/blog/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="异或" scheme="https://vincentxwd.github.io/blog/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>[CF1023] Codeforces Round #504(Div.1+Div.2)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/18/CF1023-Codeforces-Round-504-Div-1-Div-2/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/18/CF1023-Codeforces-Round-504-Div-1-Div-2/</id>
    <published>2018-08-18T03:45:42.000Z</published>
    <updated>2018-08-18T05:05:46.388Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1023" target="_blank" rel="noopener">http://codeforces.com/contest/1023</a></p><p><strong>我，七夕，掉分</strong></p><a id="more"></a><p>A：<strong>两个字符串，其中一个字符串里至多有个“*”表示任何字符都能匹配。问这两个字符串能不能匹配。</strong></p><p>从左到右扫两个字符串的相同前缀和后缀，然后看看是不是存在“*”以及两头不相接。据说这题被cha得很厉害啊？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s,t);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, t) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i] == t[j]) &#123;</span><br><span class="line">      i++,j++;tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = n - <span class="number">1</span>, q = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[p] == t[q]) &#123;</span><br><span class="line">      p--,q--;tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == p) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'*'</span> &amp;&amp; tot &lt;= m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>给你两个数$n$和$k$，问你$k$有多少能用不超过$n$的两个不同的数的和来表示，忽略顺序。</strong></p><p>设$k=x+y$，要满足$x≤n$、$y≤n$和$x≠y$。我们会发现，需要讨论$k≥2n$、$k≤n$和$n＜k＜2n$三个情况。前两个不必多说，第三个我们也是只需要统计从$\frac{k}{2}$数到$n$有多少个整数就行，因为总有$x＜\frac{k}{2}$和它对应。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k / <span class="number">2</span> &gt;= n) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= n) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, k % <span class="number">2</span> == <span class="number">0</span> ? k / <span class="number">2</span> - <span class="number">1</span> : k / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, n-k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>给定长为$n$的合法括号序列，让你求一个长为$k$的合法括号子序列。</strong></p><p>维护每一个下标为$i$的左括号对应的右括号下标$to[i]=j$，然后贪心地从左到右扫符合当前长度条件$k≥to[i]-i+1$的括号序列，每找到一堆符合条件的括号序列要更新$k$和$i$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> to[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">if</span>(n == k) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">    <span class="built_in">memset</span>(to, <span class="number">0</span>, <span class="keyword">sizeof</span>(to));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">        st.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> id = st.top(); st.pop();</span><br><span class="line">        to[i] = id; to[id] = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = k, i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; pos;</span><br><span class="line">    <span class="keyword">while</span>(tot) &#123;</span><br><span class="line">      <span class="keyword">if</span>(to[i] - i + <span class="number">1</span> &lt;= tot  &amp;&amp; to[i] - i + <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tot -= (to[i] - i + <span class="number">1</span>);</span><br><span class="line">        pos.emplace_back(i, to[i]);</span><br><span class="line">        i = to[i] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = pos[i].first; j &lt;= pos[i].second; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：<strong>原本有$n$个范围在$[1,q]$的数，定义染色操作$[l_i,r_i]$表示将$[l_i,r_i]$区间内的数字变为$i$，现在给你$n$个染色后的数字作为结果，其中含有数字$0$表示这里可以是任意数字，问你$q$次操作能不能把原本的序列变成这个序列。</strong></p><p>考虑到每次染色为一个区间，每个数字$i$仅能染色一次。那么在进行过一次染色操作后，这个区间内的数字必然不能比$i$小。</p><p>问题在于如何处理$0$，我们考虑有一个$0$在某个区间$[L,R]$内，且$a_L$与$a_R$相同，$[L,R]$中不存在除了$0$以外小于$a_L$的数字。那么我们可以将这个0置为相邻两侧数字中的任意一个，作为扩展那个数字的区间长度。</p><p>因此我们构造时只需要维护每一个数字的最右侧相同的那个数字，整个区间必然会被覆盖一次。然后用线段树维护区间最小值，存在有小于区间端点的数字时必然无法构造。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> r[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">int</span> seg[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  seg[rt] = min(seg[lrt], seg[rrt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    seg[rt] = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(l,m,lrt);</span><br><span class="line">  build(m+<span class="number">1</span>,r,rrt);</span><br><span class="line">  pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="keyword">return</span> seg[rt];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">  <span class="keyword">if</span>(m &gt;= L) ret = min(ret, query(L, R, l, m, lrt));</span><br><span class="line">  <span class="keyword">if</span>(m &lt; R) ret = min(ret, query(L, R, m+<span class="number">1</span>, r, rrt));</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(r));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">      r[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!r[q]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!r[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> a[r[<span class="number">0</span>]] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="number">0</span>) a[i] = a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="number">0</span>) a[i] = a[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">    build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> tmp;</span><br><span class="line">      <span class="keyword">if</span>(!r[a[i]]) <span class="keyword">continue</span>;</span><br><span class="line">      tmp = query(i, r[a[i]], <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(tmp &lt; a[i]) &#123;</span><br><span class="line">        ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, a[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://codeforces.com/contest/1023&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1023&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我，七夕，掉分&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="规律" scheme="https://vincentxwd.github.io/blog/tags/%E8%A7%84%E5%BE%8B/"/>
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="构造" scheme="https://vincentxwd.github.io/blog/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="线段树" scheme="https://vincentxwd.github.io/blog/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[Hackerrank] CodeKnight 1.0 A-D题解（线段树, 二分, 组合计数, 尺取）</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/16/Hackerrank-CodeKnight-1-0-A-D%E9%A2%98%E8%A7%A3/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/16/Hackerrank-CodeKnight-1-0-A-D题解/</id>
    <published>2018-08-16T13:59:42.000Z</published>
    <updated>2018-08-16T14:18:21.516Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://www.hackerrank.com/contests/codeknight-1/challenges" target="_blank" rel="noopener">https://www.hackerrank.com/contests/codeknight-1/challenges</a></p><p><strong>这些题好蛋疼啊。。。。</strong></p><a id="more"></a><p>Magical Cards：<strong>给你一个整数$n$，问你有多少种拆分方法，将这个数拆成素数的乘积。</strong></p><p>首先将这个数分解质因数，并记下每个素因数的个数$c[i]$以及一共有多少个素因数$tot$，问题转化成将这$tot$个素因数有多少种排列方式了。直接考虑每一类素因数$p[i]$要在$tot$个位置中占据$c[i]$个位置，每一种素因数的排放实际上是相互独立的。则位置有$C_{tot}^{p[i]}$种，剩下$tot-p[i]$个空位下一个质因数再放就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line">LL f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    f[<span class="number">1</span>] = f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) f[i] = f[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        LL m = n, tot = <span class="number">0</span>;</span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt++; n /= i;</span><br><span class="line">                    tot++;</span><br><span class="line">                &#125;</span><br><span class="line">                c.emplace_back(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            c.emplace_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LL ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">            ret = f[tot] / f[c[i]] / f[tot-c[i]] * ret;</span><br><span class="line">            tot -= c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shubham and Subarrays：<strong>给你n个数，和一个整数k。让你求有多少个子区间的乘积为k。</strong></p><p>考虑这样的区间问题首先想到尺取，但是仅尺取还不够。考虑k=1的情况，假如有连续的1存在（如：1 1 1 1），那么实际上有6种（$\frac{3×(3+1)}{2}$）。特殊处理掉这个情况，剩下的再计算乘积恰好为k时，左右两个指针外部的1的贡献就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL k, x[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;PLL&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">    v.clear(); v.emplace_back(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x[i]);</span><br><span class="line">      <span class="keyword">if</span>(x[i] != <span class="number">1</span>) &#123;</span><br><span class="line">        v.emplace_back(x[i], i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v.emplace_back(<span class="number">0</span>, n);</span><br><span class="line">    LL one = <span class="number">0</span>, ret = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">      cur = v[i].second - v[i<span class="number">-1</span>].second;</span><br><span class="line">      one += (cur - <span class="number">1</span>) * cur / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, one);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; v.size() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(cur * v[r].first == k) &#123;</span><br><span class="line">        cur *= v[r].first;</span><br><span class="line">        r++;</span><br><span class="line">        ret += (v[r].second - v[r<span class="number">-1</span>].second) * (v[l].second - v[l<span class="number">-1</span>].second);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(cur * v[r].first &lt; k) &#123;</span><br><span class="line">        cur *= v[r].first;</span><br><span class="line">        r++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(cur * v[r].first &gt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) l++, r++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          cur /= v[l].first;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chef and Cakes：这题太水，不多说了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        vis.clear();</span><br><span class="line">        <span class="keyword">int</span> x, a = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            vis[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : vis) &#123;</span><br><span class="line">            a = max(a, x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, vis.size(), a);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Domino’s：<strong>n个多米诺骨牌，每个骨牌的位置为$x_i$，高度为$h_i$，每个骨牌向右倒下能砸到$[x+1,x+h-1]$范围的骨牌。现在让你统计每一个骨牌从它的位置向右倒下后能砸倒多少骨牌（多米诺骨牌后面的骨牌被砸倒还会影响到后面的）。</strong></p><p>我们给n个多米诺骨牌按$x_i$排序后发现，由于最右边的骨牌倒下的影响只有自己，即为1，于是我们考虑从右往左开始处理：设我们骨牌的结果为$dp_i$，每当处理到第$i$个骨牌时，我们单张骨牌砸中的范围为$[x_i+1,x_i+h_i-1]$，我们对再它右边的骨牌中找到能砸中骨牌最多的那张牌即可（当然这里也有递推关系）。使用线段树维护每一个骨牌的dp值，每次查询的时候首先二分$[x_i+1,x_i+h_i-1]$（即受到当前骨牌影响的骨牌）中的下标$aim$，然后在线段树上查询$[pos+1, aim]$内dp值最大的下标id$，对于每一个骨牌$i$，答案为这个骨牌右边的dp值+这个骨牌左边至$i$骨牌中的骨牌数量$id-pos-1+dp$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">using</span> Node = struct &#123;</span><br><span class="line">  LL x, h, id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Node p[maxn];</span><br><span class="line">LL dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line">LL seg[maxn&lt;&lt;<span class="number">4</span>], id[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(LL rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(seg[lrt] &gt; seg[rrt]) &#123;</span><br><span class="line">    seg[rt] = seg[lrt];</span><br><span class="line">    id[rt] = id[lrt];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    seg[rt] = seg[rrt];</span><br><span class="line">    id[rt] = id[rrt];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(LL l, LL r, LL rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    seg[rt] = <span class="number">1</span>;</span><br><span class="line">    id[rt] = l;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LL m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(l, m, lrt);</span><br><span class="line">  build(m+<span class="number">1</span>, r, rrt);</span><br><span class="line">  pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(LL x, LL p, LL l, LL r, LL rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    seg[rt] = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LL m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(p &lt;= m) update(x, p, l, m, lrt);</span><br><span class="line">  <span class="keyword">else</span> update(x, p, m+<span class="number">1</span>, r, rrt);</span><br><span class="line">  pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PLL <span class="title">query</span><span class="params">(LL L, LL R, LL l, LL r, LL rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="keyword">return</span> make_pair(seg[rt], id[rt]);</span><br><span class="line">  &#125;</span><br><span class="line">  LL m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  PLL ret = make_pair(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= m) &#123;</span><br><span class="line">    ret = max(ret, query(L, R, l, m, lrt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(R &gt; m) &#123;</span><br><span class="line">    ret = max(ret, query(L, R, m+<span class="number">1</span>, r, rrt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(LL pos)</span> </span>&#123;</span><br><span class="line">  LL l = pos + <span class="number">1</span>, r = n;</span><br><span class="line">  LL hi = p[pos].x + p[pos].h - <span class="number">1</span>;</span><br><span class="line">  LL aim = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p[m].x &lt;= hi) &#123;</span><br><span class="line">      aim = m;</span><br><span class="line">      l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(aim == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  PLL id = query(pos+<span class="number">1</span>, aim, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> (id.second - pos - <span class="number">1</span>) + id.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="comment">// freopen("out", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].h;</span><br><span class="line">      p[i].id = i;</span><br><span class="line">      dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, [](Node a, Node b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.x == b.x ? a.h &lt; b.h : a.x &lt; b.x;</span><br><span class="line">    &#125;);</span><br><span class="line">    build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      dp[i] += gao(i);</span><br><span class="line">      update(dp[i], i, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; ret; ret.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ret[p[i].id] = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, ret[i], <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://www.hackerrank.com/contests/codeknight-1/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.hackerrank.com/contests/codeknight-1/challenges&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些题好蛋疼啊。。。。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Hackerrank" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Hackerrank/"/>
    
    
      <category term="二分" scheme="https://vincentxwd.github.io/blog/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="线段树" scheme="https://vincentxwd.github.io/blog/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="组合" scheme="https://vincentxwd.github.io/blog/tags/%E7%BB%84%E5%90%88/"/>
    
      <category term="计数" scheme="https://vincentxwd.github.io/blog/tags/%E8%AE%A1%E6%95%B0/"/>
    
      <category term="尺取" scheme="https://vincentxwd.github.io/blog/tags/%E5%B0%BA%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>[HDOJ3501] Calculation 2 (容斥 or 欧拉函数)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/13/HDOJ3501-Calculation-2-%E5%AE%B9%E6%96%A5-or-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/13/HDOJ3501-Calculation-2-容斥-or-欧拉函数/</id>
    <published>2018-08-13T15:24:19.000Z</published>
    <updated>2018-08-13T15:45:28.597Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3501" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=3501</a></p><p><strong>求一个数n的所有小于它并且与它不互质的数的和。</strong></p><a id="more"></a><p>打算复习一波欧拉函数的，结果这题发现可以容斥。</p><p>我们知道如果一个数$n$含有因数$x$，那么$x$的倍数都和$n$不互质，且质因数至少为$x$。</p><p>我们可以知道，对于任意小于$n$的因数$x$，对本题的贡献为$x+2x+3x+…+kx=\frac{k(k+1)}{2}x$，其中$k$为$n$对$x$的倍数。</p><p>于是直接对$n$分解因数，再容斥。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LL ret = exgcd(b, a%b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span> </span>&#123;</span><br><span class="line">  LL x, y;</span><br><span class="line">  exgcd(a, mod, x, y);</span><br><span class="line">  <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r" ,stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">    LL t = n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; p;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(n % i == <span class="number">0</span>) p.push_back(i);</span><br><span class="line">      <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) p.push_back(n);</span><br><span class="line">    <span class="keyword">int</span> nn = <span class="number">1</span> &lt;&lt; p.size();</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nn; i++) &#123;</span><br><span class="line">      LL tmp = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.size(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">          tmp *= p[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      LL cnt = t / tmp;</span><br><span class="line">      tmp = cnt * (cnt - <span class="number">1</span>) % mod * inv(<span class="number">2</span>) % mod * tmp % mod;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(__builtin_popcount(i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ret += tmp; ret %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ret -= tmp; ret += mod; ret %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来考虑欧拉函数，知道一个定理：小于$n$的数，且与$n$互质的数的和为：<br>$$<br>\frac{\phi(n)×n}{2}<br>$$<br>然而小于$n$的数的和为$\frac{n(n-1)}{2}$，于是我们一减：<br>$$<br>\frac{n(n-1-\phi(n))}{2}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r" ,stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">    LL ret = n, t = n;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(n % i == <span class="number">0</span>) ret = ret / i * (i<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) ret = ret / n * (n<span class="number">-1</span>);</span><br><span class="line">    LL p = t * (t - <span class="number">1</span> - ret) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3501&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=3501&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;求一个数n的所有小于它并且与它不互质的数的和。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
    
      <category term="数学" scheme="https://vincentxwd.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="容斥" scheme="https://vincentxwd.github.io/blog/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>[HDOJ6395] Sequence (反演思想，整除分块，矩阵快速幂)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/13/HDOJ6395-Sequence-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%EF%BC%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/13/HDOJ6395-Sequence-整除分块，矩阵快速幂/</id>
    <published>2018-08-13T12:57:01.000Z</published>
    <updated>2018-08-13T13:03:01.936Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6395" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6395</a></p><p><strong>就算个式子。</strong></p><a id="more"></a><p>这题关键在于如何处理后面的下取整分式，会发现如何构造这个矩阵都不太好弄这个式子。知道一点莫比乌斯反演，考虑到了按照整除结果对取整式进行分块，每一块单独跑块长次矩阵快速幂，然后累计到结果上就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  LL m[maxn][maxn];</span><br><span class="line">  LL r;</span><br><span class="line">  LL c;</span><br><span class="line">  Matrix()&#123;</span><br><span class="line">    r = c = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">  &#125; </span><br><span class="line">&#125; Matrix;</span><br><span class="line"><span class="function">Matrix <span class="title">mul</span><span class="params">(Matrix m1, Matrix m2)</span> </span>&#123;</span><br><span class="line">  Matrix ret = Matrix();</span><br><span class="line">  ret.r = m1.r; ret.c = m2.c;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= m1.r; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(LL j = <span class="number">1</span>; j &lt;= m2.r; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(LL k = <span class="number">1</span>; k &lt;= m2.c; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m2.m[j][k] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ret.m[i][k] = (ret.m[i][k] + (m1.m[i][j] * m2.m[j][k]) % mod) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">quickmul</span><span class="params">(Matrix m, LL n)</span> </span>&#123;</span><br><span class="line">  Matrix ret = Matrix();</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= m.r; i++) ret.m[i][i]  = <span class="number">1</span>;</span><br><span class="line">  ret.r = m.r;</span><br><span class="line">  ret.c = m.c;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = mul(m, ret);</span><br><span class="line">    m = mul(m, m);</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL a, b, c, d, p, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">  Matrix mat, ret;</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;p,&amp;n);</span><br><span class="line">    mat.r = mat.c = <span class="number">3</span>;</span><br><span class="line">    ret.r = <span class="number">3</span>; ret.c = <span class="number">1</span>;</span><br><span class="line">    mat.m[<span class="number">1</span>][<span class="number">1</span>] = d, mat.m[<span class="number">1</span>][<span class="number">2</span>] = c;</span><br><span class="line">    mat.m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>; mat.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    mat.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    ret.m[<span class="number">1</span>][<span class="number">1</span>] = b; ret.m[<span class="number">2</span>][<span class="number">1</span>] = a; ret.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">3</span>; i &lt;= n; i=p/(p/i)+<span class="number">1</span>) &#123;</span><br><span class="line">        mat.m[<span class="number">1</span>][<span class="number">1</span>] = d, mat.m[<span class="number">1</span>][<span class="number">2</span>] = c;</span><br><span class="line">        mat.m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>; mat.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        mat.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        mat.m[<span class="number">1</span>][<span class="number">3</span>] = (p / i);</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= p / (p/i)) mat = quickmul(mat, n-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> mat = quickmul(mat, p/(p/i)+<span class="number">1</span>-i);</span><br><span class="line">        ret = mul(mat, ret);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret.m[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">3</span>; i &lt;= p; i=p/(p/i)+<span class="number">1</span>) &#123;</span><br><span class="line">      mat.m[<span class="number">1</span>][<span class="number">1</span>] = d, mat.m[<span class="number">1</span>][<span class="number">2</span>] = c;</span><br><span class="line">      mat.m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>; mat.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">      mat.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">      mat.m[<span class="number">1</span>][<span class="number">3</span>] = (p / i);</span><br><span class="line">      mat = quickmul(mat, p/(p/i)+<span class="number">1</span>-i);</span><br><span class="line">      ret = mul(mat, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    mat.m[<span class="number">1</span>][<span class="number">1</span>] = d, mat.m[<span class="number">1</span>][<span class="number">2</span>] = c;</span><br><span class="line">    mat.m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>; mat.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    mat.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    mat.m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0L</span>L;</span><br><span class="line">    mat = quickmul(mat, n-max(p, <span class="number">2L</span>L));</span><br><span class="line">    ret = mul(mat, ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret.m[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6395&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=6395&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就算个式子。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018杭电多校" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="矩阵快速幂" scheme="https://vincentxwd.github.io/blog/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="分块" scheme="https://vincentxwd.github.io/blog/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>[HDOJ6386] Age of Moyu (最短路)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/13/HDOJ6386-Age-of-Moyu-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/13/HDOJ6386-Age-of-Moyu-最短路/</id>
    <published>2018-08-13T12:56:35.000Z</published>
    <updated>2018-08-13T13:00:20.975Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6386" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6386</a></p><p><strong>意思就是地铁换乘，问你怎么坐，换乘次数最少</strong></p><a id="more"></a><p>这题数据水了，我的代码放过去去了。正解应该是维护到点的每个最短的距离的线路，然后更新的时候从这个线路中去找有没有存在的。我这里只是维护了最短路的上一个线路（看来是没有二条以上路径相同但是线路不同的数据），最后正着倒着各跑一次dijkstra取min的。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;LL, LL, LL&gt; TP;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  LL v, w, next;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxm = <span class="number">2001000</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">LL n, m, ee;</span><br><span class="line">LL d[maxn];</span><br><span class="line">LL head[maxn];</span><br><span class="line">Edge e[maxm];</span><br><span class="line">priority_queue&lt;TP, <span class="built_in">vector</span>&lt;TP&gt;, greater&lt;TP&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ee = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(LL u, LL v, LL w)</span> </span>&#123;</span><br><span class="line">  e[ee].v = v; e[ee].w = w; e[ee].next = head[u]; head[u] = ee++;</span><br><span class="line">  e[ee].v = u; e[ee].w = w; e[ee].next = head[v]; head[v] = ee++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dijkstra</span><span class="params">(LL s, LL t)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">  d[s] = <span class="number">0</span>;</span><br><span class="line">  LL pre_cost, pre_id, from;</span><br><span class="line">  pq.push(TP(<span class="number">0</span>, <span class="number">-1</span>, s));</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    tie(pre_cost, pre_id, from) = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(d[from] &lt; pre_cost) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = head[from]; ~i; i=e[i].next) &#123;</span><br><span class="line">      LL v = e[i].v, w = e[i].w;</span><br><span class="line">      LL cost, cur_id;</span><br><span class="line">      <span class="keyword">if</span>(w == pre_id) &#123;</span><br><span class="line">        cost = <span class="number">0</span>; cur_id = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        cost = <span class="number">1</span>; cur_id = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cost + d[from] &lt; d[v]) &#123;</span><br><span class="line">        d[v] = cost + d[from];</span><br><span class="line">        pq.push(TP(d[v], cur_id, v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">find</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == d[x] ? x : d[x] = find(d[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v, w;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      d[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d%I64d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      d[find(u)] = find(v);</span><br><span class="line">      adde(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(find(<span class="number">1</span>) != find(n)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, min(dijkstra(n, <span class="number">1</span>), dijkstra(<span class="number">1</span>, n)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6386&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=6386&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;意思就是地铁换乘，问你怎么坐，换乘次数最少&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018杭电多校" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="最短路" scheme="https://vincentxwd.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>2018百度之星-初赛（B）ADF题解</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/12/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E5%88%9D%E8%B5%9B%EF%BC%88B%EF%BC%89ADF%E9%A2%98%E8%A7%A3/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/12/2018百度之星-初赛（B）ADF题解/</id>
    <published>2018-08-12T13:11:30.000Z</published>
    <updated>2018-08-12T13:20:01.675Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826</a></p><p>只会签到。。。</p><a id="more"></a><p>A： 因为无限添加，考虑先把另外一些树加到这个点上，再把其他子树的叶子加到某一个点上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; pre[find(x)] = find(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T, u, v;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) pre[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      in[u]++, in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      ret = max(ret, in[i]+n-in[i]<span class="number">-1</span>-max(<span class="number">0</span>, m-in[i]-k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：这题直接二分答案，即最小的那个数字。然后按照这个数字来划分是加还是减，保证加的次数的2倍比减的次数多就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">300200</span>;</span><br><span class="line">LL n;</span><br><span class="line">LL x[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(LL mid)</span> </span>&#123;</span><br><span class="line">  LL a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x[i] &gt; mid+<span class="number">1</span>) &#123;</span><br><span class="line">      b += (x[i] - mid) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> a += max(<span class="number">0L</span>L, mid-x[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  b &gt;= a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x+<span class="number">1</span>, x+n+<span class="number">1</span>);</span><br><span class="line">    LL lo = <span class="number">0</span>, hi = <span class="number">1E9</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">      LL mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(gao(mid)) &#123;</span><br><span class="line">        lo = mid + <span class="number">1</span>;</span><br><span class="line">        ret = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        hi = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F：因为$x_i$和$y_i$不会存在重复的，那么直接垂直接到最近的边上就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL mx, my, q, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; mx &gt;&gt; my &gt;&gt; q;</span><br><span class="line">      LL ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">          LL tmp = x &lt; mx - x ? x : mx - x;</span><br><span class="line">          <span class="keyword">if</span>(x &lt; mx - x) tmp = x;</span><br><span class="line">          <span class="keyword">else</span> tmp = mx - x;</span><br><span class="line">          <span class="keyword">if</span>(tmp &gt;= y) tmp = y;</span><br><span class="line">          <span class="keyword">if</span>(tmp &gt;= my - y) tmp = my - y;</span><br><span class="line">          ret += tmp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只会签到。。。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="HDOJ" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/"/>
    
      <category term="2018百度之星" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/HDOJ/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F/"/>
    
    
      <category term="二分" scheme="https://vincentxwd.github.io/blog/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="规律" scheme="https://vincentxwd.github.io/blog/tags/%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>[CF1020A-C] Codeforces Round #503 (Div.2)</title>
    <link href="https://vincentxwd.github.io/blog/2018/08/12/CF1020A-C-Codeforces-Round-503-Div-2/"/>
    <id>https://vincentxwd.github.io/blog/2018/08/12/CF1020A-C-Codeforces-Round-503-Div-2/</id>
    <published>2018-08-12T05:15:17.000Z</published>
    <updated>2018-08-12T05:25:18.404Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1020" target="_blank" rel="noopener">http://codeforces.com/contest/1020</a></p><p><strong>上分啦</strong></p><a id="more"></a><p>A：<strong>n个楼每个楼h层，在每栋楼的$[a,b]$层上都有一个横向的通道，可以从一个楼去任意楼。现在给你两个位置，问最少要走多少步。</strong></p><p>对两个位置和通道区间进行讨论，然后抠一下就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL n, h, a, b, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL ta, fa, tb, fb;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;h&gt;&gt;a&gt;&gt;b&gt;&gt;k) &#123;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;ta&gt;&gt;fa&gt;&gt;tb&gt;&gt;fb;</span><br><span class="line">      LL ret = (LL)<span class="built_in">abs</span>(ta - tb);</span><br><span class="line">      <span class="keyword">if</span>(ta == tb) &#123;</span><br><span class="line">        ret += (LL)<span class="built_in">abs</span>(fa - fb);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa &gt; b &amp;&amp; fb &gt; b) &#123;</span><br><span class="line">          ret += (fa + fb - <span class="number">2L</span>L * b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fa &lt; a &amp;&amp; fb &lt; a) &#123;</span><br><span class="line">          ret += (<span class="number">2L</span>L * a - fa - fb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ret += (LL)<span class="built_in">abs</span>(fa - fb);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>意思就是让你从每个人出发找第一个遍历2次的点。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  dfs(p[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(p ,<span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">      p[i] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">      dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>n个人要给m个政党投票，每个人都有自己的投票目标以及花钱收买他的代价。现在希望让1号政党的票数超过其他所有政党的票数，问你至少要花多少钱。</strong></p><p>考虑贪心地选花费最少的，但是直接这样选相当于确定了收买人数，实际上可以买某一个政党的一些票就可以减少收买人数。于是我们考虑枚举1号政党的目标票数，超过该票数的政党则购买所有最少价格的差票，如果还不足我们的目标票数则从剩下的票里选最便宜的买。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3030</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, W;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">int</span> p[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(<span class="keyword">int</span> vote)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  tmp.clear();</span><br><span class="line">  <span class="keyword">int</span> need = vote - W;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[i].size() &gt;= vote) &#123;</span><br><span class="line">      id = f[i].size() - vote + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id &gt; need) <span class="keyword">return</span> <span class="number">1E18</span>;</span><br><span class="line">    need -= id;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; id; j++) &#123;</span><br><span class="line">      ret += f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = id; j &lt; f[i].size(); j++) &#123;</span><br><span class="line">      tmp.push_back(f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(tmp.begin(), tmp.end());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; need; i++) &#123;</span><br><span class="line">    ret += tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i],&amp;w[i]);</span><br><span class="line">      f[p[i]].push_back(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      sort(f[i].begin(), f[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">1E18</span>;</span><br><span class="line">    W = f[<span class="number">1</span>].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = W; i &lt;= n; i++) &#123;</span><br><span class="line">      ret = min(ret, gao(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;http://codeforces.com/contest/1020&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/1020&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上分啦&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://vincentxwd.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="贪心" scheme="https://vincentxwd.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="dfs" scheme="https://vincentxwd.github.io/blog/tags/dfs/"/>
    
  </entry>
  
</feed>
