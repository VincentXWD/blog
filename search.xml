<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>再见2018</title>
      <link href="/blog/2019/01/20/goodbye-2018/"/>
      <url>/blog/2019/01/20/goodbye-2018/</url>
      <content type="html"><![CDATA[<p><strong>这里只是很普通的个人2018年终总结，写在期末后，过年前。对于我来说，2018年绝对是我的一生中最不平凡的一年，是我人生轨迹发生重大转变的一年。</strong></p><a id="more"></a><p>我从来没有写过这样的回忆录，但是18年过得很不平常，不平常的事情总是希望自己永远记住，而把它们写下来是最好的方法。</p><h1 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h1><p>在2017年末，我同上百万人一样参加了全国硕士研究生统一招生考试，也就是俗称的考研。</p><p>虽然已经过去一年多了，但是我至今仍然很不愿意和别人讨论考研这个话题，每当有人跟我聊起考研，我总喜欢敷衍地打趣几句然后再玩几个自己觉得很有趣但是别人听不懂的梗，企图规避这个话题。因为我总是觉得自己很强，觉得考研那段时间自己和周围的人总是格格不入，于是产生了许多奇怪的不友好的想法，伤害了很多很多人包括我曾经的挚爱。</p><p>这一年来我从来没有认真地回忆过这三个月的考研经历（虽然现在也不想），不是因为复习多么单调多么辛苦不愿多提，而是在逃避自己那时候的不成熟对他人造成伤害的心理谴责。我把这段简短的总结写在最前面希望让自己永远不要再像以前一样急躁和爱迁怒于人。</p><h1 id="从北信科到计算所"><a href="#从北信科到计算所" class="headerlink" title="从北信科到计算所"></a>从北信科到计算所</h1><p>上半年考完研后开始忙毕业和所里的工作，算是从本科生到硕士生的一个过渡。我在所里认识了无论性格人品还是学术技术都超棒的师兄师姐，我不得不承认在计算所的这段时间对我的个人成长帮助非常大，我学会了如何做科研，如何去分析一个问题，以及面对一个问题应该怎么样去尝试解决。</p><p>我在这里完成了我的本科毕业论文。说来惭愧，我花了接近半年的时间才做完我的毕设，虽然时间很长，但是我真实觉得自己学到了很多东西。从一开始对图像处理和ML&amp;DL的一窍不通，到能够独立完成一个project和一篇论文，让我感觉自己几乎是恰好有了踏入科研的资格：我明白了在开始一个领域的研究之前一定要做足够多的调研，确保自己的工作不会重蹈覆辙；在分析问题时一定要考虑清楚这个问题的难点在什么地方，现在都有什么样的方法去克服这些难点，如果发现了没有人考虑到的问题或者是未曾有人解决过的难题，这或许就可能成为自己工作中的创新点；在做实验的时候一定要详细记录每一个实验的意义是什么（目的是为了解决什么问题、印证什么假设），并且要写清楚这个实验在整体系统上做了什么变动，期望的结果是什么，结果说明了什么，还要写清楚自己对结果的思考以及下一步的工作计划。实验中失败是非常常见的，只有在重复的试错中才有可能发现正确的结论（前提是自己的每一步都是经过深思熟虑的）。</p><p>同时这段时间我开始思考自己真正想要做的事情是什么，我意识到弄清楚自己的努力方向是多么重要，而要找到自己的目标不是一件容易的事情，最好的方法就是根据自己的兴趣一件又一件地去尝试。</p><h1 id="雁栖湖"><a href="#雁栖湖" class="headerlink" title="雁栖湖"></a>雁栖湖</h1><p>在雁栖湖的学习节奏很快，每一节课都会有很多很多听不懂的东西，所以在课后要下很多功夫。我的同学们都非常优秀，让我体会最深的还是大家对知识的一丝不苟的态度，对于一个问题或知识点，我的同学会思考很久并且确保自己完全弄明白以后才肯罢休。作为工程选手的我养成了许多的陋习，拿到一个东西很喜欢只了解它的IO，不关心它的机理，这对于做科研是很致命的缺点，而且我的性格是很急躁的，面对成片的公式很不愿意去推导。后来我尝试静下心来去推导一些公式时，发现在推导过程中也能学到很多东西。我现在才真正意识到自己应该静下心来做每一件事，好好磨一磨自己的急性子，遇到问题不要想当然。哎，明明都是小时候都应该知道的道理，结果到现在才真正意识到，果然以前是真的又菜又跳。</p><p>十月份完成了自己毕设相关的一篇论文，花了一个月的时间改了接近30稿才提交上去。这篇paper现在来看真的很水，但是毕竟花了时间写，也算是磨了自己的性格。</p><p>）PS：抱住了阳神的大腿完成了两门课的课设。</p><h1 id="新朋友"><a href="#新朋友" class="headerlink" title="新朋友"></a>新朋友</h1><p>国科大部分所的研一新生是在雁栖湖校区参加集中教学的，能认识来自353的舍友、计控704班等很多很多小伙伴们我真的感到非常开心。我感受到大家都是非常聪明的人，每个人真的都非常努力而且有自己的优势。我为能和大家成为同学而感到由衷的荣幸和自豪。</p><h1 id="ACM"><a href="#ACM" class="headerlink" title="ACM"></a>ACM</h1><p>ACM这个事情是很遗憾的，我本希望18年下半年能有机会继续打区域赛拿一块银牌，结果连资格都没有拿，后来发现硕士只有阳神他们队还有UCAS本科时的金牌爷去参赛，于是我释然了…</p><p>所以这一年没有什么成就，似乎顶多也就是kickstart拿到了a day with google还有google ai camp的入场券？</p><p>这一年依然没有拿到GCJ的T-shirt，依然没有上紫，依然有很多很多的知识点不懂和很多很多的题不会做…但是不知不觉算法竞赛已经不再是学习生活的全部了。我走进了一个更广阔的领域，遇到了新的问题，这迫使我去学习非常多的新知识。我看待这个领域就如同我看待算法竞赛一样，我不知道它最终会走向何方，也没有过多考虑自己付出的努力会获得怎样的回报。我只希望能凭借自己所学的知识解决一个又一个有趣又棘手问题，希望自己能够提出别人未曾发现的问题，希望自己能够在这个过程中获得快乐和满足。</p><h1 id="找实习"><a href="#找实习" class="headerlink" title="找实习"></a>找实习</h1><p>不是很想写这个的，担心被自己的老板看到2333。我在11、12月的时候面了很多公司的算法岗，全部都是一二线的互联网公司和AI独角兽公司，有内推也有自己砸简历，最终也是拿到了好几个offer。经过深思熟虑（实际是只参考了薪水）后决定去某血汗工厂（雾）。</p><p>我是在参加完a day with google之后才正式开始投简历找工作的，因为这个活动有一个HR帮忙改简历的环节，我就借机把自己的简历魔改了一把，发现真的有奇效。</p><p>此外，我发现和开发岗是有明显区别（废话）。</p><p>如果有朋友想了解更多的话可以给我发邮件，我个人认为还是有些参考价值的。</p><hr><p>太晚了先休息，感觉还有很多非学业的内容没有回忆到，有时间再写。</p>]]></content>
      
      <categories>
          
          <category> 只言片语 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[Good Bye 2018 D] New Year and the Permutation Concatenation（组合数学）</title>
      <link href="/blog/2018/12/31/cf1091d/"/>
      <url>/blog/2018/12/31/cf1091d/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1091/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/D</a><br>题意：给一个由字典序顺序的全排列拼接成的数列，问其中有多少个长度为$n$的连续子序列和为$\dfrac{n(n+1)}{2}$<br><a id="more"></a></p><p>长度为$n$的子序列和为$\dfrac{n(n+1)}{2}$的意思就是说有多少个连续子序列是$1$到$n$的全排列。</p><p>这题场上是找规律拆分贡献递推+OEIS过的，早上重新按照拆分贡献再推了一下，发现其实完全不需要OEIS。</p><p>首先分析一下答案的贡献：</p><ol><li>$n!$个原始排列的贡献。</li><li>两个排列相交的贡献。</li></ol><p>第1部分非常容易，答案就是$n!$. 关键是第二个部分。</p><p>例如$n=4$，手写几个看看规律（我写了$(n-1)!+1=3!+1$个排列的串，多1个是为了说明规律，后面的结果以此类推）：</p><p>1234 1243 1324 1342 1423 1432 2134…</p><p>我们从第一个排列的第2个数字开始，于是可能的排列是：</p><p>1 <strong>2341 2431 3241 3421 4231</strong> 4322 134 …</p><p>我们发现，两个相邻的排列是从第一个排列的第2个数字开始数的时候（也就是数到第二个排列的第1个数），前面$3!-1=5$对排列都是合法的，当1432遇到2134时则构造不出来（是4322）。</p><p>由于开头的数字可以是1、2、3、4任意一个，每一个数字的作为开头都有5个答案，于是这种构造对答案的贡献是$5\times4=20$.</p><p>同理，从第一个排列的第3个数字开始，可能的排列是：</p><p>12 <strong>3412</strong> 4313 <strong>2413</strong> 4214 <strong>2314</strong> 3221 34 …</p><p>从第4个数字开始就都不行了。</p><p>于是我们发现：<strong>每次选第一个数列的第$k+1$个数字作为开头时，必须保证这两个数列的第$k$个数字相同，这样才能保证构造出来的是一个排列，这样的k可以从1取到n-1。</strong></p><p>找到了这样的贡献分布，可是计算上是有点麻烦的。正难则反，考虑找到两个数列的第$k-1$个数字不同的排列对数。我们发现$k=1$时候，1、2、3、4开头合法的各5个，那么一共有20个；$k=2$时，合法的有12个。以此类推，我们发现，针对每一个$k$，对于答案的贡献是$n!-n(n-1)..(n-k-1)$，于是总的贡献就是：<br>$$<br>n\times n!-\sum_{k=1}^{n-1}\dfrac{n!}{k!}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL,LL&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010000</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">LL n;</span><br><span class="line">LL a[maxn], f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LL ret = exgcd(b, a%b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span> </span>&#123;</span><br><span class="line">  LL x, y;</span><br><span class="line">  exgcd(a, mod, x, y);</span><br><span class="line">  <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">  f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">    f[i] = i * f[i<span class="number">-1</span>] % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  LL ret = n * f[n] % mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    LL tmp = f[n] * inv(f[i]) % mod;</span><br><span class="line">    ret -= tmp; ret += mod; ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1092E] Minimal Diameter Forest（树直径，DFS）</title>
      <link href="/blog/2018/12/20/cf1092E/"/>
      <url>/blog/2018/12/20/cf1092E/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1092/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1092/problem/E</a><br><strong>给一个森林，问将这个森林连成一棵树使得新成的树直径最短。</strong><br><a id="more"></a></p><p>显然，对于森林里的每一棵树，都选各自直径的中点作为树根，全部连到直径最长的那棵树的中心上就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1111</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], vis[maxn], pre[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; root;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> L = u, R = u;</span><br><span class="line">  <span class="keyword">int</span> v, d, len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; id;</span><br><span class="line"></span><br><span class="line">  vis[u] = <span class="number">1</span>; dep[u] = <span class="number">0</span>;</span><br><span class="line">  id.emplace(u);</span><br><span class="line">  q.emplace(u);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    u = q.front(); q.pop();</span><br><span class="line">    id.emplace(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">      vis[v] = <span class="number">1</span>;</span><br><span class="line">      dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">      q.emplace(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : id) <span class="keyword">if</span>(dep[x] &gt; dep[L]) L = x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : id) &#123;</span><br><span class="line">    dep[x] = <span class="number">0</span>;</span><br><span class="line">    vis[x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">  vis[L] = <span class="number">1</span>;</span><br><span class="line">  q.emplace(L);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    u = q.front(); q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">      vis[v] = <span class="number">1</span>;</span><br><span class="line">      dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">      pre[v] = u;</span><br><span class="line">      q.emplace(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : id) <span class="keyword">if</span>(dep[x] &gt; dep[R]) R = x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : id) len = max(len, dep[x]);</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(pre[R] != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[R] == max(len/<span class="number">2</span>, len-len/<span class="number">2</span>)) &#123;</span><br><span class="line">      root.emplace_back(R, len);</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R = pre[R];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!flag) root.emplace_back(R, len);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m)) &#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">    root.clear();</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) gao(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rt = <span class="number">1</span>, len = <span class="number">-1</span>;</span><br><span class="line">    sort(root.begin(), root.end(), [](pii a, pii b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;);</span><br><span class="line">    rt = root[<span class="number">0</span>].first, len = root[<span class="number">0</span>].second;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : root) &#123;</span><br><span class="line">      <span class="keyword">if</span>(p.first == rt) <span class="keyword">continue</span>;</span><br><span class="line">      edge.emplace_back(rt, p.first);</span><br><span class="line">      G[rt].emplace_back(p.first);</span><br><span class="line">      G[p.first].emplace_back(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, gao(rt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : edge) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x.first, x.second);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1092D1&amp;D2] Tree with Maximum Cost（栈）</title>
      <link href="/blog/2018/12/19/cf1092D/"/>
      <url>/blog/2018/12/19/cf1092D/</url>
      <content type="html"><![CDATA[<p>题目链接：<br><a href="http://codeforces.com/contest/1092/problem/D1" target="_blank" rel="noopener">http://codeforces.com/contest/1092/problem/D1</a><br><a href="http://codeforces.com/contest/1092/problem/D2" target="_blank" rel="noopener">http://codeforces.com/contest/1092/problem/D2</a><br>题意：<br>希望用$2\times 1$的砖头搭出一面长为$n$并且每一个单位长度高度为$a_i$的墙，现在允许的操作是：<br>D1：横、竖都允许放<br>D2：只允许横着放<br>问是否能搭出指定高度的墙？<br><a id="more"></a></p><p>D1：可以贪心，由于当两个相邻的墙高度的奇偶性相同的时候，那么这两个墙可以看做一面墙，并且高度可以任意（允许任意+1）。于是我们考虑维护一个栈，从左到右贪心地判断当前墙是否与栈顶的墙高度的奇偶相同，如果相同则配对出栈，否则入栈等待与它配对的墙。当栈内为空或只有一个高度的时候（此时这个高度可以搭成比之前所有墙都高的情况，并且前面的墙总可以+1到这个高度），则说明可以搭出指定高度的墙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">      a[i] &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(st.empty()) &#123;</span><br><span class="line">        st.emplace(a[i]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(st.top() != a[i]) st.emplace(a[i]);</span><br><span class="line">      <span class="keyword">else</span> st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.size() &lt;= <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D2：考虑只允许横着放，那么只有在两个块一样高的时候才能+1. 于是考虑扫到每一个数的时候是否与栈顶这个数相同，如果相同的话则可以配对出栈；否则讨论一下大小：如果当前块比栈顶的高，那就不会再有机会更新到栈顶那个块，于是这种情况下是没有解的，否则还是有可能存在解的。有一个cha点在输出前，如果栈内存在元素那么这个块一定是最高的（其他所有块结对后+1直到这个块），否则是没有解的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">int</span> hi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">      hi = max(hi, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(st.empty()) &#123;</span><br><span class="line">        st.emplace(a[i]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(st.top() == a[i]) st.pop();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(st.top() &lt; a[i]) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> st.emplace(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.empty()) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.size() == <span class="number">1</span> &amp;&amp; st.top() == hi) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1092F] Tree with Maximum Cost（树DP）</title>
      <link href="/blog/2018/12/19/cf1092F/"/>
      <url>/blog/2018/12/19/cf1092F/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1092/problem/F" target="_blank" rel="noopener">http://codeforces.com/contest/1092/problem/F</a><br><strong>寻找一个点，使得这个点到其他所有点的距离乘点权的和最大。</strong><br><a id="more"></a></p><p>考虑把点权和*距离拆分成两部分，一部分是当前点的所有子孙到当前点的距离，另一部分是其余点到当前点的距离。固定一个树根，第一部分可以dfs一遍更新过来，维护当前距离和以及所有点的权值和，每次更新时去掉当前点的权值。</p><p>第二部分由某点的父亲节点更新过来，稍微计算一下计数的公式就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">200200</span>;</span><br><span class="line">LL n;</span><br><span class="line">LL a[maxn], tot1[maxn], tot2[maxn];</span><br><span class="line">LL dp1[maxn], dp2[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(LL u, LL p)</span> </span>&#123;</span><br><span class="line">tot1[u] = a[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line"><span class="keyword">if</span>(p == v) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(v, u);</span><br><span class="line">tot1[u] += tot1[v];</span><br><span class="line">dp1[u] += dp1[v] + tot1[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(LL u, LL p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p != <span class="number">-1</span>) &#123;</span><br><span class="line">tot2[u] = tot2[p] + tot1[p] - tot1[u];</span><br><span class="line">dp2[u] = dp1[p] - dp1[u] - tot1[u] + dp2[p] + tot2[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line"><span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(v, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n)) &#123;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;a[i]);</span><br><span class="line">  G[i].clear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(tot1, <span class="number">0</span>, <span class="keyword">sizeof</span> tot1);</span><br><span class="line">  <span class="built_in">memset</span>(tot2, <span class="number">0</span>, <span class="keyword">sizeof</span> tot2);</span><br><span class="line">  <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span> dp1);</span><br><span class="line">  <span class="built_in">memset</span>(dp2, <span class="number">0</span>, <span class="keyword">sizeof</span> dp2);</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%I64d %I64d"</span>, &amp;u, &amp;v);</span><br><span class="line">  G[u].emplace_back(v);</span><br><span class="line">  G[v].emplace_back(u);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs1(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt;dp1[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  ret = max(ret, dp1[i]+dp2[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用JS实现UCAS半自动评教脚本</title>
      <link href="/blog/2018/12/15/ucas-pingjiao/"/>
      <url>/blog/2018/12/15/ucas-pingjiao/</url>
      <content type="html"><![CDATA[<p>自用，同学们有需要的话也可以拿去用。</p><p>打开你的评教页面，chrome按F12调出“检查”，打开Console选项后将下面代码粘贴并回车，保存退出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> td = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'td'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; td.length;i++) &#123;</span><br><span class="line">td[i].getElementsByTagName(<span class="string">"input"</span>)[<span class="number">0</span>].checked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">"input[name='starFlag']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"checked"</span>,<span class="string">"checked"</span>);</span><br><span class="line">$(<span class="string">"textarea[id='merit']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"value"</span>,<span class="string">"课程特色鲜明，内容取舍合理，组织严密，逻辑性强。重点突出，难点讲解清楚。拓展学生知识面，培养分析能力，引导创新。"</span>);</span><br><span class="line">$(<span class="string">"textarea[id='flaw']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"value"</span>,<span class="string">"无"</span>);</span><br><span class="line">$(<span class="string">"textarea[id='suggest']"</span>).eq(<span class="number">0</span>).attr(<span class="string">"value"</span>,<span class="string">"无"</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1084D] The Fair Nut and the Best Path（树DP）</title>
      <link href="/blog/2018/12/11/cf1084d/"/>
      <url>/blog/2018/12/11/cf1084d/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1084/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1084/problem/D</a></p><p><strong>有一棵树，每一个点和边都有权值。一个人希望从一个点走到另一个点，要求在走的过程中点权和不小于边权和。求最大的点权和与边权和之差。</strong></p><a id="more"></a><hr><p>首先可以知道的是，如果两个点之间是任意可达的话，那么走这两个点的时候点权和与边权和之差一定比只选中单个点更大；如果两个点中有一个点比边权小，那选最大的那一个点的收益一定会比全选要更大。</p><p>所以实际上不需要考虑某一个点到另一个点不可达的情况，因为反过来即使可达那也不会是最优的，因此实际上路径是没有必要考虑逆方向的。</p><p>根据上述规则，就可以确定考虑将答案拆成两种：</p><p>一种是当前点为端点的一条链的情况，这种情况需要维护随后可以走的差值最大的链。</p><p>另一种是以当前点为中间点，分别从两个子树中走过来的情况，这时候需要同时维护差值最大和次大的链。</p><p>于是我们相当于是在选转折点，这个并且在这个转折点上选两个权值和最大的子链，使得点权和-边权和最大。就有个问题了，选子链的时候，都是从子链走向转折点，而题目中实际上是应该有一个子链走向转折点，而另一个子链是转折点走过去的。考虑最大连续子序列和，当扫到&lt;0的前缀和时，那么会把当前的dp值设为0，和这个问题实际上是一样的，因此不需要考虑方向的问题了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300300</span>;</span><br><span class="line">LL dp1[maxn], dp2[maxn], d[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  dp1[u] = <span class="number">0</span>, dp2[u] = <span class="number">0</span>;</span><br><span class="line">  LL a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : G[u]) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = x.first, w = x.second;</span><br><span class="line">    <span class="keyword">if</span>(p == v) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    <span class="keyword">if</span>(dp1[v] - w &gt; a) &#123;</span><br><span class="line">      b = a;</span><br><span class="line">      a = dp1[v] - w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dp1[v] - w &gt; b) &#123;</span><br><span class="line">      b = dp1[v] - w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dp1[u] = max(dp1[u], a+d[u]);</span><br><span class="line">  dp2[u] = max(dp2[u], a+b+d[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;d[i]);</span><br><span class="line">      G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span> dp1);</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">0</span>, <span class="keyword">sizeof</span> dp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v, w;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      G[u].emplace_back(v, w);</span><br><span class="line">      G[v].emplace_back(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ret = max(ret, dp2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[BZOJ4017] [Noi2008]志愿者招募（单纯形法）</title>
      <link href="/blog/2018/12/09/bzoj1061/"/>
      <url>/blog/2018/12/09/bzoj1061/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1061" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=1061</a><br>申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要N 天才能完成，其中第i 天至少需要Ai 个人。 布布通过了解得知，一共有M 类志愿者可以招募。其中第i 类可以从第Si 天工作到第Ti天，招募费用是每人Ci 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。</p><a id="more"></a><hr><p>学习了一个学长的博客，真的很棒：<a href="https://www.hrwhisper.me/introduction-to-simplex-algorithm/" target="_blank" rel="noopener">https://www.hrwhisper.me/introduction-to-simplex-algorithm/</a></p><p>首先这题一定是规划问题，我们根据题意列出优化方程。比如测试样例：</p><p>3 3<br>2 3 4<br>1 2 2<br>2 3 5<br>3 3 2</p><p>我们设第$i$类志愿者招$x_i$个，那么目标是：<br>$$<br>\min 2x_1+5x_2+2x_3<br>$$<br>需要满足：<br>$$<br>x_1\geq 2<br>$$</p><p>$$<br>x_1+x_2\geq 3<br>$$</p><p>$$<br>x_2+x_3\geq 4<br>$$</p><p>对于这类$\min (CX); s.t.\ AX\geq Y$的问题，其对偶问题是：<br>$$<br>\max (YX’);s.t.\ A^TX’\leq C<br>$$<br>然后就会发现这个形式跟输入的格式完全一致了。</p><p>PS：至于为什么这个问题的线性规划一定保证是整数解，因为我们构造的矩阵是全幺模矩阵，有人出现则是1，不出现则是0，由全幺模矩阵的一个定理：对于任何整数向量b，方程组A的所有基本解为整数向量的充分条件是A为幺模矩阵。所以我们可以使用单纯形法解决这个整数规划问题。</p><p>套下模版。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Simplex &#123;</span><br><span class="line">  <span class="comment">// s.t. ax≤b</span></span><br><span class="line">  <span class="comment">// MAX cx</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10010</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1E-9</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1E18</span>;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="keyword">double</span> a[maxm][maxn], b[maxm], c[maxn], v;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    b[l] /= a[l][e];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j != e) a[l][j] /= a[l][e];</span><br><span class="line">    &#125;</span><br><span class="line">    a[l][e] = <span class="number">1</span> / a[l][e];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(a[i][e]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        b[i] -= a[i][e] * b[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(j != e) a[i][j] -= a[i][e] * a[l][j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i][e] = -a[i][e] * a[l][e];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v += c[e] * b[l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j != e) c[j] -= c[e] * a[l][j];</span><br><span class="line">    &#125;</span><br><span class="line">    c[e] = -c[e] * a[l][e];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> e = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(e = <span class="number">1</span>; e &lt;= n; e++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[e] &gt; eps) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(e == n + <span class="number">1</span>) <span class="keyword">return</span> v;</span><br><span class="line">      <span class="keyword">double</span> mn = inf;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][e] &gt; eps &amp;&amp; mn &gt; b[i] / a[i][e]) &#123;</span><br><span class="line">          mn = b[i] / a[i][e];</span><br><span class="line">          l = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(mn == inf) <span class="keyword">return</span> inf;</span><br><span class="line">      pivot(l, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxm], f[maxm], c[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="comment">// freopen("out", "w", stdout);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    Simplex::n = n, Simplex::m = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">      Simplex::c[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s[i],&amp;f[i],&amp;c[i]);</span><br><span class="line">      Simplex::b[i] = c[i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = s[i]; j &lt;= f[i]; j++) &#123;</span><br><span class="line">        Simplex::a[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(Simplex::simplex()+<span class="number">0.5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> BZOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单纯形法 </tag>
            
            <tag> 线性规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder308E] tokitsukaze and Similar String (字符串哈希, 打表)</title>
      <link href="/blog/2018/12/07/nowcoder308e/"/>
      <url>/blog/2018/12/07/nowcoder308e/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/308/e" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/308/e</a></p><p>tokitsukaze获得了一个长度为n，由a-z小写字母组成的字符串。<br>我们定义两个字符串是相似的，当且仅当能通过多次以下操作，使得两个字符串相等。并且把需要操作的最小次数，称为两个字符串的相似度。<br>操作是这样的：选择一个字符串，把字符串的每个字母都替换为字母表上的下一个字母，同时，我们认为z的下一个字母为a，比如选择”acdz”，操作一次后变为”bdea”。<br>现在tokitsukaze从字符串中任取两个子串，她想知道它们是不是相似的，如果它们相似，请输出相似度，如果它们不相似，请输出-1。</p><a id="more"></a><hr><p>字符串哈希，好久没见到了。<br>这题可以预处理出变换26次的所有串，我们希望快速查询子串，于是想到用字符串哈希。<br>对于字符串$s$，我们预处理$hash[i]$为$s[1]\to s[i]$这个字符串前缀的哈希值，可以这样求：<br>$$<br>hash[i]=hash[i-1]*M+s[i]<br>$$<br>于是我们希望知道$s[i]\to s[j]$的哈希值，就可以：<br>$$<br>hash[j]-hash[i-1]\times M^{j-i+1}<br>$$<br>不用管hash的具体值，任其自然溢出就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ULL = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ULL m1 = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line">ULL vis[<span class="number">27</span>][maxn];</span><br><span class="line">ULL mul[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mul[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">    mul[i] = mul[i<span class="number">-1</span>] * m1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">int</span> x, y, len;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(t+<span class="number">1</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        vis[i][j] = vis[i][j<span class="number">-1</span>] * m1 + t[j] - <span class="string">'a'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        t[j] = <span class="string">'a'</span> + ((t[j] - <span class="string">'a'</span> + <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;len);</span><br><span class="line">      <span class="keyword">if</span>(x + len - <span class="number">1</span> &gt; n || y + len - <span class="number">1</span> &gt; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> ret = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[<span class="number">0</span>][x+len<span class="number">-1</span>]-vis[<span class="number">0</span>][x<span class="number">-1</span>]*mul[len] == vis[i][y+len<span class="number">-1</span>]-vis[i][y<span class="number">-1</span>]*mul[len]) &#123;</span><br><span class="line">          ret = min(ret, min(i, <span class="number">26</span>-i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret==<span class="number">0x7f7f7f7f</span>?<span class="number">-1</span>:ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>供复习使用：<a href="https://blog.csdn.net/richard_for_oi/article/details/79306985" target="_blank" rel="noopener">https://blog.csdn.net/richard_for_oi/article/details/79306985</a></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 打表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder315E] 勇敢的妞妞 (思维，状压，记忆化搜索)</title>
      <link href="/blog/2018/12/06/nowcoder315e/"/>
      <url>/blog/2018/12/06/nowcoder315e/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/315/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/315/E</a></p><p>美丽的牛家庄受到了外星人的侵略, 勇敢的妞妞要上战场抵御侵略。</p><p>在妞妞上战场前, 村长牛牛给了妞妞N件装备, 妞妞需要选择其中的K件,装备在身上提升自己的战斗力。每件装备有5种属性增幅值,对于第i件装备它的属性增幅值为(ri1, ri2, ri3, ri4, ri5), 分别代表该装备对不同的属性值增幅。</p><p>当妞妞装备多件装备的时候,由于装备之前会互相影响, 对于每种属性值的增幅并不是所有装备该属性值之和, 而是该种属性值下所有装备中最大的属性值。而妞妞最终增加的战斗力为这5种属性值增幅之和。</p><p>妞妞一定要保卫牛家庄, 所以她希望她能提升尽可能多的战斗力, 请你帮帮她计算她最多能增加多少战斗力。</p><a id="more"></a><p>首先能想到的是当$K\geq 5$时，只要在N件装备里选出5种属性中分别的最大值即可。</p><p>由于只有5种属性，我们可以关心每件装备对不同属性组合的贡献，于是可以状态压缩，比如我只关心第1、3属性的装备谁最大，那么这个状态就是$(10100)_2$，我们记录每种状态下都是哪个装备能提供最大幅度的增长，维护这个数组$hi$.</p><p>接下来希望尝试不同子状态的组合，比如$(10100)_2$和$(01001)_2$可以组合成$(11101)_2$，那么他们对答案的贡献就是$hi(10100_2)+hi(01001_2)$。所以我们直接先写个爆搜。</p><p>发现这个爆搜的状态重复了，于是记忆化一下就可以剪掉一部分搜索分支了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, ret;</span><br><span class="line"><span class="keyword">int</span> hi[<span class="number">1</span>&lt;&lt;<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> r[maxn][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">6</span>][<span class="number">1</span>&lt;&lt;<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">int</span> done, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(~dp[cnt][done]) <span class="keyword">return</span> dp[cnt][done];</span><br><span class="line">  <span class="keyword">if</span>(cnt == k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>((i &amp; done)) <span class="keyword">continue</span>;</span><br><span class="line">    ret = max(ret, dfs(cnt+<span class="number">1</span>, done|i, i+<span class="number">1</span>) + hi[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[cnt][done] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;r[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="built_in">memset</span>(hi, <span class="number">0</span>, <span class="keyword">sizeof</span> hi);</span><br><span class="line">    <span class="keyword">if</span>(k &gt; <span class="number">5</span>) k = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> st = <span class="number">0</span>; st &lt; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); st++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(st &amp; (<span class="number">1</span> &lt;&lt; j)) tmp += r[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        hi[st] = max(hi[st], tmp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 状压 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder272D] Where are you (最小生成树，缩点，割边)</title>
      <link href="/blog/2018/12/03/nowcoder272d/"/>
      <url>/blog/2018/12/03/nowcoder272d/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/272/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/272/D</a></p><p>求无向图中必然在最小生成树上出现的边的条数。<br><a id="more"></a></p><p>根据最小生成树的构造方法可以知道，当最小生成树不唯一时，可以用某一条边替换树上相同权值的边。<br>考虑kruskal算法，我们按照相同的边进行分组，每次处理一个组，并把这组边加到之前已经处理好的连通块上后跑tarjan求桥。在这个组里如果有某条边是桥，那么这条边一定是会选中的就可以计数，之后清理一下标记就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">int</span> w;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">202001</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  pre[find(x)] = find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tarjan</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, next;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">  &#125;;</span><br><span class="line">  Edge edge[maxn];</span><br><span class="line">  <span class="keyword">int</span> ecnt, d, Y;</span><br><span class="line">  <span class="keyword">int</span> head[maxn], bridge[maxn];</span><br><span class="line">  <span class="keyword">int</span> low[maxn], dfn[maxn];</span><br><span class="line"></span><br><span class="line">  Tarjan() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(bridge, <span class="number">0</span>, <span class="keyword">sizeof</span> bridge);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    ecnt = <span class="number">0</span>; d = <span class="number">0</span>; Y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[ecnt].u = u, edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].idx = Y;</span><br><span class="line">    edge[ecnt].next = head[u]; head[u] = ecnt++;</span><br><span class="line">    edge[ecnt].u = v, edge[ecnt].v = u;</span><br><span class="line">    edge[ecnt].idx = Y++;</span><br><span class="line">    edge[ecnt].next = head[v]; head[v] = ecnt++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i=edge[i].next) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">      <span class="keyword">int</span> idx = edge[i].idx;</span><br><span class="line">      <span class="keyword">if</span>(p == idx) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">        dfs(v, idx);</span><br><span class="line">        low[u] = min(low[u], low[v]);</span><br><span class="line">        <span class="keyword">if</span>(low[v] == dfn[v]) &#123;</span><br><span class="line">          bridge[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Tarjan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;p)) &#123;</span><br><span class="line">    Tarjan t;</span><br><span class="line">    e.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      e.emplace_back(Edge(&#123;u,v,w&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e.begin(), e.end(), [](Edge a, Edge b) &#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = i;</span><br><span class="line">      <span class="keyword">while</span>(k &lt; m &amp;&amp; e[k].w == e[i].w) k++;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">        u = find(e[j].u), v = find(e[j].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        t.adde(u, v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">        u = find(e[j].u), v = find(e[j].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t.dfn[u]) t.dfs(u, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!t.dfn[v]) t.dfs(v, <span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; k; j++) &#123;</span><br><span class="line">        u = find(e[j].u), v = find(e[j].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        t.dfn[u] = t.dfn[v] = <span class="number">0</span>;</span><br><span class="line">        t.low[u] = t.low[v] = <span class="number">0</span>;</span><br><span class="line">        t.head[u] = t.head[v] = <span class="number">-1</span>;</span><br><span class="line">        unite(u, v);</span><br><span class="line">      &#125;</span><br><span class="line">      i = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.ecnt; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(t.bridge[i]) ret++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> 缩点 </tag>
            
            <tag> 割边 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder272B] Xor Path(树，异或，计数)</title>
      <link href="/blog/2018/11/30/nowcoder272b/"/>
      <url>/blog/2018/11/30/nowcoder272b/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/272/B" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/272/B</a></p><p>给定一棵n个点的树，每个点有权值$A_i$. 定义$path(i,j)$表示$i$到$j$的最短路径上，所有点的点权异或和。对于$i=1\to n-1,j=i+1 \to n$，求所有$path(i,j)$的异或和。</p><a id="more"></a><p>考虑到这个问题只和每个点权的出现次数的奇偶有关系，那么我们可以分情况讨论下每个点在任意两点间的路径中都是如何出现的。</p><ul><li>对于叶子节点，只有n-1次（与其他点直连）。</li><li>对于非叶节点，则有：<ul><li>与其他点直连，出现n-1次。</li><li>这个点的子树中的任意两点进行连接，出现$\sum_{1\leq i&lt;j\leq n} child_i\times child_j$次，其中$child_i$表示第$i$个儿子为根节点的总点数（包括自己）。</li><li>这个点将子树和非子树分成两部分，这两部分互相连接。那么贡献是两部分点数的乘积。</li></ul></li></ul><p>只有一个地方的计算需要优化，那就是$k$个数任意取2个数的乘积之和，维护一个前缀和随便弄一下就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500500</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL w[maxn], son[maxn], cnt[maxn];</span><br><span class="line">LL out[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  son[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum, val;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    son[u] += son[v];</span><br><span class="line">    sum.emplace_back(son[v]);</span><br><span class="line">    val.emplace_back(son[v]);</span><br><span class="line">    tot++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) &#123;</span><br><span class="line">    sum[i] += sum[i<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">    out[u] += ((val[i] * (sum[tot<span class="number">-1</span>] - sum[i]))) % <span class="number">2</span>;</span><br><span class="line">    out[u] %= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">    <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span> son);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt[i] = (n - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">      cnt[i] += ((son[i] - <span class="number">1</span>) * (n - son[i])) % <span class="number">2</span>;</span><br><span class="line">      cnt[i] += out[i] % <span class="number">2</span>;</span><br><span class="line">      cnt[i] %= <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(cnt[i] &amp; <span class="number">1</span>) ret ^= w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异或 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[POJ2887] Big String（块状链表）</title>
      <link href="/blog/2018/11/29/poj2887/"/>
      <url>/blog/2018/11/29/poj2887/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2887" target="_blank" rel="noopener">http://poj.org/problem?id=2887</a><br><strong>给一个字符串，要求两个操作：</strong><br><strong>I ch p：在这个字符串第p个字符前插入字符ch</strong><br><strong>Q p：查询第p个位置的字符</strong><br><a id="more"></a></p><p>第一次写块状链表，还挺顺利的。。。<br>就是块大小调了几次wa了好几发。。。<br>块状链表比数组分块多了一个操作就是可以用拆分操作来支持插入操作。对于这个题来说就是当某个块中插入元素是块大小的2倍时，我们就可以把这个块拆成2个了。<br>我用的list可能常数可能比较大，但是非常好实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> bsize, len;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; be;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1001000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator p = be.begin(); p != be.end(); p++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;size() &gt;= <span class="number">2</span> * bsize) &#123;</span><br><span class="line">      <span class="built_in">string</span> a = p-&gt;substr(<span class="number">0</span>, bsize);</span><br><span class="line">      <span class="built_in">string</span> b = p-&gt;substr(bsize, p-&gt;length()-bsize);</span><br><span class="line">      <span class="comment">// cout &lt;&lt;*p&lt;&lt;" split: "&lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">      *p = b;</span><br><span class="line">      be.insert(p, a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator p = be.begin(); p != be.end(); p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; tot + p-&gt;size()) &#123;</span><br><span class="line">      tot += p-&gt;size();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos == tot+<span class="number">1</span>) <span class="keyword">return</span> (*p)[i];</span><br><span class="line">      <span class="keyword">else</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">char</span>* tmp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator p = be.begin(); p != be.end(); p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; tot + p-&gt;size()) &#123;</span><br><span class="line">      tot += p-&gt;size();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos -= tot;</span><br><span class="line">    p-&gt;insert(pos, tmp);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  len++;</span><br><span class="line">  maintain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">char</span> cmd[<span class="number">5</span>], tmp[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> pos;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  be.clear();</span><br><span class="line">  bsize = <span class="number">10000</span>;</span><br><span class="line">  be.push_back(s);</span><br><span class="line">  maintain();</span><br><span class="line">  <span class="keyword">int</span> q;</span><br><span class="line">  scan_d(q);</span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">    <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">      scan_d(pos);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, query(pos));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, tmp);</span><br><span class="line">      scan_d(pos);</span><br><span class="line">      pos--;</span><br><span class="line">      <span class="keyword">if</span>(pos &gt;= len) insert(len, tmp);</span><br><span class="line">      <span class="keyword">else</span> insert(pos, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> POJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 块状链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1011] Round #499 (Div. 2)（树转RMQ+莫队 or 启发式合并）</title>
      <link href="/blog/2018/11/27/cf600E/"/>
      <url>/blog/2018/11/27/cf600E/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/600/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/600/problem/E</a><br><strong>给一棵树，问从根节点开始每个节点的子树（包含这个节点）中的众数的和。</strong></p><a id="more"></a><p>一看到子树上的某种计数我就会非常自然地想到树转RMQ再做一些区间操作，当然这个题也不例外。。。</p><p>于是考虑把这棵树的查询转成区间查询，要查每一个节点的子树，那么就是有$n​$次查询。线段树是解决不了区间众数问题的，于是就想到去分块。但是这题的意思是众数如果出现多次那就要把他们都加起来，所以我们<strong>在维护每个数出现的次数的同时，还要维护每个次数对应的数字之和。</strong>更新的时候注意加加减减就可以了，还有就是每次更新当前最大次数$ret​$的时候遇到remove要判断一下当前这个出现次数是否已经没有数字了，遇到这种情况的时候，因为每次出现次数都-1，于是我们直接把$ret-1​$就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">using</span> Query = struct &#123; LL l, r, ret, id; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(LL &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v, n, sid, sz;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;LL&gt;&gt; G;</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; c, be, w;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Query&gt; q;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;LL, LL&gt; vis, tot;</span><br><span class="line">  <span class="keyword">while</span>(scan_d(n)) &#123;</span><br><span class="line">    G = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;LL&gt;&gt;(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;LL&gt;(<span class="number">0</span>));</span><br><span class="line">    c = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    w = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    q = <span class="built_in">vector</span>&lt;Query&gt;(n+<span class="number">1</span>);</span><br><span class="line">    sz = LL(<span class="built_in">sqrt</span>(n)); sid = <span class="number">0</span>;</span><br><span class="line">    vis.clear(); tot.clear();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      scan_d(c[i]);</span><br><span class="line">      tot[<span class="number">0</span>] += c[i];</span><br><span class="line">      be.emplace_back(i / sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      scan_d(u);</span><br><span class="line">      scan_d(v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(LL, LL)&gt; dfs = [&amp;](LL u, LL p) &#123;</span><br><span class="line">      q[u].l = ++sid; w[sid] = c[u]; q[u].id = u;</span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        LL&amp; v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">      &#125;</span><br><span class="line">      q[u].r = sid;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    sort(q.begin(), q.end(), [&amp;](Query a, Query b) &#123;</span><br><span class="line">      <span class="keyword">return</span> be[a.l] == be[b.l] ? a.r &lt; b.r : a.l &lt; b.l;</span><br><span class="line">    &#125;);</span><br><span class="line">    function&lt;<span class="keyword">void</span>(LL, LL&amp;)&gt; add = [&amp;](LL x, LL&amp; ret) &#123;</span><br><span class="line">      tot[vis[x]] -= x;</span><br><span class="line">      vis[x]++;</span><br><span class="line">      tot[vis[x]] += x;</span><br><span class="line">      ret = max(ret, vis[x]);</span><br><span class="line">    &#125;;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(LL, LL&amp;)&gt; remove = [&amp;](LL x, LL&amp; ret) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ret == vis[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot[vis[x]] - x == <span class="number">0</span>) &#123;</span><br><span class="line">          ret = vis[x] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      tot[vis[x]] -= x;</span><br><span class="line">      vis[x]--;</span><br><span class="line">      tot[vis[x]] += x;</span><br><span class="line">    &#125;;</span><br><span class="line">    LL L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span>(L &lt; q[i].l) &#123; remove(w[L], ret); L++; &#125;</span><br><span class="line">      <span class="keyword">while</span>(L &gt; q[i].l) &#123; L--; add(w[L], ret); &#125;</span><br><span class="line">      <span class="keyword">while</span>(R &lt; q[i].r) &#123; R++; add(w[R], ret); &#125;</span><br><span class="line">      <span class="keyword">while</span>(R &gt; q[i].r) &#123; remove(w[R], ret); R--; &#125;</span><br><span class="line">      <span class="comment">// LL p = 0;</span></span><br><span class="line">      <span class="comment">// printf("(%lld, %lld) : ", q[i].l,q[i].r);</span></span><br><span class="line">      <span class="comment">// for(auto x : vis) &#123;</span></span><br><span class="line">      <span class="comment">//   printf("%lld %lld, ", x.first, x.second);</span></span><br><span class="line">      <span class="comment">//   p = max(p, x.second);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// printf("\n");</span></span><br><span class="line">      <span class="comment">// for(auto x : vis) &#123;</span></span><br><span class="line">      <span class="comment">//   if(x.second == p) q[i].ret += x.first;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// cout &lt;&lt; p &lt;&lt; " " &lt;&lt; ret &lt;&lt; endl;</span></span><br><span class="line">      q[i].ret = tot[ret];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q.begin(), q.end(), [=](Query a, Query b)&#123;</span><br><span class="line">      <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, q[i].ret, <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题其实就是想教大家<strong>在维护每个数出现的次数的同时，还要维护每个次数对应的数字之和。</strong>我们冷静分析以后，发现这个题可以直接DFS。</p><p>我们希望在每次DFS的时候把子树中的数字出现情况merge到当前这个父亲上，考虑对每个点维护上述两个数组，每次把小的树更新到大的树上，merge的具体操作跟上述莫队的更新一样。</p><p>如何保证小集合merge到大集合上的复杂度？</p><p>Tutorial是这么解释的：“every time when vertex <em>v</em> will be moved from one <em>map</em> to another the size of the new map will be at least two times larger. So each vertex can be moved not over than $\log n$ times.”</p><p>发现merge的时候大集合至少是小集合的2倍，实际上就是说每次每个集合被遍历的次数都会减半，相当于最坏情况下每个点被遍历$\log n$次，于是merge的复杂度就是$n\log n $. 整体复杂度就是$O(n\log^2 n)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">100100</span>;</span><br><span class="line">LL n, c[maxn], id[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; G[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; cnt[maxn], tot[maxn];</span><br><span class="line">LL ret[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(LL u, LL v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cnt[id[u]].size() &lt; cnt[id[v]].size()) swap(id[u], id[v]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt[id[v]]) &#123;</span><br><span class="line">    tot[id[u]][cnt[id[u]][x.first]] -=  x.first;</span><br><span class="line">    cnt[id[u]][x.first] += x.second;</span><br><span class="line">    tot[id[u]][cnt[id[u]][x.first]] +=  x.first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LL u, LL p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">    LL&amp; v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    gao(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  ret[u] = tot[id[u]].rbegin()-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt[i].clear();</span><br><span class="line">      tot[i].clear();</span><br><span class="line">      G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;c[i]);</span><br><span class="line">      id[i] = i;</span><br><span class="line">      cnt[i][c[i]] = <span class="number">1</span>;</span><br><span class="line">      tot[i][<span class="number">1</span>] = c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%I64d%c"</span>, ret[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫队算法 </tag>
            
            <tag> 离线 </tag>
            
            <tag> 树转RMQ </tag>
            
            <tag> 启发式合并 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder283F] 出装方案 (状压DP or 费用流)</title>
      <link href="/blog/2018/11/25/nowcoder283f/"/>
      <url>/blog/2018/11/25/nowcoder283f/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/283/F" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/283/F</a></p><p>众所周知，在各种对抗类游戏里装备都是很重要的一环，不同的出装方案会给玩家带来不同的强度。 </p><p>  dalao手里有N件装备，现在dalao要把装备分给N个队友，每个队友只能分一件装备，而每个队友穿上不同的装备会有不同程度的强度提升。  </p><p>  现在给出每个队友对每件装备的强度提升的值，请问dalao的所有分配方案里，<strong>最多</strong>能让团队的<strong>总</strong>强度提升多少呢？</p><a id="more"></a><p>这题可以DP也可以费用流。</p><p>DP可以维护$f(i,st)$表示处理到前$i$个人，并且当前已经拿了$st$个装备时的最佳方案，转移就从$st$中未标记的转移就可以。由于只和上一层的状态有关，因此存储空间可以压下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      f[<span class="number">0</span>][<span class="number">1</span>&lt;&lt;i] = a[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> st = <span class="number">1</span>; st &lt; nn; st++) &#123;</span><br><span class="line">          <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; j) &amp; st) <span class="keyword">continue</span>;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][st|(<span class="number">1</span>&lt;&lt;j)] = max(f[i&amp;<span class="number">1</span>][st|(<span class="number">1</span>&lt;&lt;j)], f[!(i&amp;<span class="number">1</span>)][st]+a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[(n<span class="number">-1</span>)&amp;<span class="number">1</span>][nn<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>费用流也十分好想，一边是装备一边是人，超级源连装备费用为0容量为1，人连超级汇费用为0容量为1，内部装备的费用为装备提升的相反数容量为1，跑最大费用最大流即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, next;</span><br><span class="line">  LL c, w;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">0x3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">const</span> LL inf = (<span class="number">1L</span>L&lt;&lt;<span class="number">55</span>);</span><br><span class="line"><span class="keyword">int</span> tot, head[maxn];</span><br><span class="line">LL dist[maxn];</span><br><span class="line">LL cost, flow;</span><br><span class="line">Node e[maxm];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> S, T, N;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S = T = N = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c:容量, w:费用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL c, LL w)</span> </span>&#123;</span><br><span class="line">  e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">  e[tot].u = v; e[tot].v = u; e[tot].c = <span class="number">0</span>; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dist[i] = inf;</span><br><span class="line">    visit[i] = <span class="number">0</span>;</span><br><span class="line">    pre[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">  Q.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  pre[s] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q.front();</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(e[j].c &gt; <span class="number">0</span> &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123;</span><br><span class="line">        dist[e[j].v] = dist[u] + e[j].w;</span><br><span class="line">        pre[e[j].v] = j;</span><br><span class="line">        <span class="keyword">if</span>(!visit[e[j].v]) &#123;</span><br><span class="line">          Q.push(e[j].v);</span><br><span class="line">          visit[e[j].v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return dist[t] &lt; 0; // 求可行流</span></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 求最小费用流</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ChangeFlow</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  LL det = mod;</span><br><span class="line">  <span class="keyword">int</span> u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    det = min(det, e[u].c);</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    e[u].c -= det;</span><br><span class="line">    e[u ^ <span class="number">1</span>].c += det;</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> det;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">MinCostFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  LL mincost, maxflow;</span><br><span class="line">  mincost = maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(spfa(s, t, n)) &#123;</span><br><span class="line">    LL det = ChangeFlow(t);</span><br><span class="line">    mincost += det * dist[t];</span><br><span class="line">    maxflow += det;</span><br><span class="line">  &#125;</span><br><span class="line">  cost = mincost;</span><br><span class="line">  flow = maxflow;</span><br><span class="line">  <span class="keyword">return</span> mincost;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> to[maxn][maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T_T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T_T);</span><br><span class="line">  <span class="keyword">while</span>(T_T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    init();</span><br><span class="line">    S = <span class="number">0</span>, T = <span class="number">2</span> * n + <span class="number">1</span>, N = T + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      adde(S, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      adde(n+i, T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;to[i][j]);</span><br><span class="line">        adde(i,n+j, <span class="number">1</span>, -to[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, -MinCostFlow(S, T, N));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费用流 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder283H] 图论一顿套模版 (最短路)</title>
      <link href="/blog/2018/11/25/nowcoder283h/"/>
      <url>/blog/2018/11/25/nowcoder283h/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/283/H" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/283/H</a></p><p>有N栋楼和M条道路<strong>（单向）</strong>，每条路都有“不整洁度”W，现在校方想知道从S楼到T楼的所有路径中，“不整洁度”<strong>乘积最小</strong>是多少。 由于答案可能很大，所以你需要将最后的答案对10E9+7取模。</p><a id="more"></a><p>因为权值会很大，所以直接拿乘积算最短路是不可以的，因为取模后数值大小无法比较。</p><p>需要注意的是，题目保证每一个权都是2的幂，虽然我没注意。。</p><p>于是我维护了权值的每一位，计算的时候只管它们最终都是2的多少次幂。</p><p>于是可以堆优化最短路，在堆里维护2的幂次，这样就能保证一个大小顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  LL v, w, next;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">50050</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxm = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">1E18</span>;</span><br><span class="line">LL n, m, ee, s, t;</span><br><span class="line">LL d[maxn][<span class="number">64</span>];</span><br><span class="line">LL head[maxn];</span><br><span class="line">Edge e[maxm];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;PLL, <span class="built_in">vector</span>&lt;PLL&gt;, greater&lt;PLL&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; n; x=(x*x)%mod,n&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = (ret * x) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ee = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(LL u, LL v, LL w)</span> </span>&#123;</span><br><span class="line">  e[ee].v = v; e[ee].w = w; e[ee].next = head[u]; head[u] = ee++;</span><br><span class="line">  <span class="comment">// e[ee].v = u; e[ee].w = w; e[ee].next = head[v]; head[v] = ee++;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL v, LL u, LL w=<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  LL a = <span class="number">0</span>, b = <span class="built_in">ceil</span>(<span class="built_in">log</span>(w)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">    a += d[v][i] * i;</span><br><span class="line">    b += d[u][i] * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get</span><span class="params">(LL u)</span> </span>&#123;</span><br><span class="line">  LL a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">    a += d[u][i] * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(LL &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v;</span><br><span class="line">  LL w;</span><br><span class="line">  <span class="keyword">while</span>(scan_d(n)) &#123;</span><br><span class="line">    scan_d(m);</span><br><span class="line">    scan_d(s);</span><br><span class="line">    scan_d(t);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) d[i][j] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      scan_d(u);</span><br><span class="line">      scan_d(v);</span><br><span class="line">      scan_d(w);</span><br><span class="line">      adde(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">      d[s][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.push(PLL(get(s), s));</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">      PLL tmp = pq.top(); pq.pop();</span><br><span class="line">      LL pw = tmp.first, u = tmp.second;</span><br><span class="line">      <span class="keyword">if</span>(get(u) &lt; pw) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(LL i = head[u]; ~i; i=e[i].next) &#123;</span><br><span class="line">        LL v = e[i].v; LL w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(check(v, u, w)) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">            d[v][j] = d[u][j];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> cur = <span class="built_in">ceil</span>(<span class="built_in">log</span>(w)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">          d[v][cur]++;</span><br><span class="line">          pq.push(PLL(get(v), v));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[t][<span class="number">0</span>] == inf) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(d[t][i]) &#123;</span><br><span class="line">        ret *= mul(<span class="number">2L</span>L,(i*d[t][i])%mod) % mod;</span><br><span class="line">        ret %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder283J] RMQ (线段树)</title>
      <link href="/blog/2018/11/25/nowcoder283j/"/>
      <url>/blog/2018/11/25/nowcoder283j/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/283/J" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/283/J</a></p><p>小姐姐想要一种数据结构，支持如下操作： </p><p>  对于一个整数数组：     </p><p>  \1. 给定L和R，输出[L,R]中元素的和 </p><p>  \2. 给定L，R和X，将[L,R]中每个元素与X进行按位或运算 </p><p>  \3. 数组索引从1开始 </p><p>  按位或在C\C++、Java、Python中为’|’运算符</p><a id="more"></a><p>难点在于如何处理或操作。</p><p>做过异或线段树的题，这个或自然会想到拆位处理，针对每一位建一棵线段树，如果或的数字的某一位为1时，则这一位（假设是第$i$位）在区间$[l,r]$对于答案（sum）的贡献为$2^i\times(r-l+1)$.</p><p>认真写一下lazy标记的处理就好，蛮好写。注意线段树$sum[rt][i]$的顺序，惨遭卡常。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">2</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> add[maxn&lt;&lt;<span class="number">2</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUP</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  sum[rt][i] = sum[rt&lt;&lt;<span class="number">1</span>][i] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDOWN</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(add[rt][i]) &#123;</span><br><span class="line">    add[rt&lt;&lt;<span class="number">1</span>][i] |= add[rt][i];</span><br><span class="line">    add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i] |= add[rt][i];</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sum[rt&lt;&lt;<span class="number">1</span>][i] = m - l + <span class="number">1</span>;</span><br><span class="line">    sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i] = r - m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[l]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[l] &amp; <span class="number">1</span>) sum[rt][i] = <span class="number">1</span>;</span><br><span class="line">      i++;</span><br><span class="line">      a[l] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(lson);</span><br><span class="line">  build(rson);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    sum[rt][i] = sum[rt&lt;&lt;<span class="number">1</span>][i] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    add[rt][i] = <span class="number">1</span>;</span><br><span class="line">    sum[rt][i] = (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pushDOWN(rt, l, r, i);</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= m) update(L, R, c, lson, i);</span><br><span class="line">  <span class="keyword">if</span>(R &gt; m) update(L, R, c, rson, i);</span><br><span class="line">  pushUP(rt, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1L</span>L &lt;&lt; i) * sum[rt][i];</span><br><span class="line">  &#125;</span><br><span class="line">  pushDOWN(rt, l, r, i);</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= m) </span><br><span class="line">    ret += query(L, R, lson, i);</span><br><span class="line">  <span class="keyword">if</span>(m &lt; R) </span><br><span class="line">    ret += query(L, R, rson, i);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> a, b, c;</span><br><span class="line">  <span class="keyword">char</span> cmd[<span class="number">5</span>];</span><br><span class="line">  scan_d(n);</span><br><span class="line">  scan_d(q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    scan_d(::a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">    <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">'S'</span>) &#123;</span><br><span class="line">      scan_d(a);</span><br><span class="line">      scan_d(b);</span><br><span class="line">      LL ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        ret += query(a, b, <span class="number">1</span>, n, <span class="number">1</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      scan_d(a); scan_d(b); scan_d(c);</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c &amp; <span class="number">1</span>) update(a, b, <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i);</span><br><span class="line">        i++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[读书笔记-西瓜书] EM算法</title>
      <link href="/blog/2018/11/21/em/"/>
      <url>/blog/2018/11/21/em/</url>
      <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）中EM算法部分的笔记，书上总结得很精炼，有很多细枝末节的东西需要填充。</p><p>PDF版：<a href="http://pcoln8jiu.bkt.clouddn.com/em.pdf" target="_blank" rel="noopener">http://pcoln8jiu.bkt.clouddn.com/em.pdf</a></p><a id="more"></a><hr><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>书中将EM算法总结为估计参数隐变量的方法，它是一种迭代式算法：</p><p>若参数$\Theta$已知，则根据训练数据$D$推断出最优隐变量$Z$；若$Z$的值已知，则可对$\Theta$求极大似然估计。</p><p>步骤简单地可以总结为下面两步：<br>E步：利用当前估计的参数值$\Theta$计算对数似然的期望。</p><p>M步：寻找可以使E步产生的似然期望最大的$\Theta$。</p><p>上面两个步骤交替执行，直至收敛。</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>强烈建议观看徐亦达教授的EM算法视频：<a href="https://www.bilibili.com/video/av23901379" target="_blank" rel="noopener">https://www.bilibili.com/video/av23901379</a></strong></p><p>这部分之前写的不是很清楚，于是我决定重新看一下徐老师的视频和PPT，认真把EM算法框架推导和证明过一遍，再推导出高斯混合模型带入框架中的具体形式。</p><hr><p>EM算法是一个非常好的解决计算困难问题的思路，巧妙地引入隐变量（latent variables）避开一些复杂计算。首先从高斯混合模型引入问题：</p><h2 id="高斯混合模型（Gaussian-Mixture-Model-GMM）"><a href="#高斯混合模型（Gaussian-Mixture-Model-GMM）" class="headerlink" title="高斯混合模型（Gaussian Mixture Model, GMM）"></a>高斯混合模型（Gaussian Mixture Model, GMM）</h2><p>基于贝叶斯估计通常首先假设数据中的特征之间独立同分布。我们遇到数据集的分布无法仅用一个Gaussian Distribution拟合时通常考虑使用混合模型，Gaussian mixture model就是将多个高斯模型加权求和达到对拟合数据的目的。使用GMM描述一个数据集的分布可以表示成：<br>$$<br>p(X)=\sum_{i=1}^k\alpha_iN(X|\mu_i,\Sigma_i)<br>$$</p><p>$$<br>\sum\alpha_i=1<br>$$</p><p>$k$为高斯分布个数，$\Theta$表示高斯混合模型，$\alpha$为每个高斯分布的权，$N$表示一个高斯分布的概率值，定义为$f(x;\theta_i)$，是参数为$\theta_i$的高斯分布概率密度函数$\dfrac{1}{\sqrt{2\pi}\Sigma_i}exp(-\dfrac{(x-\mu_i)^2}{2\Sigma_i^2})$。$\mu、\Sigma$分别为每个高斯分布的参数。</p><p>对于整个GMM $\Theta$，我们需要确定的参数有$2k-1$个，即$\mu_1,…,\mu_k,\Sigma_1,…,\Sigma_k,\alpha_1,…,\alpha_{k-1}$.</p><p>插一句关于$\alpha_i$的来历：因为数据分布（或者说宽度）并不一定非常平均，我随便搜了一张图来解释一下：</p><p><img src="http://f.hiphotos.baidu.com/zhidao/wh%3D450%2C600/sign=4e7ea7a347a98226b8942323bfb29537/314e251f95cad1c8023cd9f17b3e6709c83d5164.jpg" alt="img"></p><p>比如这个图，很明显两个高斯分布比例不一样，因此用权重更合适。</p><p>我思考为什么权值和是1，参考了问答[1]：因为GMM的定义本质上是一个概率密度函数，概率密度函数在负无穷到正无穷内的积分为1，因此我们首先要满足概率密度函数的性质。</p><p>我们希望GMM更好地拟合数据集，也就是希望$p(x)$尽可能地大，于是通常利用对数似然估计对高斯混合模型进行调参，使得拟合特定的数据集。</p><p>这里再插一句：为什么不用一般的极大似然估计(MAP)？</p><p>这是我和师兄同学在饭桌上讨论过的一个问题，总结一下，原因有两条：</p><ol><li>因为极大似然估计是把所有概率乘在一起，每个概率值都是小数，数据量大了小数位精度会丢得非常厉害。</li><li>将连乘换成对数和的形式，求导方便。</li></ol><p>针对高斯混合模型，我们构造损失函数$L(\Theta)$：<br>$$<br>L(\Theta|X)=\sum_{i=1}^n \log p(X)<br>$$<br>即：<br>$$<br>L(\Theta|X)=\sum_{i=1}^n \log \sum_{j=1}^k\alpha_jN(x_i|\mu_j,\Sigma_j)<br>$$<br>于是我们的优化目标就是：<br>$$<br>\Theta^{MLE}=\mathop{argmax}_\Theta L(\Theta|X)<br>$$<br>虽然上式可导，但是无法一步到位，计算过程过于复杂。</p><p>考虑是不是可以有一个迭代的方法，求得$\Theta^{(1)},\Theta^{(2)},…,\Theta^{(t)}$，使得我们最后收敛？</p><hr><p>这是推导EM需要的前置知识，摆在这里。</p><h2 id="Jensen不等式-2"><a href="#Jensen不等式-2" class="headerlink" title="Jensen不等式[2]"></a>Jensen不等式[2]</h2><p>设$f$是定义域为实数的函数，如果对于所有的实数$x$，$f(x)$的二次导数大于等于0，那么$f是$凸函数。当$x$是向量时，如果其Hessian矩阵H是半正定的，那么$f$是凸函数。如果只大于0，不等于0，那么称$f$是严格凸函数。</p><p>Jensen不等式表述如下：</p><p>如果f是凸函数，$X$是随机变量，那么：$E[f(X)]\geq f(E[X])$，特别地，如果$f$是严格凸函数，当且仅当$X$是常量时，上式取等号。</p><p><img src="http://img.my.csdn.net/uploads/201301/24/1359004230_7889.jpg" alt="img"></p><p>图中，实线$f$是凸函数，$X$是随机变量，有0.5的概率是$a$，有0.5的概率是$b$。$X$的期望值就是$a$和$b$的中值了，图中可以看到$E[f(X)]\geq f(E[X])$成立。</p><p><strong>顺便，中国数学界关于函数凹凸性定义和国外很多定义是反的。国内教材中的凹凸，是指曲线，而不是指函数，图像的凹凸与直观感受一致，却与函数的凹凸性相反[3].</strong></p><hr><h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><p>直接给出EM算法需要迭代解决的基本任务：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}_\Theta\int_z \log p(X,z|\Theta)p(z|X,\Theta^{(t)}) \mathop{dz}<br>$$<br>当然这是最普遍的定义，如果放在离散问题上，那么$z$的数量是有限的于是可以写成：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}<em>\Theta\sum</em>{i=1}^k\log p(X,z_i|\Theta)p(z_i|X,\Theta^{(t)})<br>$$<br><strong>接下来会一步一步地推出上面这个迭代式。</strong></p><p>我再摆一下原来的优化目标：<br>$$<br>\Theta^{MLE}=\mathop{argmax}<em>\Theta\log \sum</em>{j=1}^k\alpha_jN(X|\mu_j,\Sigma_j)<br>$$<br>我们发现有2个不一样的地方：</p><ol><li>怎么多了个变量$z$？</li><li>这个$\sum$怎么跑$\log$左边去了？</li></ol><h5 id="怎么多了个变量？这对原目标不会有影响么？"><a href="#怎么多了个变量？这对原目标不会有影响么？" class="headerlink" title="怎么多了个变量？这对原目标不会有影响么？"></a>怎么多了个变量？这对原目标不会有影响么？</h5><p>首先，其实$z$是辅助变量，称为隐变量（latent variable），引入这个东西是EM算法的一个亮点。我记得在数据挖掘课上徐君老师点评SVM算法，说这是一个典型的“看似化简为繁”的工作，但是有了这一步，后面的计算往往会更加简便。</p><p>这和EM算法异曲同工，EM算法的提出者也看得很远，他对需要优化的损失函数引入辅助变量，而且必须保证加和不加的分布相同（保证加了$z$之后的边缘分布与原分布一致），也就是说，给出数据的概率分布，必须保证有：<br>$$<br>p(X)=\sum_{i=1}^kp(X|\Theta,z_i)p(\Theta,z_i)<br>$$<br>$p(X|\Theta,z_i)$表示对数据判断的似然（对应GMM中的概率密度函数$N$）</p><p>$p(\Theta,z_i)$表示先验（对应GMM中的权重$\alpha_i$）</p><p>我们这么定义，因此合适的$p$都不会有影响。</p><h5 id="这个-sum-怎么跑-log-左边去了？"><a href="#这个-sum-怎么跑-log-左边去了？" class="headerlink" title="这个$\sum$怎么跑$\log$左边去了？"></a>这个$\sum$怎么跑$\log$左边去了？</h5><p>保留这个问题，首先分析我们的优化目标。由于是迭代的，那么最基本的要求就是我们每次迭代都要使当前结果更加接近最终结果，也就是：<br>$$<br>\log p(X|\Theta^{(t+1)})\geq \log p(X|\Theta^{(t)})<br>$$<br>我们的目标是推出这样一个式子，此时已经没有隐变量$z$了。我们希望通过优化目标下式来得到上式的结果：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}<em>\Theta\sum</em>{i=1}^k\log p(X,z_i|\Theta)p(z_i|X,\Theta^{(t)})<br>$$<br>这个假设非常大胆，我们很轻易地发现这里其实蕴含了一个矛盾，我们定义$\Theta$是最终的优化结果，而$\Theta^{(t)}$却是当前步的最优目标，我们在计算过程中实际上并不知道$\Theta$，这完全是个Chicken and eggs problem。</p><p>如何处理并不是很显然，我们尝试推一下。首先知道：<br>$$<br>p(X)=\dfrac{p(X)p(XZ)}{p(XZ)}=\dfrac{p(XZ)}{p(Z|X)}<br>$$<br>于是：<br>$$<br>\log p(X|\Theta)=\log \dfrac{p(XZ|\Theta)}{p(Z|X\Theta)}= \log p(XZ|\Theta)-\log p(Z|X\Theta)<br>$$<br>那么它们在$Z$下的期望也一定相等，即：<br>$$<br>E_{p(Z|X\Theta^{(t)})}[\log p(X|\Theta)]= E_{p(Z|X\Theta^{(t)})}[\log p(XZ|\Theta)-\log p(Z|X\Theta)]<br>$$<br>等式左边展开期望的定义：<br>$$<br>E_{p(Z|X\Theta^{(t)})}[\log p(X|\Theta)]=\int_Z[\log p(X|\Theta)]p(z|X\Theta^{(t)})dz<br>$$</p><p>$$<br>=\log p(X|\Theta)\int_zp(z|X\Theta^{(t)})dz<br>$$</p><p>$$<br>=\log p(X|\Theta)<br>$$</p><p>等式右边，由期望可加性拆成两项差，期望定义展开：<br>$$<br>=\int_Z\log p(XZ|\Theta)p(z|X\Theta^{(t)})dz-\int_Z\log p(Z|X\Theta)p(z|X\Theta^{(t)})dz<br>$$<br><strong>这是整个EM算法里最tricky的部分（其次是引入latent variable）</strong>，仔细观察就会发现EM算法迭代优化的只是前面那个积分$\int_Z\log p(XZ|\Theta)p(Z|X\Theta^{(t)})dz$，所以接下来就是消掉后面这个积分，这个被消掉的过程是有点厉害的。。</p><p>前半部分定义给个记号：$Q(\Theta,\Theta^{(t)})$，后半部分定义为：$H(\Theta,\Theta^{(t)})$.</p><p>重申下我们的目标，希望推出最终优化目标为：<br>$$<br>\mathop{argmax}_{\Theta}[\int_Z\log p(XZ|\Theta)p(z|X\Theta^{(t)})dz]=\Theta^{(t)}<br>$$<br>那么到$t+1$步的时候，$Q$和$H$会变大还是变小？</p><p>讨论$Q$：（因为我们的最终目标就只包含Q，所以Q肯定单调增加啦）显然$Q(\Theta^{(t+1)},\Theta^{(t)})Q&gt;(\Theta,\Theta^{(t)})$.</p><p>讨论H：如果$H(\Theta^{(t)},\Theta^{(t)})\geq H(\Theta^{(t+1)},\Theta^{(t)})$，即$H$是单调递减的话就可以将优化目标的后半部分的积分约掉了，下面证明。</p><h5 id="证明-H-Theta-t-Theta-t-geq-H-Theta-Theta-t"><a href="#证明-H-Theta-t-Theta-t-geq-H-Theta-Theta-t" class="headerlink" title="证明$H(\Theta^{(t)},\Theta^{(t)})\geq H(\Theta,\Theta^{(t)})$"></a>证明$H(\Theta^{(t)},\Theta^{(t)})\geq H(\Theta,\Theta^{(t)})$</h5><p>$$<br>\int_z\log[p(z|X\Theta^{(t)})]p(z|X\Theta^{(t)})dz-\int_z\log[p(Z|X\Theta)]p(z|X\Theta^{(t)})dz<br>$$</p><p>即：<br>$$<br>\int_z\log[\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)}]p(z|X\Theta^{(t)})dz<br>$$<br>希望上式$\geq0$，ummmm…似乎做不下去了。</p><p>冷静分析，上面实际上是个函数的期望$E_Z(log[\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)}])$，里面有个$\log$实在太复杂，能不能把$\log$拿出来，比如写成$\log E(\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)})$.</p><p>我们再仔细考虑，诶？这个分子是$p(z|X\Theta^{(t)})$，跟$Z$下的概率一样嘛。于是保证这个函数的单调性的同时做一下变换：<br>$$<br>E_Z(log[\dfrac{p(z|X\Theta^{(t)})}{p(Z|X\Theta)}])=E_Z(-log[\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}])<br>$$<br>我们要把$log$拿出来，于是作者想到了用Jensen不等式$E[f(X)]\geq f(E[X])$，函数的期望≥期望的函数，带进去就OK了：<br>$$<br>E_Z(-log[\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}])\geq -\log E_Z(\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})})<br>$$<br>展开不等式右边：<br>$$<br>-\log E_Z(\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})})=\int_Z \dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}p(z|X\Theta^{(t)})dz=-log(1)=0<br>$$<br>于是：<br>$$<br>E_Z(-log[\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})}])\geq -\log E_Z(\dfrac{p(Z|X\Theta)}{p(z|X\Theta^{(t)})})=0<br>$$<br>单调减的性质就证出来了。</p><p>所以我们的优化目标就是：<br>$$<br>\Theta^{(t+1)}=\mathop{argmax}<em>\Theta\sum</em>{i=1}^k\log p(X,z_i|\Theta)p(z_i|X,\Theta^{(t)})<br>$$<br>（$\sum$竟然跑到$\log$的左边去了）</p><hr><p>Reference：</p><p>徐老师的视频链接：<a href="https://www.bilibili.com/video/av23901379" target="_blank" rel="noopener">https://www.bilibili.com/video/av23901379</a></p><p>[1]. <a href="https://www.quora.com/Why-are-all-of-the-weights-in-Gaussian-mixture-models-supposed-to-be-positive" target="_blank" rel="noopener">https://www.quora.com/Why-are-all-of-the-weights-in-Gaussian-mixture-models-supposed-to-be-positive</a></p><p>[2]. <a href="https://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8537620</a></p><p>[3]. <a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7/4583322?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7/4583322?fr=aladdin</a></p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[GCJKickstart2018RoundH] C. Let Me Count The Ways（容斥）</title>
      <link href="/blog/2018/11/18/GCJK2018HC/"/>
      <url>/blog/2018/11/18/GCJK2018HC/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;a=2" target="_blank" rel="noopener">https://codejam.withgoogle.com/codejam/contest/3324486/dashboard#s=p2&amp;a=2</a></p><p><strong>一共有$2n$个座位排成一排，现在有m对人去坐，每对人之间有顺序。每对人均不可以相邻，问一共有多少种坐法？</strong></p><a id="more"></a><p>考虑用总的排列数减去每对人都相邻的情况，于是我们发现后者的排列是可以容斥的。</p><p>设$f(k)$表示$k$对人均坐在一起的排列数，那么答案就是：<br>$$<br>\sum_{k=0}^m(-1)^kf(k)<br>$$<br>$f(k)$也比较容易算，可以由下面几个部分组合起来：</p><ol><li>$m$对中任取$k$对：$C(m,k)$</li><li>每对人有顺序，那么所有可能的排列就是$2^k$</li><li>在$2n​$个位置里面挑$k​$对位置，将两个相邻位置看成一个座位，那么相当于$2n-k​$个位置的排列，那么总计一共有$(2n-k)!​$种排列。</li></ol><p>于是$f(k)=C(m,k)2^k(2n-k)!$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod =(LL) <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8100001</span>;</span><br><span class="line">LL f[maxn];</span><br><span class="line">LL n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) f[i] = (f[i<span class="number">-1</span>] * i) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = (ret * x) % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    x = (x * x) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LL ret = exgcd(b, a%b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span> </span>&#123;</span><br><span class="line">  LL x, y;</span><br><span class="line">  exgcd(a, mod, x, y);</span><br><span class="line">  <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f[x] * inv(f[x-y]) % mod * inv(f[y]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL k = <span class="number">0</span>; k &lt;= m; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">ret += (f[<span class="number">2</span>*n-i]*C(m,i)%mod)*mul(<span class="number">2L</span>L,i)%mod;</span><br><span class="line">ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ret -= (f[<span class="number">2</span>*n-i]*C(m,i)%mod)*mul(<span class="number">2L</span>L,i)%mod;</span><br><span class="line">ret += mod;</span><br><span class="line">ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) ret += mod;</span><br><span class="line"><span class="keyword">return</span> ret % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="comment">// freopen("out", "w", stdout);</span></span><br><span class="line">init();</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _ &lt;&lt; <span class="string">" Done."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, gao());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Kickstart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学， 容斥 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces521E] Thematic Contests(贪心)</title>
      <link href="/blog/2018/11/17/cf521E/"/>
      <url>/blog/2018/11/17/cf521E/</url>
      <content type="html"><![CDATA[<p>赛后4min过题的感觉真不爽啊……</p><p>题目链接：<a href="http://codeforces.com/contest/1077/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1077/problem/E</a></p><p><strong>题意：要$n$个题出比赛，每一个题有一个类型$a_i$，要求每一天出的比赛都是同一种类型的题，并且每一种类型在这几天内只出现一次，并且当前一天出题数是前一天的2倍，问这些天最多出多少题。</strong></p><a id="more"></a><p>首先维护一下每一种题出现的次数，我们只需要操作这个次数就可以了。</p><p>对题目出现次数从大到小排个序，接下来我们考虑枚举题目的上界，然后往下枚举就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;LL,LL&gt; vis;</span><br><span class="line">LL n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL a;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n)) &#123;</span><br><span class="line">    vis.clear();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;a);</span><br><span class="line">      vis[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; cnt;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : vis) &#123;</span><br><span class="line">      cnt.emplace_back(x.second);</span><br><span class="line">      ret = max(ret, x.second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cnt.begin(), cnt.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      LL t = i;</span><br><span class="line">      LL tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt.size(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(cnt[j] &gt;= t) tmp += t;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[j] &lt; t) <span class="keyword">break</span>;</span><br><span class="line">        tmp += t;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ret = max(ret, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[读书笔记-西瓜书] 支持向量机（SVM）</title>
      <link href="/blog/2018/11/16/svm/"/>
      <url>/blog/2018/11/16/svm/</url>
      <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第六章（支持向量机）的笔记。支持向量机最根本的想法是利用数据集找到一个超平面，将两类的样本分隔开，并且这个超平面距离两类数据的支持向量最远。支持向量指的是距离超平面最近的几个点。</p><a id="more"></a><hr><p>HEXO特别坑，我的数学公式在typora中编辑正常，但是生成静态页面时就解析错误了，只好上传图片外加附PDF文件了：<a href="http://pcoln8jiu.bkt.clouddn.com/svm.pdf" target="_blank" rel="noopener">http://pcoln8jiu.bkt.clouddn.com/svm.pdf</a></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_1.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_2.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_3.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_4.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_5.Jpeg" alt="img"><br><img src="http://pcoln8jiu.bkt.clouddn.com/111716584510_0svm_6.Jpeg" alt="img"></p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces520D] Fun with Integers (规律，并查集)</title>
      <link href="/blog/2018/11/16/cf520d/"/>
      <url>/blog/2018/11/16/cf520d/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1062/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/D</a></p><p>给一个$n$，现在允许任意初始一个数$k$并给定一个操作：$ax=b$，$bx=a$当且仅当$a$为$b$的倍数或$b$为$a$的倍数时，可以将$a$变为$b$（可以是负数），同时获得分数$|x|$. 要求不允许有多次$a$到$b$或$b$到$a$的操作（每个$x$仅算一次），问最多能得多少分。</p><a id="more"></a><p>看到第一个样例就明白了：考虑一个数$x$和它的因数$p_i$，我们总可以由$x$转到所有$\pm p_i$的可能（从$x$转到$p_i$，再由$p_i$转到$-x$，然后是$-x$到$-p_i$，接着是$-p_i$到$x$），每一次的贡献是$4p_i$，于是我们考虑维护所有带有整除关系的连通块，然后计算它们的所有倍数和*4就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line">LL s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  pre[find(x)] = find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">        unite(i, i*j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">        s[find(i)] += (LL)j &lt;&lt; <span class="number">2L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = max(ret, s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规律 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[读书笔记-西瓜书] Bayes分类器</title>
      <link href="/blog/2018/11/10/bayes/"/>
      <url>/blog/2018/11/10/bayes/</url>
      <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第七章（贝叶斯分类器）的笔记。</p><a id="more"></a><hr><h2 id="贝叶斯决策论"><a href="#贝叶斯决策论" class="headerlink" title="贝叶斯决策论"></a>贝叶斯决策论</h2><p>使用贝叶斯决策论解决问题时的目标实际上是“最小化总体风险”，可以形式化表示成下式：<br>$$<br>R(c_i|x)=\sum_{j=1}^{n}\lambda_{ij}P(c_j|x)<br>$$<br>$\lambda_{ij}$：$i$类误分类成$j$类的代价。</p><p>$P(c_i|x)$：样本$x$分类成$c_i$的概率。</p><p>贝叶斯决策论希望找到一个最小化总体风险的判别准则$h(x)$，对于分类任务则是一个分类准则（$h(x)$表示将$x$归类为$h(x)$类），使得上述总体风险最小：<br>$$<br>h(x)=\mbox{argmin}\ R(c|x)<br>$$</p><hr><h2 id="贝叶斯准则"><a href="#贝叶斯准则" class="headerlink" title="贝叶斯准则"></a>贝叶斯准则</h2><p>贝叶斯准则可以简单理解为“整体风险最小化=每个样本的风险最小化”，风险指的是（比如在分类问题中）被分成错误类的期望。</p><p>能够使用贝叶斯准则的前提是获得后验概率$P(c|x)$，贝叶斯分类器此类生成模型则会考虑使用贝叶斯定理来求解这个后验概率：<br>$$<br>P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}<br>$$<br>解释一下公式中的每一个量的意义：</p><p>$P(c|x)$：<strong>后验概率</strong>，认为$x$分类成$c$的概率。</p><p>$P(c)$：<strong>先验概率</strong>，从公式上直观上看就是“偏见”、“第一眼看到这个人就觉得他是坏人”这样的概率。</p><p>$P(x|c)$：$x$相对于$c$的类条件概率，也称<strong>似然</strong>。指的是已知某些观测所得到结果（类别是$c$）时，对有关事物的性质（恰好是样本$x$）的参数进行估计[1]。</p><p>$P(x)$：用于归一化的因子，$P(x)=\sum_{i=1}^{n}P(x|c=i)P(c=i)$.</p><p>贝叶斯定理实际上就是希望通过已知相当数量的训练数据集合$D$，我们希望找到一个合理的方法来估计$D$中的$P(c)$和$P(x|c)$：</p><p>我们假设训练集中的训练数据独立同分布，那么根据大数定律，$P(c)$可以用每一类样本的<strong>频率</strong>来估计。</p><p>$P(x|c)$很难使用频率估计，因为$D$中的样本$x$通常无法完全覆盖所有情况：未被数据集覆盖$\not=$出现概率为0。于是需要使用<strong>极大似然估计</strong>.</p><hr><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计(MLE)"></a>极大似然估计(MLE)</h2><p>书中首先在介绍Logistic回归的时候使用了MLE（对数似然），但是没有仔细介绍。</p><p>首先假设数据集符合某种概率分布$D(\theta_c)$，被分成不同类完全取决于参数向量$\theta_c$.训练模型的过程就是参数估计的过程。</p><p>极大似然估计（MLE）就是一种参数估计方法，估计方法完全写在名字里了：似然（$P(x|c)$）极大化。由于分类结果完全取决于$\theta_c$，因此这个似然可以表示成$P(x|\theta_c)$.介绍贝叶斯准则的时候也讲了，“整体风险最小化=每个样本的风险最小化”。因此$\theta_c$对于整个数据集$D​$的似然就是：<br>$$<br>P(D|\theta_c)=\prod_{x\in D}P(x|\theta_c)<br>$$<br>我们给它取对数（因为小数连乘会导致精度损失）：<br>$$<br>L(\theta_c)=logP(D|\theta_c)=\sum_{x\in D}\mbox{log}P(x|\theta_c)<br>$$<br>我们对$\theta_c$的估计为：<br>$$<br>\hat{\theta_c}=\mbox{argmax}_{\theta_c}L(\theta_c)<br>$$<br>分析到这里这个式子已经展不开了，因为每个样本具体的似然取决于<strong>我们假设的是哪个分布</strong>，比如概率密度函数服从正态分布$\N(\mu_c,\sigma^2_c)$，那么对于它的参数$\mu_c$和$\sigma_c^2$的极大似然估计分别为数据集的均值$\dfrac{\sum_{x\in D}x}{|D|}$和方差$\dfrac{\sum_{x\in D}(x-\hat{\mu_c})^2}{|D|}$。</p><p>（然而我认为通常这么随意假设数据分布是不科学的= =）</p><hr><h2 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h2><p>由于$P(x|c)$是所有属性的联合概率，难以估计属性之间的关系，为了避免计算上的问题，引入属性条件独立性假设。</p><p>属性条件独立性假设：假设所有属性（理解：样本$x$中的每一维）相互独立。</p><p>于是$P(c|x)$重写为：<br>$$<br>P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}=\dfrac{P(c)}{P(x)}\sum_{i=1}^dP(x_i|c)<br>$$<br>$d$为属性数，$x_i$为样本$x$在第$i$个属性的取值。对于每个类$c$，$P(x)$都一样。在计算过程中可以忽略，于是：<br>$$<br>h(x)=\mbox{argmin}\ R(c|x)<br>$$</p><p>$$<br>=\mbox{argmax}\ P(c|x)<br>$$</p><p>$$<br>=\mbox{argmax}\ P(c)\prod_{i=1}^dP(x_i|c)<br>$$</p><p>$P(c)$：可以由每类的样本出现<strong>频率</strong>获得。</p><p>$P(x_i|c)$：针对离散的情况，可以根据类别是$c$并且含有属性$x_i$的出现<strong>频率</strong>获得；针对连续的情况，用密度函数。</p><p>一句话：于是计算贝叶斯实际上就是算两个量：$P(c)$和$P(x_i|c)$，按照两个量对应样本的<strong>频率</strong>获得一个概率，然后再用$h(x)$的计算方法乘出不同属性对应不同分类的极大似然估计即可。</p><hr><h2 id="缺省值处理"><a href="#缺省值处理" class="headerlink" title="缺省值处理"></a>缺省值处理</h2><p>有时会遇到某个样本某个属性缺失的情况，但是又不至于将该样本删除，于是需要进行平滑处理。拉普拉斯修正。</p><hr><h2 id="半朴素贝叶斯"><a href="#半朴素贝叶斯" class="headerlink" title="半朴素贝叶斯"></a>半朴素贝叶斯</h2><p>适当考虑部分属性的相互依赖信息，半朴素贝叶斯使用<strong>“独依赖估计”</strong>，即每个属性至多依赖于一个其他属性。<br>$$<br>P(c|x) \propto P(c)\prod_{i=1}^dP(x_i|c_,pa_i)<br>$$<br>$pa_i$：$x_i$所依赖的属性（$x_i$的父属性），计算过程就是将任意两个属性之间的依赖信息$I(x_i,x_j)$为边权建图，跑最大生成树。</p><hr><h2 id="贝叶斯网"><a href="#贝叶斯网" class="headerlink" title="贝叶斯网"></a>贝叶斯网</h2><p>贝叶斯网是个有向无环图，用点表示属性，权值为属性发生的概率，边表示依赖关系，边权为条件概率。例如$A$有一条指向$B$的边，点权描述的是$P(A)$、$P(B)$，这条边的权描述的就是$P(B|A)$. 没有边相连的两个点之间是相互独立的。</p><p>有一个笔记[2]中的例子非常形象地描述了相互独立的性质：</p><p>一个聪明人，在一场很难的考试里拿了高分，却得到了一封很烂的推荐信，同时他SAT考试却是高分的概率是多少？</p><p>我们再隐藏一些细节，一个人推荐信很烂，他SAT高分的概率是多少？或者，一个人SAT低分，却手握牛推的概率是多少？</p><p>如果不考虑随机变量之间的依赖关系，上述内容是很难计算的。但是如果有一个构建好的概率图，上面的问题则可以转化为条件概率问题。</p><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>已知网络结构的话，那么贝叶斯网上的各种信息是很容易统计的，按照网络要求和训练数据统计不同<strong>频率</strong>即可。</p><p>若网络结构未知，将贝叶斯网的学习看作是一个数据压缩任务，目标是<strong>学习到一个能以最短编码长度描述训练数据的模型</strong>。定义评分函数：<br>$$<br>s(B|D)=f(\theta)|B|-L(B|D)<br>$$<br>s(B|D)：在数据集$D$条件下的贝叶斯网$B$的评分函数。</p><p>$|B|$：贝叶斯网的参数个数。</p><p>$f(\theta)$：描述每个参数$\theta$所需字节数</p><p>$L(B|D)$：贝叶斯网的对数似然。</p><p>我们最终的目的是寻找一个$B$使$s$(B|D)最小，$f(\theta)$可以取1或者$\dfrac{1}{2}\mbox{log}\ m$，分别称为AIC和BIC。</p><h4 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h4><p>不能直接根据贝叶斯网定义的联合概率分布来计算后验概率，因为网络节点多的稠密图推理是NP-hard的。于是可以借助<strong>近似推断</strong>，常用Gibbs采样完成，先跳过了= =、</p><hr><p>Reference：</p><p>[1]. <a href="https://blog.csdn.net/lwq1026/article/details/70161857" target="_blank" rel="noopener">https://blog.csdn.net/lwq1026/article/details/70161857</a></p><p>[2].  <a href="https://www.cnblogs.com/ironstark/p/5087081.html" target="_blank" rel="noopener">https://www.cnblogs.com/ironstark/p/5087081.html</a></p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[读书笔记] Bias-Variance Dilemma</title>
      <link href="/blog/2018/11/05/BiasVarianceTradeoff/"/>
      <url>/blog/2018/11/05/BiasVarianceTradeoff/</url>
      <content type="html"><![CDATA[<p><strong>Deliberate Practice$\ ^{[1]}$：to identify your weakest areas and direct a massive effort on improving those areas without worrying about areas in which you are already good.</strong></p><p>这是我在阅读西瓜书第二章时的一个遗留问题，是关于偏差-方差窘境（Bias-Variance Dilemma）的内容。</p><a id="more"></a><p>首先要解释Bias-Variance Tradeoff，也就是偏差-方差权衡，譬如当前有一个拟合任务，需要构造一个多项式函数去拟合它，函数可以构造成这样：<br>$$<br>y=a_0+a_1x+a_2x^2+…+a_nx^n<br>$$<br>如何确定$n$的大小就是一个偏差-方差的权衡问题，。图像上直观地看则是为了确定这条曲线的“弯曲程度”。</p><p>曲线拟合和机器学习：前者是利用数据尽可能地拟合出一条完美的曲线；后者则是在有限的数据规模内进行学习，目的是遇到未知数据时能够做出最好的判断。</p><p>模型的泛化能力可以由泛化误差来描述，泛化误差越小，模型的期望泛化能力越强。模型$f$在数据集$D$上的泛化误差可以分解为偏差$bias$、方差$var$、噪声$\epsilon$之和：<br>$$<br>E(f;D)=\mbox{bias}^2(x)+\mbox{var}(x)+\epsilon^2<br>$$<br>递推可以在西瓜书P45翻到。</p><p>噪声指的是学习算法本身固有的误差（系统误差）和数据集的噪声。当保证数据集十分纯净的时候，人为可控的部分就只有偏差和方差了。于是机器学习中存在偏差-方差窘境：<strong>偏差(bias)描述的是模型的拟合能力，偏差过大可以认为是欠拟合；方差(variance)则描述的是数据集的情况，方差过大可以认为是在数据集上过拟合。</strong>二者无法同时达到最小，只能取一个平衡点。    </p><p>总结一下特点：</p><ul><li>高偏差的模型：训练集的错误率高，验证集和训练集的错误率类似。</li><li>高方差的模型：训练集错误率低，验证集高。</li></ul><p>下图描述了一些简单的处理方法：<br><img src="https://www.learnopencv.com/wp-content/uploads/2017/02/Machine-Learning-Workflow.png" alt="img"></p><hr><p><strong>Reference</strong></p><p>[1]. <a href="https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/" target="_blank" rel="noopener">https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/</a></p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[读书笔记-西瓜书] 决策树</title>
      <link href="/blog/2018/11/04/decision_tree/"/>
      <url>/blog/2018/11/04/decision_tree/</url>
      <content type="html"><![CDATA[<p>这是阅读周志华教授《机器学习》中第四章（决策树）的笔记，因为决策树是比较简单的算法，没有什么数学公式的推导，书中也是简单介绍了下信息熵的定义。</p><p>简单总结一下这一章的要点：</p><p>这一章介绍决策树，决策树的特点就是每一个节点作为一个选择分支，用于判断某一个样本是否含有这个属性。</p><p>决策树是递归定义的，因此属性个数理论上讲可以是无限多个。</p><p>在选择某个节点的代表属性时，引入利用信息增益为准则的ID3、C4.5和CART算法，这是三种较为类似的决策树的学习算法。</p><p>为了防止过拟合，还对决策树使用了剪枝操作。</p><p>处理连续值的方法是离散化后设定划分点。</p><p>遇到缺失值时利用无缺失的值进行估计，计算对应的信息增益再进行划分。</p><p>决策树的每一个节点还可以考虑不止一个属性，譬如使用多个属性值的线性组合的形式（多变量决策树），即允许存在斜的划分边界。甚至可以在每一个节点放一个感知机（感知机树）。</p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[读书笔记-西瓜书] 线性判别分析：LDA</title>
      <link href="/blog/2018/11/04/lda/"/>
      <url>/blog/2018/11/04/lda/</url>
      <content type="html"><![CDATA[<p><strong>线性判别分析（Linear Discriminant Analysis, LDA）又称Fisher判别分析，是一种数据降维的方法，主要思想是使属于同一类的投影点距离尽可能地接近（类内方差小），不同类的中心点距离尽可能地远（类间中点距离大）。</strong></p><a id="more"></a><p>LDA就是模识课上黄老板讲的Fisher判别，名字不同而已。思想也很简单，计算也不复杂。首先定义一些变量：<br>$$<br>x_i：i类数据的训练样本<br>$$</p><p>$$<br>\mu_i：i类数据的均值向量<br>$$</p><p>$$<br>\Sigma_i：i类数据的协方差矩阵<br>$$</p><p>投影到直线$w$上后，样本中心（均值）所在的投影就变为$w^T\mu_i$，协方差变为$w^T\Sigma_i w$，推一下协方差：</p><p>展开协方差的定义：$\Sigma_i=\sum_{j=1}^n(x_j-u_i)^2$</p><p>变换后的协方差定义：$\Sigma’<em>i=\sum</em>{j=1}^n(w^Tx_j-w^Tu_i)^2$</p><p>则有：<br>$$<br>\Sigma’<em>i=\sum</em>{j=1}^n(w^Tx_j-w^Tu_i)^2=\sum_{j=1}^n(w^T(x_j-u_i))^2<br>$$</p><p>$$<br>=\sum_{j=1}^nw^T(x_j-u_i)(w^T(x_j-u_i))^T<br>$$</p><p>$$<br>=\sum_{j=1}^nw^T(x_j-u_i)(x_j-u_i)^Tw<br>$$</p><p>$$<br>=w^T\sum_{j=1}^n(x_j-u_i)^2w<br>$$</p><p>$$<br>=w^T\Sigma_iw<br>$$</p><p>用变换后的协方差作为衡量类内点的“集中”程度，我们尽可能想让这个值小。于是第一个目标可以用这个值逼近。</p><p>为了叙述方便，现在假设分类任务是二分类，分别是0、1类。第二个目标类间距离可以直接比较类内中点之间的距离测度，定义类间距为中点的Euclidean Distance平方：$Dis(0,1)=|w^T\mu_0-w^T\mu_1|^2$来衡量。我们希望这个值尽可能大</p><p>定义：$S_w’=\Sigma’_0+\Sigma’_1$，$S_b’=Dis(0,1)$。</p><p>同时考虑上述两个指标，于是做商合成一个目标函数（突然想起自己的paper里也搞过这种设计）：<br>$$<br>J=\dfrac{S_b’}{S_w’}=\dfrac{|w^T\mu_0w-w^T\mu_1|^2}{w^T\Sigma_0w+w^T\Sigma_1w}<br>$$</p><p>$$<br>=\dfrac{w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w}<br>$$</p><p>目标即为通过调整$w$最大化$J$，$S’_b$和$S’_w$的比值称为“广义瑞利商”。由于分子和分布都是关于$w$的二次项，因此解只与$w$的方向有关。方程等价于优化下式：<br>$$<br>\min_w -w^TS’_bw<br>$$</p><p>$$<br>st.\ w^TS’_ww=1<br>$$</p><p>这是个带约束的极值求解问题，可以用高数中学过的拉格朗日乘数法解决，构造拉格朗日函数：<br>$$<br>L(w)=-w^TS’_bw+\lambda(w^TS’_ww-1)<br>$$<br>令上式的导数得0，即可得：<br>$$<br>w=S_w’^{-1}(\mu_0-\mu_1)<br>$$<br>问题转换成求解$S’_w$的逆。注意该阵通常情况下不可逆，原因是数据维数和数据条目数通常是不匹配，就是说数据集并不能确定地体现数据的分布情况。</p><p>书上介绍的实际是PCA方法，直接给$S’_w$进行SVD分解，得到$S’_w=U\Sigma V^T$，于是$S_w’^{-1}=(U\Sigma V^T)^{-1}=V\Sigma^{-1}U^T$。</p><p>最终我们可推得：<br>$$<br>w=V\Sigma^{-1}U^T(\mu_0-\mu_1)<br>$$</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[读书笔记-西瓜书] 线性模型、Logistic回归</title>
      <link href="/blog/2018/11/03/logistic/"/>
      <url>/blog/2018/11/03/logistic/</url>
      <content type="html"><![CDATA[<p>这是阅读周志华教授的《机器学习》中关于Logistic回归部分的笔记（在模识老师的安利下，最终还是买了西瓜书）。</p><p><strong>Logistic回归音译为“逻辑回归”实在是太蠢了。</strong></p><a id="more"></a><p>Logistic回归是西瓜书第三章“线性模型”中的内容，首先总结一下在logistic回归之前的知识点。</p><p>所谓线性回归就是定义一个线性函数$f(x)=w^Tx+b$，经过在一个特定数据集上学习后获得参数$w$和$b$的过程。通常需要搭配优化算法使用，例如最小二乘法、梯度下降法、牛顿法、拟牛顿法$^{[1,2]}$等，我将它们的特点总结如下：</p><p>最小二乘法：希望找到一条n维空间上的直线，使得所有数据点到这条线上的欧几里德距离最短（均方差误差最小），因为均方误差损失函数是凸的，所以最小二乘法直接对该损失函数关于$w$和$b$进行求导。</p><p>梯度下降法：这是一种迭代求解最优的算法，方法就是将参数沿着梯度负方向更新。这种算法经常陷入局部最优，而且速度未必快。有很多延伸的优化，比如随机梯度下降、带惯性的梯度下降等。</p><p>牛顿法：对拟合目标函数泰勒展开后求导后迭代，需要计算任意两个变量的二阶偏导的逆（海森矩阵的逆）所以计算复杂度高，但是收敛快。过程一图以蔽之：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif" alt="img"></p><p>拟牛顿法：把海森矩阵用个近似矩阵来代替，为了减少计算的复杂度，同时这个近似矩阵保证是可逆的（感谢HF同学的指正QAQ）。</p><p>但是通常的拟合任务并非是线性的，数据可能是符合某种非线性函数的变化（例如指数），因此有了对数线性回归（log-linear regression）。由于自变量的变化还是$w^Tx+b$，因此还属于线性回归模型。更一般的形式如下：<br>$$<br>g(y)=w^Tx+b<br>$$<br>$$<br>y=g^{-1}(w^Tx+b)<br>$$</p><p>此处$g(\cdot)$是一个非线性函数，这个函数需要“<strong>连续且充分光滑</strong>”。</p><p>分类任务和回归任务最大的区别是，分类需要一个hard-label，而回归通常是一个实数值的soft-label（hard-label和soft-label是我自己起的）。想用回归的方法进行分类，则需要有一个soft-&gt;hard的映射函数。</p><p>可以手动设阈值（阶跃，就是分段函数），但是不满足作为$g(\cdot)$需要的充分条件。于是有人构造了更加光滑的logistic function（对数几率函数）：<br>$$<br>y=\dfrac{1}{1+e^{-z}}<br>$$<br>这是一种sigmoid函数：形似S的函数。我们想表示成$g(y)=w^Tx+b$的形式，可以推：<br>$$<br>y=\dfrac{1}{1+e^{-z}}<br>$$<br>$$<br>y+ye^{-z}=1<br>$$</p><p>$$<br>\dfrac{1-y}{y}=e^{-z}<br>$$</p><p>$$<br>\ln\dfrac{1-y}{y}=-z<br>$$</p><p>$$<br>\ln\dfrac{y}{1-y}=z<br>$$</p><p>其中$z=w^Tx+b$，$y$和$1-y$分别可看作是正反例的可能性（logits），二者的比值取对数称为“对数几率 ”。通常写作：<br>$$<br>\ln\dfrac{p(y=1|x)}{p(y=0|x)}=z<br>$$<br>有：<br>$$<br>p(y=1|x)=\dfrac{e^{z}}{1+e^z}<br>$$<br>由于$p(y=0|x)=1-p(y=1|x)$，则：<br>$$<br>p(y=0|x)=\dfrac{1}{1+e^z}<br>$$<br>使用极大似然估计$w$和$b$，构造损失函数$l(w,b)=\sum_{i=1}^{m}\ln p(y_i|x_i;w,b)$，最大化该函数，整理一下就能得到loss函数的形式，之后就能用上述的最优化算法求它的最优解了。</p><p><strong>Reference</strong></p><p>[1]. <a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixiangwan/p/7532830.html</a></p><p>[2]. <a href="https://www.cnblogs.com/xiaohuahua108/p/6011105.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuahua108/p/6011105.html</a></p><hr>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[读书笔记] Neural Networks and Deep Learning Chapter 2</title>
      <link href="/blog/2018/10/29/nndl_ch2/"/>
      <url>/blog/2018/10/29/nndl_ch2/</url>
      <content type="html"><![CDATA[<p>这是我阅读在线书籍《Neural Networks and Deep Learning》第二章的笔记。</p><p>手残不小心把整个笔记的文件夹误删了，原来这种事是真的会发生的啊，还好对第一章笔记做了备份= =、</p><p>章节链接： <a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap2.html</a></p><a id="more"></a><p>尽力恢复车祸现场。。</p><p>先给出一堆变量定义（图来自知乎<a href="https://zhuanlan.zhihu.com/p/26765585）：" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26765585）：</a></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/gsddyyyy.png" alt="img"></p><hr><p>在”The four fundamental equations behind backpropagation”之前，主要介绍了一个化简前馈表示的方法：$a^{l} = \sigma(w^l a^{l-1}+b^l)$。</p><p>还有两个一个函数允许作为损失函数的两个条件：1. 必须是以网络输出作为参数；2. 损失函数必须写成多个独立样本的损失的和的形式。</p><p>以及介绍了哈达玛积（Hadamard product）：$(s \odot t)_j = s_j t_j$，就是对应项相乘，例：<br>$$<br>\left[\begin{array}{c} 1 \ 2 \end{array}\right]<br>  \odot \left[\begin{array}{c} 3 \ 4\end{array} \right]<br>= \left[ \begin{array}{c} 1 <em> 3 \ 2 </em> 4 \end{array} \right]<br>= \left[ \begin{array}{c} 3 \ 8 \end{array} \right]<br>$$</p><hr><h3 id="The-four-fundamental-equations-behind-backpropagation"><a href="#The-four-fundamental-equations-behind-backpropagation" class="headerlink" title="The four fundamental equations behind backpropagation"></a><strong>The four fundamental equations behind backpropagation</strong></h3><p>反向传播会计算出$\delta_j^l$，表示为第$l$层的第$j$个神经元的误差。</p><p>定义：$\delta^l_j = \frac{\partial  C}{\partial z^l_j}$，$z_j^l$为第$l$层的第$j$个神经元的加权输入结果。反向传播的目标就是计算每一层的$\delta^l$，称之为measure of error。反向传播总的来说是4个方程。</p><p><strong>words</strong></p><ol><li>intermediate：中间的</li><li>messes with：由于……而迷糊</li><li>perturb：扰乱</li></ol><hr><p>首先看看最后一层的损失如何计算：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)<br>$$<br>$\partial C/\partial a_j^L$用于描述作为第$j$个激活函数的输出变化有多快，如果$C$不依赖于这个神经元，那么$\delta_j^L$会比较小（接近收敛）。后面的$\sigma$的导数表示激活函数在这个点的变化有多快。</p><p>这个式子的计算瓶颈在于这个偏导数，于是转换成了下面的形式：<br>$$<br>\delta^L = (a^L-y) \odot \sigma’(z^L)<br>$$<br>$a^L-y$是$C$的变化率，就是个$\Delta$，拆开后就写成上面哈达玛积的形式了。</p><p>再次重申，$\delta^L$表示的是第$L$层（也就是最后一层）的传播误差。<strong>for the error in the output layer</strong>。</p><p>接着看看隐层的传播如何计算：<br>$$<br>\delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l)<br>$$<br>式子中很明显，$l$层的误差就是由下一层（$l+1$层）反传回去的。</p><p>关于对$w^{l+1}$参数矩阵求转置：我是这么理解的，因为输出的时候$l$层用的是$n \times m$的矩阵，想要传回去的话，下层的size就不能是$n\times m$了，而是$m\times n$。转置和下一层的误差相乘，可以把误差传回对应的神经元。</p><p>网络中偏差（bias）的损失的计算：<br>$$<br>\frac{\partial C}{\partial b^l_j} =  \delta^l_j<br>$$<br>模型直接可以用该层的损失来更新某个神经元的bias，于是可以简写：$\partial C / \partial b=\delta$。</p><p>网络中权重的损失的计算：<br>$$<br>\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j<br>$$<br>某层某个神经元的输入乘以该神经元的偏差可以认为是这个神经元对于最终损失的影响值。简写为：$\frac{\partial<br>​    C}{\partial w} = a_{\rm in} \delta_{\rm out}$。</p><p>总结四个BP的关键等式：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz21.png" alt="img"></p><p>下面对每一个等式进行证明，加深理解。</p><hr><p>证明主要分两个部分：</p><p>第一部分是推导出反向传播损失函数和输出之间的关系（BP1 BP2）</p><p>第二部分是推导出损失函数与权重weight和偏差bias的关系（BP3 BP4）</p><p><strong>BP1：</strong><br>$$<br>\delta^L = \nabla_aC \odot \sigma’(z^L)<br>$$<br>证：对于第$j$个激活函数，有定义：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial z^L_j}<br>$$<br>展开：<br>$$<br>\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)=\dfrac{\part C}{\part a_j^L}\dfrac{\part a_j^L}{\part z_j^L}<br>$$<br>由于$a_j^L=\sigma(z_j^L)$，那么$\sigma’(z_j^L)=\dfrac{\partial a_j^L}{\partial z_j^L}$，即：$\delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j)$</p><p>推广至$L$层，公式可简写为：<br>$$<br>\delta^L = \frac{\partial C}{\partial a^L} \sigma’(z^L)<br>$$</p><p><strong>BP2：</strong><br>$$<br>\delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l)<br>$$<br>证：由定义展开$\delta^l$：<br>$$<br>\delta^l = \frac{\partial C}{\partial z^l}<br>$$<br>利用导数的链式法则，对拆成对$z^{l+1}$求导的形式：<br>$$<br>\delta^l = \dfrac{\partial C}{\partial z^{l+1}}\dfrac{\part z^{l+1}}{\part z^{l}}=\dfrac{\partial z^{l+1}}{\partial z^{l}}\delta^{l+1}<br>$$<br>由于$z^{l+1}=\sum_jw_{j}^{l+1}\delta^l(z_{j}^{l+1})+b^{l+1}$，带入上式即证。</p><p><strong>BP3：</strong><br>$$<br>\frac{\partial C}{\partial b^l_j} =  \delta^l_j<br>$$<br>证：<br>$$<br>\frac{\partial C}{\partial b^l_j} =  \frac{\part C}{\part z^{l+1}_j}\frac{\part z^{l+1}_j}{\part b_j^l}=\delta_j^l\frac{\part(w^l_jz^l+b^l_j)}{\part b_j^l}=\delta_j^l<br>$$<br><strong>BP4：</strong></p><p>和上面一样，把$b$换成$w$就行。</p><hr><h3 id="The-backpropagation-algorithm"><a href="#The-backpropagation-algorithm" class="headerlink" title="The backpropagation algorithm"></a><strong>The backpropagation algorithm</strong></h3><p>利用上面证明过的4个结论，就可以推导出反向传播算法，算法可以递归形式地定义成这样：</p><ol><li>输入$x$</li><li>前馈：$z^l=w^la^{l-1}+b^l，夏日难a^l=\sigma(z^l)$</li><li>输出误差：$\delta^L = \nabla_aC \odot \sigma’(z^L)$</li><li>反向传播误差：对于每一层$l,l=L-1,L-2…,2$，于是$\delta^l=((w^{l+1})^T\delta^{l+1})\odot \sigma’(z^l)$</li><li>输出：$w,b$的损失函数定义为$\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j$和$\frac{\partial C}{\partial b^l_j} = \delta^l_j$。</li><li>$\frac{\partial  C}{\partial  b^l_j} = \delta^l_j$。</li></ol><hr><h3 id="The-code-for-backpropagation"><a href="#The-code-for-backpropagation" class="headerlink" title="The code for backpropagation"></a><strong>The code for backpropagation</strong></h3><p>这章实现了用SGD训练的的BP：每次叠小批量的训练集，再计算损失后反传。</p><p>介绍了一个可以同时计算多个mini-batch的trick：把多个mini-batch放到一个矩阵里，利用矩阵计算库对矩阵计算的优化来加速训练。</p><hr><h3 id="In-what-sense-is-backpropagation-a-fast-algorithm"><a href="#In-what-sense-is-backpropagation-a-fast-algorithm" class="headerlink" title="In what sense is backpropagation a fast algorithm?"></a><strong>In what sense is backpropagation a fast algorithm?</strong></h3><p>想在求偏导这一步加速梯度下降的计算，考虑利用$\dfrac{\partial C}{\partial w_j}\approx \dfrac{C(w+\epsilon e_j)-C(w)}{\epsilon}$这样近的似来代替计算偏导，当$\epsilon$很小的时候，起码GD方向是不会变的（$\epsilon$很小的话，多叠几次就可以近似等价于梯度方向走步长步）。但是实际上这样做的计算开销仍然会非常大。</p><p>而反向传播可以<strong>DP</strong>地把损失传回去。</p><hr><h3 id="Backpropagation-the-big-picture"><a href="#Backpropagation-the-big-picture" class="headerlink" title="Backpropagation: the big picture"></a><strong>Backpropagation: the big picture</strong></h3><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz25.png" alt="img"></p><p>对于每层输出产生的误差$\Delta a_j^l$，可以用下式做近似：<br>$$<br>\Delta a^l_j \approx \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>那么对于这层而言其中一条由输出反传回来的结果则是：<br>$$<br>\Delta C \approx \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>于是考虑所有连通的情况：<br>$$<br>\Delta C \approx \sum_{mnp\ldots q} \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}} \Delta w^l_{jk}<br>$$<br>这就是反向传播对于某一条边更新时需要的计算：<br>$$<br>\frac{\partial C}{\partial w^l_{jk}} = \sum_{mnp\ldots q} \frac{\partial C}{\partial a^L_m}<br>  \frac{\partial a^L_m}{\partial a^{L-1}_n}<br>  \frac{\partial a^{L-1}_n}{\partial a^{L-2}_p} \ldots<br>  \frac{\partial a^{l+1}_q}{\partial a^l_j}<br>  \frac{\partial a^l_j}{\partial w^l_{jk}}<br>$$</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>The Last Samurai</title>
      <link href="/blog/2018/10/28/the-last-samurai/"/>
      <url>/blog/2018/10/28/the-last-samurai/</url>
      <content type="html"><![CDATA[<p>I watched a movie named “the last samurai” today: almost after some paper’s deadline. Actually I have watched it when I graduated from my high school. I was impressed by their fearless spirit and extremely focusing.</p><a id="more"></a><p>The story happened at the end of the 19th century, during the Southwest War and the Meiji Restoration of Japan. A drunken hero who participated in the American Civil War was invited by Japanese Reformers to train the new recruits of the Shogunate（幕府）Army. However, he was captured by the anti-Shogunate（倒幕派）to a small village in a battle. He was influenced by their really Bushido spirit and become a warrior of old and new ways(今古有神奉志士，就是融汇古今的武士).</p><p>There are many places worth roasting. For instance, samurais have a tradition of using firearms. But this movie shows they are just using samurai swords and bows. So many examples like this, but they don’t hinder this masterpiece to become one of my favorite movies.</p><p>I love Japanese anime so much and I’m also interested in Japanese traditional culture (in spite of I only know about it in some films). I’m yearning for the life with peace and warm. People in that time can focus on something in a long period, enjoy the process of doing only one thing to the extreme. That maybe is called Craftsmanship(工匠精神). Aside from the historical factors of Japan at that time, this spirit is also worth learning.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai1.png" alt="img"></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai2.png" alt="img"></p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai3.png" alt="img"></p><p>The film section that I love the best is in the village, Algren saw the villagers were doing their own things with their heart and soul as if there was a discipline that cannot be seen. When Algren was learning how to battle with Samurai sword but always beaten by Ujio. Then he was told by Higen that he had “too many minds”. That means Algren shouldn’t think too much except defeating his enemy.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai4.png" alt="img"></p><p>I think the essence of Craftsmanship spirit is “no mind”, means without too many distracting thoughts and just focus on the moment now.</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/samurai5.png" alt="img"></p><p>I’m very lacking in this spirit. I was always disturbed by many things. Maybe that is the reason why I cannot do anything better. Although there is a huge contrast between that time and the times I am in now and the requirements for people are getting higher,  it cannot become the reason of inattention. I should learn how to abandon distracting thoughts and focus on one thing. For me, I think the main source of disturbing is from the Internet. Maybe I should close my QQ and WeChat when I’m doing something that needs “no mind”.</p><p>I talked about some small things above. But what if some big things. I was always hearing something interesting and turning to explore that thing. Then I’ll do nothing at the end. That is called “ to put away the cup after taking a tiny sip”(浅尝辄止).  The reason for this phenomenon is having too many minds. I always want to grasp anything but it is not realistic because human has limited energy.</p><p>I’m sure I have to throw away so many minds and focus on something I think is the most worthy.</p>]]></content>
      
      <categories>
          
          <category> 只言片语 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[Codeforces517D] Minimum path (DP, 贪心, 搜索)</title>
      <link href="/blog/2018/10/28/CF1072D/"/>
      <url>/blog/2018/10/28/CF1072D/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://codeforces.com/contest/1072/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1072/problem/D</a></p><p>给一个$n\times n$的字母阵，允许修改其中的$k$个字符，问从$(1,1)$走到$(n,n)$字典序最小的字符串。</p><a id="more"></a><p>如果不考虑替换的话，字典序最小的字符串可以由BFS得到。</p><p>如果考虑替换的话，首先知道替换掉的字符肯定都会把不是’a’的换成’a’。</p><p>接下来考虑DP，维护$dp(i,j)$为走到$(i,j)$处最多的’a’数量，这里不考虑$k$次替换。</p><p>由于是字典序最小，那么我们知道越早替换成’a’字典序一定是最小的，因此我们就确定了贪心地替换前面扫描的非’a’字符这样一个转移的无后效性。</p><p>DP转移可以这样：<br>$$<br>dp(i,j)=max(dp(i-1,j),dp(i,j-1))+(G(i,j)==’a’)<br>$$<br>接着考虑是否有足够的替换次数，于是存在$i+j-1-dp(i,j)$个待替换的非’a’字符，显然都替换掉字典序是最小的，于是我们拿这个和$k$比一下就可以确定当前字符$G(i,j)$是否需要替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> G[maxn][maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;pii&gt; pq;</span><br><span class="line"><span class="keyword">int</span> p[maxn][maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ret;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">    reverse(ret.begin(), ret.end());</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ok(x<span class="number">-1</span>,y)&amp;&amp;p[x<span class="number">-1</span>][y]) &#123;</span><br><span class="line">    ret.push_back(G[x<span class="number">-1</span>][y]);</span><br><span class="line">    dfs(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">    ret.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ok(x,y<span class="number">-1</span>)&amp;&amp;p[x][y<span class="number">-1</span>]) &#123;</span><br><span class="line">    ret.push_back(G[x][y<span class="number">-1</span>]);</span><br><span class="line">    dfs(x,y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">    ret.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="built_in">memset</span>(dp ,<span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + (G[i][j] == <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">if</span>(i + j - <span class="number">1</span> - dp[i][j] &lt;= k) G[i][j] = <span class="string">'a'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.push(pii(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    p[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;pii&gt; tmp;</span><br><span class="line">      <span class="keyword">int</span> cur = <span class="number">200</span>;</span><br><span class="line">      <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        tmp.push_back(pq.front());</span><br><span class="line">        cur = min(cur, (<span class="keyword">int</span>)G[pq.front().first][pq.front().second]);</span><br><span class="line">        pq.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = tmp[i].first, y = tmp[i].second;</span><br><span class="line">        <span class="keyword">if</span>(cur == (<span class="keyword">int</span>)G[x][y]) &#123;</span><br><span class="line">          p[x][y] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(ok(x+<span class="number">1</span>, y)&amp;&amp;!vis[x+<span class="number">1</span>][y]) &#123;</span><br><span class="line">            vis[x+<span class="number">1</span>][y] = <span class="number">1</span>;</span><br><span class="line">            pq.push(pii(x+<span class="number">1</span>, y));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(ok(x, y+<span class="number">1</span>)&amp;&amp;!vis[x][y+<span class="number">1</span>]) &#123;</span><br><span class="line">            vis[x][y+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            pq.push(pii(x, y+<span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.clear();</span><br><span class="line">    ret.push_back(G[n][n]);</span><br><span class="line">    dfs(n,n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces Mail.Ru Cup 2018 Round 1] D. Changing Array (异或和，贪心)</title>
      <link href="/blog/2018/10/19/CF1054D/"/>
      <url>/blog/2018/10/19/CF1054D/</url>
      <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1054/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1054/problem/D</a></p><p><strong>一个人有$n$个二进制最高位$1%不超过$k$位的数，现在允许每一个数按位取反，统计这个数列中最多有多少个区间异或和不是0。</strong></p><a id="more"></a><p>发现一个重要的性质是，每一个区间内有两个数进行取反操作的话，实际就是没有进行取反操作。因为取反操作可以看做是一个数对$2^k-1$异或，两个数进行取反的话，那么就是异或$2^k-1$两次，就被抵消了。</p><p>假设前缀和为$sum$的点有$k$个，那么一定有$C_{k-1}^2$种构成区间异或和为0的方式，现在的问题就是尽量减少每一种$sum$出现的次数了。</p><p>于是我们可以贪心地去比每一个数和它翻转后与前缀和异或后的次数，每次往出现少的异或和上加。总的贡献是$\sum_i C^2_{cnt_i-1}$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL a[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">auto</span> rev = [=](LL x) &#123; <span class="keyword">return</span> x ^ ((<span class="number">1L</span>L &lt;&lt; (LL)k) - <span class="number">1</span>); &#125;;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    LL ret = <span class="number">1L</span>L * (n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    cnt.clear();</span><br><span class="line">    cnt[sum]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">      <span class="keyword">if</span>(cnt[sum^a[i]] &gt; cnt[sum^rev(a[i])]) sum ^= rev(a[i]);</span><br><span class="line">      <span class="keyword">else</span> sum ^= a[i];</span><br><span class="line">      cnt[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : cnt) &#123;</span><br><span class="line">      ret -=  <span class="number">1L</span>L * (p.second - <span class="number">1</span>) * p.second / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[C++] 闭包的capture（捕获）方式</title>
      <link href="/blog/2018/10/19/Cpp-capture/"/>
      <url>/blog/2018/10/19/Cpp-capture/</url>
      <content type="html"><![CDATA[<p>最近刷题喜欢用闭包把函数全部写到main中，通常一个函数可以这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; f = [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x; &#125;;</span><br></pre></td></tr></table></figure><p>但是在闭包[]中可以添加=或&amp;两个运算符，查过cpp reference后，这个叫capture（捕获），即<strong>使用闭包外的变量的方式</strong>。讨论这两个运算符：</p><p>[=](){}：这是对闭包外变量进行const引用的形式，即不允许修改闭包外的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> p = [=]()&#123;</span><br><span class="line">  x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这段代码编译会报错，因为=捕获不允许修改外变量。</p><p>[&amp;](){}：这是对闭包外变量进行引用的形式，可以修改闭包外的变量，并且保留为修改后的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> p = [&amp;]()&#123;</span><br><span class="line">  x = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line">p();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>而这段代码会输出4，因为闭包捕获到外部变量后将其修改并保留。</p><p>除此之外，还可以声明特定变量使用特定的捕获方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a,&amp;b]。将a按值进行传递，b按引用进行传递。</span><br><span class="line">[=,&amp;a,&amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</span><br><span class="line">[&amp;,a,b]。除a和b按值进行传递外，其他参数都按引用进行传递。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[GCJKickstart2018RoundB] B. Sherlock and the Bit Strings</title>
      <link href="/blog/2018/10/18/GCJKickstart2018RoundB-B-Sherlock-and-the-Bit-Strings/"/>
      <url>/blog/2018/10/18/GCJKickstart2018RoundB-B-Sherlock-and-the-Bit-Strings/</url>
      <content type="html"><![CDATA[<p><a href="https://code.google.com/codejam/contest/10284486/dashboard#s=p1" target="_blank" rel="noopener">https://code.google.com/codejam/contest/10284486/dashboard#s=p1</a></p><p>给一个长为n的01串，现在规定在串的一些区间$[A_i,B_i]$中至少存在$C_i$个1，求满足条件的字典序为第$p$大的串。</p><a id="more"></a><p>小数据可以直接暴力，记下空位和$p$的二进制形式，然后从低到高扫01串就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL p;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="built_in">string</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span> ,&amp;n,&amp;k,&amp;p);</span><br><span class="line">    p--;</span><br><span class="line">    pos.clear();</span><br><span class="line">    ret.resize(n); fill(ret.begin(), ret.end(), <span class="string">'#'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">      <span class="keyword">if</span>(c[i]) ret[a[i]<span class="number">-1</span>] = <span class="string">'1'</span>;</span><br><span class="line">      <span class="keyword">else</span> ret[a[i]<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">      pos.emplace_back(p&amp;<span class="number">1</span>);</span><br><span class="line">      p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ret[j] == <span class="string">'1'</span> || ret[j] == <span class="string">'0'</span>) j--;</span><br><span class="line">        ret[j--] = <span class="string">'1'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(pos[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ret[j] == <span class="string">'1'</span> || ret[j] == <span class="string">'0'</span>) j--;</span><br><span class="line">        ret[j--] = <span class="string">'0'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ret[i] == <span class="string">'#'</span>) ret[i] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _++ &lt;&lt; <span class="string">": "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Kickstart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[GCJKickstart2018RoundB] A. No Nine</title>
      <link href="/blog/2018/10/18/GCJKickstart2018RoundB-A-No-Nine/"/>
      <url>/blog/2018/10/18/GCJKickstart2018RoundB-A-No-Nine/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/10284486/dashboard#s=p0" target="_blank" rel="noopener">https://code.google.com/codejam/contest/10284486/dashboard#s=p0</a></p><p>求$[L,R]$内不被9整除且每一位都不是9的数的个数。</p><a id="more"></a><p>经典数位dp，根据$(x+y)\%m=(x\%m+y\%m)\%m$，直接维护前$l$位对9取模的值，向后dfs到最后一位发现模数不是0就计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> digit[maxn];</span><br><span class="line">LL dp[maxn][maxn];</span><br><span class="line">LL L, R;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mod, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!flag &amp;&amp; ~dp[l][mod]) <span class="keyword">return</span> dp[l][mod];</span><br><span class="line">  <span class="keyword">if</span>(l == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(mod % <span class="number">9</span> == <span class="number">0</span>) <span class="keyword">return</span> dp[l][mod] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[l][mod] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> pos = flag ? digit[l] : <span class="number">9</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pos; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">    ret += dfs(l<span class="number">-1</span>, (mod*<span class="number">10</span>+i)%<span class="number">9</span>, flag&amp;&amp;(i==pos));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!flag) dp[l][mod] = ret;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x) &#123;</span><br><span class="line">    digit[++tot] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(tot, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;L,&amp;R);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, f(R)-f(L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Kickstart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[GCJKickstart2018RoundA] B. Lucky Dip</title>
      <link href="/blog/2018/10/18/GCJKickstart2018RoundA-B-Lucky-Dip/"/>
      <url>/blog/2018/10/18/GCJKickstart2018RoundA-B-Lucky-Dip/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/9234486/dashboard#s=p1" target="_blank" rel="noopener">https://code.google.com/codejam/contest/9234486/dashboard#s=p1</a></p><p><strong>有n个数，允许k次“取一个数再放回重新取”的操作，一个人希望拿到最大的那个数字。求取到数字最大的期望。</strong></p><a id="more"></a><p>$k=0$时，期望就是均值，即$E_0=\frac{1}{n}\sum_{i=0}^nv_i$。</p><p>$k=1$时，每取到一个数可以有一次机会选择是否放回，但是期望拿到数字最大，因此要选取比$k=0$时期望大的数，$E_1=\frac{1}{n}\sum_{i=1}^n\mbox{max}(v_i,E_0)$。</p><p>可以推广：$E_k=\frac{1}{n}\sum_{i=1}^n\mbox{max}(v_i,E_{k-1})$。</p><p>假设计算$E_k$时，有$t$个数字使得$E_{k-1}$比$v_i$大，那么就有$n-t$个数使$E_{k-1}$比$v_i$小，他们的对$E_k$的贡献分别是$tE_{k-1}$和$\sum_{v&lt;E_{k-1}}v$。我们可以对$v$排序，前者的$t$可以二分得到，后者可以维护一个前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20020</span>;</span><br><span class="line"><span class="keyword">double</span> v[maxn], sum[maxn];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> E)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[mid] &lt;= E) &#123;</span><br><span class="line">      ret = mid;</span><br><span class="line">      lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">    <span class="keyword">double</span> E = <span class="number">.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v+<span class="number">1</span>, v+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i<span class="number">-1</span>] + v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> t = bs(E);</span><br><span class="line">      E = (sum[n]-sum[t]) + t * E;</span><br><span class="line">      E /= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %.8f\n"</span>, _++, E);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Kickstart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期望, 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[GCJKickstart2018RoundA] A. Even Digits</title>
      <link href="/blog/2018/10/18/GCJKickstart2018RoundA-A-Even-Digits/"/>
      <url>/blog/2018/10/18/GCJKickstart2018RoundA-A-Even-Digits/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://code.google.com/codejam/contest/9234486/dashboard#s=p0" target="_blank" rel="noopener">https://code.google.com/codejam/contest/9234486/dashboard#s=p0</a></p><p><strong>给一个数，这个数每次只能+1或-1，问把这个数变成每一位都是偶数的最少步数。</strong></p><a id="more"></a><p>其实就是说，求和这个数的差的绝对值最小的每位都是偶数的数。</p><p>考虑比这个数小的数，要最大化这个数就是把这个数最高位的奇数-1后面的数都是8；</p><p>考虑比这个数大的数，要最小化这个数就是把这个数最高位的奇数+1后面的数都是0，但是要考虑当前最高位是9的时候，再+1是不可能的了，所以这一个情况就不需要++。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span> maxn = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">down</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> y = x;</span><br><span class="line">  LL a = stoull(x);</span><br><span class="line">  y[<span class="number">0</span>]--;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; y.length(); i++) y[i] = <span class="string">'8'</span>;</span><br><span class="line">  LL b = stoull(y);</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">up</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> y = x;</span><br><span class="line">  LL a = stoull(x);</span><br><span class="line">  <span class="keyword">if</span>(y[<span class="number">0</span>] != <span class="string">'9'</span>) &#123;</span><br><span class="line">    y[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; y.length(); i++) y[i] = <span class="string">'0'</span>;</span><br><span class="line">    LL b = stoull(y);</span><br><span class="line">    <span class="keyword">return</span> b - a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>((s[i] - <span class="string">'0'</span>) % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      ret = min(down(s.substr(i, n-i)), up(s.substr(i, n-i)));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, _++, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Kickstart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造, 模拟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[读书笔记] Neural Networks and Deep Learning Chapter 1</title>
      <link href="/blog/2018/10/08/nndl_ch1/"/>
      <url>/blog/2018/10/08/nndl_ch1/</url>
      <content type="html"><![CDATA[<p>这是我阅读在线书籍《Neural Networks and Deep Learning》的笔记，这篇博文是第一章的。没什么营养，因为大部分都知道了，于是草草略过。</p><p>章节链接： <a href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html</a></p><a id="more"></a><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h3><p>科普。</p><h3 id="words"><a href="#words" class="headerlink" title="words"></a><strong>words</strong></h3><ol><li>effortlessly：毫不费力地</li><li>deceptive：欺骗性的</li><li>superbly：雄伟地（文中表程度大）</li><li>astoundingly：令人惊讶地</li><li>stupendously：（同上）</li></ol><hr><p>科普。。</p><p><strong>words</strong></p><ol><li>morass：沼泽、困境</li><li>caveats：警告</li></ol><hr><p>科普。。。讲下NN可以从一堆数据中学习到一些特征，然后去预测一些没见过的数据。并且数据越多效果越好。</p><hr><p>介绍第一章要搞什么（手撸一个NN，用来识别手写数字，就74行），随后的章节要搞什么（想一些trick提升NN的acc之类）。</p><p><strong>words</strong></p><ol><li>intervention：介入、调停</li></ol><hr><p>手写数字识别这个问题简单，非常适合用来举例（大概这样可以把注意力更多地集中到NN本身之类？）。<em>it’s challenging - it’s no small feat to recognize handwritten digits - but it’s not so difficult as to require an extremely complicated solution, or tremendous computational power.</em><br>(这是一项具有挑战性的工作——识别手写的数字绝非易事——但是拥有一个极其复杂的解决方案，或者是巨大的计算能力的话就不难了)，之后会讲一些扩展。</p><p><strong>words</strong></p><ol><li>throughout：自始至终</li></ol><hr><p>这章的重点：</p><p>两类神经元：<strong>感知机（Perceptrons）</strong>和<strong>sigmoid函数</strong>。</p><p>神经网络的标准训练方法：<strong>随机梯度下降（Stochastic gradient descent, SGD）</strong></p><p><em>Amongst the payoffs, by the end of the chapter we’ll be in position to understand what deep learning is, and why it matters.</em>最后会讨论一下DL为什么会matters。</p><hr><h3 id="Perceptrons"><a href="#Perceptrons" class="headerlink" title="Perceptrons"></a><strong>Perceptrons</strong></h3><p>感知机（<a href="http://books.google.ca/books/about/Principles_of_neurodynamics.html?id=7FhRAAAAMAAJ）是一类人工神经元，由科学家Frank" target="_blank" rel="noopener">http://books.google.ca/books/about/Principles_of_neurodynamics.html?id=7FhRAAAAMAAJ）是一类人工神经元，由科学家Frank</a> Rosenblatt在上世纪50到60年代间完成。</p><p>不过目前非常流行的一类模型是神经网络（Neural Network），最重要的一部分是sigmoid（就个非线性函数）。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz0.png" alt="img"></p><p>上图是个最原始感知机的神经元，嗯。</p><p>假设这个perceptron有三个输入$x_1,x_2,x_3$，中间的圈里一系列权重$w_1,w_2,w_3$。输入来的时候，我们首先做向量乘法$sum=\sum_i w_ix_i$，然后要和一个阈值$threshold$比较得到$output$：<br>$$<br>output=<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ sum \leq threshold \<br>1, \ \ otherwise.<br>\end{array}<br>\right.<br>$$</p><hr><p>举个例子。</p><p><strong>words</strong></p><ol><li>transit：公共交通</li><li>adore：崇拜、爱慕</li><li>loathe：讨厌</li></ol><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz1.png" alt="img"></p><p>每一列称之为<strong>层（Layer）</strong>，第一层的三个神经元对输入分别以自己的权重进行处理（每层的处理就是向量乘积，最后获得<strong>一个值</strong>），得到的输出（可能不用threshold判断）再分别给第二层的每一个神经元，第二层的决策会更加复杂，因为第二层的输入是通过第一层抽象过的结果。</p><p>实际上每个神经元的输入可以有很多，但是输出都是一个。这么画是为了说明层与层之间是如何联系起来的。</p><p><strong>words</strong></p><ol><li>plausible：可信的</li><li>subtle：微妙的</li><li>engage：从事，参与</li><li>sophisticated：复杂的</li><li>incidentally：顺便，附带地</li></ol><hr><p>把上述神经元的计算过程简化下：<br>$$<br>output=<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ \omega\cdot x+b \leq 0 \<br>1, \ \ otherwise.<br>\end{array}<br>\right.<br>$$<br>$b$就是bias，也是threshold。表示一种“输出1”的测量(<em>the bias as a measure of how easy it is to get the perceptron to output a 1.</em> )。</p><p><strong>words</strong></p><ol><li>cumbersome：冗杂的，累赘的</li><li>notation：标志、符号、记号</li><li>reminder：剩下的</li></ol><hr><p>举了个简单的例子，说明感知机可以做与、或、非之类的逻辑操作：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz2.png" alt="img"></p><p>上图就是一个与非门，实际上感知机能做任何逻辑操作（因为这东西可以实现一切基本逻辑操作，那么就像连电路一样把那些门都连起来就行了）。</p><p>这是为了说明，感知机可以和其他计算设备一样强大。然而并非仅此而已，我们还可以在这个简单的模型上使用学习算法，使这个模型可以自己调整每一个神经元中的weights和bias，这种调节来自外部刺激（external stimuli），而非手动调整。</p><p><strong>words</strong></p><ol><li>equivalent：等价物</li><li>notable：值得注意的</li></ol><hr><p><strong>Sigmoid Neurons</strong></p><p>先介绍更新权重的时候，可以表示成$\omega+\Delta\omega$的形式，这样就可以学习了（当然都是向量）。也就是，我们希望每次output反过头过来传个值，然后更新这个网络。</p><p>但是上述的naïve perceptron在输出的时候都会经过一个突变函数（非零即一），通过这个门以后后面的神经元就完全没法恒量差别了（就像雅思）。</p><p>引出sigmoid：</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz9.png" alt="img"></p><p>这里output为$\sigma(z) \equiv\dfrac{1}{1+e^{-z}}=\dfrac{1}{1+exp(-\sum_jw_jx_j-b)}$。</p><p>这样做的好处是对之前用的step function做了平滑处理，使得变化看起来不会过于激烈。看看原文是如何解释的：</p><p><em>The smoothness of $\sigma$ means that small changes $\Delta w_j$ in the weights and $\Delta b$ in the bias will produce a small change $\Delta output$ in the output from the neuron.</em></p><p>就是说变化后的w和b在处理完输入接着输出到output的时候，使得output的变化不至于太剧烈，output可以近似为下面的值：<br>$$<br>  \Delta \mbox{output} \approx \sum_j \frac{\partial \, \mbox{output}}{\partial w_j}<br>  \Delta w_j + \frac{\partial \, \mbox{output}}{\partial b} \Delta b<br>$$<br>确实可以用微分来解释，因为$\mbox{output}$是一个n元一次线性方程，那么对它微分就是各项偏导之和，而微分的几何意义就是表示偏移量（变化量）的。</p><p>我们需要有一个平滑函数$\sigma$来简化运算，由于指数在微分时的性质（无限可微），所以构造了sigmoid函数作为激活函数（sigmoid还有一个著名性质就是导数可以用自身表达）。</p><p>如何解释经过sigmoid的输出？</p><p>最大的不同是：经过sigmoid平滑后，输出由原来的0或1变为[0,1]中任意实数（希望变成0 1的话直接设阈值max一下就ok）。</p><p><strong>words</strong></p><ol><li>terrific：可怕的</li><li>property：性质、性能</li><li>occasionally：偶尔、偶然地、不定期地</li><li>legitimate：合法的</li><li>convention：约定</li></ol><hr><p><strong>Exercises</strong></p><p>part I：证明感知机中所有w、b都乘一个大于0的常数c，这个网络的输出不会改变。</p><p>证：$<br>\mbox{output}=<br>\left{<br>\begin{array}{lll}<br>0, \ \ if\ \omega\cdot x+b \leq 0 \<br>1, \ \ otherwise.<br>\end{array}<br>\right.$，乘一个整数不会影响。</p><p>part II：给一个感知机，对于任意输入$x$，都有$\omega\cdot x+b \not=0$。现在把所有神经元都替换成sigmoid神经元，再乘一个大于0的常数c，证明假如c趋于无穷大的时候，有sigmoid神经元的模型就会退化成没有sigmoid的网络。假如$\omega\cdot x+b =0$的时候又会有什么不同？</p><p>(1). 证：$c \to +\infty,c&gt;0$时，可以分别将$lim$带入上述$\sigma$函数中求极限，发现分别收敛于0和1。</p><p>(2). 结果会输出0，而sigmoid会输出0.5，是不一样的。</p><hr><h3 id="The-architecture-of-neural-networks"><a href="#The-architecture-of-neural-networks" class="headerlink" title="The architecture of neural networks"></a><strong>The architecture of neural networks</strong></h3><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz10.png" alt="img"></p><p>上图是一个网络，从左到右开始，第1层叫输入层（input layer），每个元素叫输入神经元；第2层叫隐层（hidden layer），未必只有一层；第3层叫输出层（output layer）。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz11.png" alt="img"></p><p>有多层的网络有时候也被称作“多层感知机”，这是有历史原因的。所以现在完全可以认为NN=MLP（MLP里的感知层（简单的线性操作）换成sigmoid）。</p><p>然后介绍识别手写数字的任务，提到最简单的构建NN的方法就是把一张图片（例如$64\times 64$）的灰度信息直接保存（输入直接是$4096$维，当然要把灰度归一化到[0,1]内），然后走一遍网络取argmax。同时，hidden layer的设计会非常多样。</p><p>前馈神经网络：通常定义只允许前面的层向后面的层输出，不允许反过来（不允许有环）。但是现在已经有一些可以带环的网络（RNN）。</p><p><strong>words</strong></p><ol><li>terminology：术语</li><li>philosophical：哲学的</li><li>rules of thumb：经验法则（大拇指规则）</li><li>heuristics：启发、尝试（法）</li></ol><hr><h3 id="A-simple-network-to-classify-handwritten-digits"><a href="#A-simple-network-to-classify-handwritten-digits" class="headerlink" title="A simple network to classify handwritten digits"></a><strong>A simple network to classify handwritten digits</strong></h3><p>本科做过了这段懒得读了。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/tikz12.png" alt="img"></p><p>这个图挺帅，意思就是用一层hidden，然后输入是$28\times 28=784$维，然后最后输出10个分类的logits。</p><p>这里讨论了一个很有趣的问题：为什么输出是10个而不是4个（因为$2^4=16&gt;10$可以表示所有我们希望的数字情况）？</p><p>个人认为隐层中每次处理后都会提取图像中的某一部分的特征，预测的时候被激活与否的影响因素为某部分是不是有这个特征，有某种特征对应0-9这十个数是很容易的，然而要对应二进制编码则很难表示。</p><p><strong>words</strong></p><ol><li>sake：利益、理由</li></ol><p>Exercise懒得做了，只要对应好四个位置给权值就行了。</p><hr><h3 id="Learning-with-gradient-descent"><a href="#Learning-with-gradient-descent" class="headerlink" title="Learning with gradient descent"></a><strong>Learning with gradient descent</strong></h3><p>介绍mnist数据集，同时设计一些必要的环节：</p><p>$\mbox{cost function}$：$\begin{eqnarray}  C(w,b) \equiv \frac{1}{2n} \sum_x | y(x) - a|^2\end{eqnarray}.$（均方误差），训练过程中的目标是最小化$\mbox{cost function}$。</p><p>然后讲梯度下降：</p><p>$\begin{eqnarray}    \Delta C \approx \frac{\partial C}{\partial v_1} \Delta v_1 +   \frac{\partial C}{\partial v_2} \Delta v_2. \end{eqnarray}$ 我们的目标是希望使$\Delta C$变负，$\Delta v_1,\Delta v_2$分别是两个不同方向的偏移量。因此可以说$\Delta C$是两个方向偏移量的叠加。</p><p>定义梯度向量：$\begin{eqnarray}    \nabla C \equiv \left( \frac{\partial C}{\partial v_1},    \frac{\partial C}{\partial v_2} \right)^T. \end{eqnarray}$</p><p>所以化简后，变化量可以表示成：$\begin{eqnarray}    \Delta C \approx \nabla C \cdot \Delta v. \end{eqnarray}$</p><p>定义$\begin{eqnarray}    \Delta v = -\eta \nabla C\end{eqnarray}$，$\eta$是一个极小的正数（学习率），$\Delta C \approx -\eta \nabla C \cdot \nabla C = -\eta |\nabla C|^2$，$\Delta C \leq0$恒成立知，$C$是一个只减不增的值，于是我们在算出的$\Delta C$（我们希望让$\Delta C$一直是负数，也就是$C$一直下降）的同时，算出$v$移动后的位置$v’=v-\eta \nabla C$。</p><p><img src="http://neuralnetworksanddeeplearning.com/images/valley_with_ball.png" alt="img"></p><p>就像这个绿球一直往地势低的地方滚，直到最低点（极低点）为止。</p><p>到$m$维的向量空间，$\nabla C$的定义会得到扩展：<br>$$<br>\begin{eqnarray}<br>  \nabla C \equiv \left(\frac{\partial C}{\partial v_1}, \ldots,<br>  \frac{\partial C}{\partial v_m}\right)^T<br>\end{eqnarray}<br>$$<br>（对于$\Delta v$中的每维变量，都会有一个对应的梯度去更新它。）</p><p>通常训练神经网络的工作都是面对这样一个最优化问题，梯度下降算法可以看做是一个采用最少步骤使得$C$下降的一个方法。</p><p><strong>words</strong></p><ol><li>quadratic：二次的</li><li>ah-doc：特别的</li><li>recap：翻造、重申</li><li>distract：转移、分心</li><li>lurk：潜伏、埋伏、隐藏</li></ol><hr><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a><strong>Exercise</strong></h3><p><a href="http://neuralnetworksanddeeplearning.com/chap1.html#exercises_647181" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html#exercises_647181</a></p><p>Part I. 证明上述的假设，即：当$\left|v\right| = \epsilon, \Delta v =-\eta \nabla C​$时，其中$\epsilon &gt;0​$为很小的一个数，且当$\eta =\dfrac{\epsilon}{\left| \nabla C\right|}​$时，$\Delta C=\nabla C \cdot \Delta v​$可以取到最小值。（也就是要证给定步长，我们沿着梯度的方向总能找到最小值）</p><p>证明：当$\Delta C = \nabla C \cdot \Delta v$且$\left|v\right|=\epsilon$时，令$\Delta v=-\eta \nabla C=(-\epsilon/\left|\Delta C\right|)\nabla C$，则有：<br>$$<br>\begin{align}<br>\Delta C &amp;= \nabla C \cdot \Delta v \<br>&amp;=  \nabla C \cdot  ( -\epsilon/\left|\nabla C\right| ) \nabla C \<br>&amp;= \nabla C ^2 ( -\epsilon/\left|\nabla C\right| ) \<br>&amp;= \left|\nabla C\right| ^2 ( -\epsilon/\left|\nabla C\right| ) \<br>&amp;= -\epsilon \left|\nabla C\right| \<br>&amp;= -\left|\Delta v\right|\left|\nabla C\right|<br>\end{align}<br>$$<br>由柯西-施瓦兹不等式，$\left|u\right|\left|v\right| \ge \left|u \cdot v\right|$得，$\left|\Delta v\right|\left|\nabla C\right|\ge \left| \Delta v \cdot \nabla C \right|$，$-\left|\Delta v\right|\left|\nabla C\right|$必为最小值。</p><p>Part II. 给出一个在多维和一维情况下梯度下降的几何解释。</p><p>答：一维的话就退化成函数求导问题了，就是在一个曲线上找极小值，也就是一个圆点往地势低的地方滚。</p><hr><p>接近物理学球下滚模拟的变种算法不可避免地需要求二阶偏微分，十分复杂。因此书中会引出一些方法来避免这个问题（梯度下降）。</p><p>梯度下降的目标是最小化$\mbox{cost function}\begin{eqnarray}  C(w,b) \equiv   \frac{1}{2n} \sum_x | y(x) - a|^2 \nonumber\end{eqnarray}$.</p><p>反向更新的时候，这样来更新weights和biases：<br>$$<br>\begin{eqnarray}<br>  w_k &amp; \rightarrow &amp; w_k’ = w_k-\eta \frac{\partial C}{\partial w_k} \<br>  b_l &amp; \rightarrow &amp; b_l’ = b_l-\eta \frac{\partial C}{\partial b_l}.<br>\end{eqnarray}<br>$$<br>但是有一个问题，原始的梯度下降里，这个目标函数实际上是在求$C​$在不同$x​$取值时的均值，也就是要把整个dataset都迭代一遍后再去反向传播。</p><p>随机梯度下降（Stochastic gradient descent，SGD）每次选取指定规模的mini-batch去做梯度下降，在mini-batch的大小$m$满足：<br>$$<br>\begin{eqnarray}<br>  \frac{\sum_{j=1}^m \nabla C_{X_{j}}}{m} \approx \frac{\sum_x \nabla C_x}{n} = \nabla C,<br>\end{eqnarray}<br>$$<br>即$m$个输入的平均值要接近于全体输入的平均值，SGD才可近似于naïve GD。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/1539092769209.png" alt="1539092769209"></p><p>带入权值和偏移更新中，公式变成这样：<br>$$<br>\begin{eqnarray}<br>  w_k &amp; \rightarrow &amp; w_k’ = w_k-\frac{\eta}{m}<br>  \sum_j \frac{\partial C_{X_j}}{\partial w_k} \<br>  b_l &amp; \rightarrow &amp; b_l’ = b_l-\frac{\eta}{m}<br>  \sum_j \frac{\partial C_{X_j}}{\partial b_l},<br>\end{eqnarray}<br>$$<br>在SGD时，称把整个数据集经过mini-batch训练一遍为一个epoch，通常要来好几个epoch。</p><p>在算目标函数的时候不要忘记$\frac{1}{n}$（用mini-batch的时候是$\frac{1}{m}$），做一下平均（因为有可能后来添加数据，就是说数据规模不一定的时候会影响到）。</p><p><strong>words</strong></p><ol><li>incidentally：顺便地，偶然一提地</li><li>convention：惯例，约定</li><li>omit：省略、疏忽</li></ol><hr><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a><strong>Exercise</strong></h3><p>提到了mini-batch size=1的时候的一种极限情况。</p><hr><h3 id="Implementing-our-network-to-classify-digits"><a href="#Implementing-our-network-to-classify-digits" class="headerlink" title="Implementing our network to classify digits"></a><strong>Implementing our network to classify digits</strong></h3><p>介绍数据集，和要实现的神经网络。稍微读下代码，其他没什么好看的。</p><hr><h3 id="Toward-deep-learning"><a href="#Toward-deep-learning" class="headerlink" title="Toward deep learning"></a><strong>Toward deep learning</strong></h3><p>又是一些废话。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder199A] 分组(dfs，拉姆齐定理, 随机)</title>
      <link href="/blog/2018/10/07/Nowcoder-199A/"/>
      <url>/blog/2018/10/07/Nowcoder-199A/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/199/A" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/199/A</a></p><p><strong>意思就是给你一个无向图染色，每个点最多有一个相邻点可以染成同色。</strong></p><a id="more"></a><p>我们证明一下解一定存在：</p><p>首先考虑$n&lt;4$，无论如何都能有解，显然成立。</p><p>我们可以画一下最极端的情况是什么样子的…</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/1538920651987.png" alt="1538920651987"></p><p>在这个情况下无法再想这个完全图内加边加点，因此这是个最极端的情况，但是它是有解的。</p><p>那么我们其他的符合条件的图都可以由这个图通过删边加点加边的方式获得并且他们是一个连通图（每个人都认识聚会中的一些人）。</p><p>于是这题就可以解了：</p><p>直接dfs，但是题目最后有个备注很蛋疼，那就是有10%的数据，有一组数据存在某个组里每个人都互相不认识。</p><p>所以我们考虑尽可能先处理那个分组里的点，这个分组里的点尽量首先安排。但是我们又不能知道那个组都有哪些个点，因此我们考虑把每一个点的边打乱一下保存再dfs，最后再加个特判就ok。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  vis[u] = id;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(!vis[v]) dfs(v, u, <span class="number">3</span>-vis[u]);</span><br><span class="line">    <span class="keyword">if</span>(vis[v] == vis[u]) cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span>) vis[u] = <span class="number">3</span> - vis[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      random_shuffle(G[i].begin(), G[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) dfs(i, <span class="number">-1</span>, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt2 == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,vis[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,vis[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">      <span class="keyword">if</span>(vis[i] == <span class="number">1</span>) cnt1++;</span><br><span class="line">      <span class="keyword">else</span> cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> dfs </tag>
            
            <tag> 随机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder208A] Birthday(最小费用最大流)</title>
      <link href="/blog/2018/10/06/Nowcoder-208A/"/>
      <url>/blog/2018/10/06/Nowcoder-208A/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/206/A" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/206/A</a></p><p><strong>题意很简单，给你n个球，m个桶。现在每个球最多可以丢到两个桶中的一个，同时规定每个桶中球的平方和为代价。现在希望你找一个方案，使得代价最小。</strong></p><a id="more"></a><p>一开始random_shuffle后回溯在60%左右T掉。。</p><p>回溯的时候往一个当前有$x$个球的桶里丢一个球的时候，代价的增幅为$(x+1)^2-x^2$，于是来了灵感。</p><p>我们可以把丢球的过程看作节点，每次往一个当前有$x$个球的桶里多丢一个球的时候，意味着代价增加了$(x+1)^2-x^2$，而且这个代价是单调递增的。</p><p>我们考虑建图，超级源、汇中间有n个代表球的节点和m个代表桶中球数量的节点：</p><p>由源点出发，n个节点代表球，各连接一条，流量为1，费用为0的边。</p><p>接着从n个节点向m个节点出发，代表球可以向某两个桶里丢，流量为1，费用为0。</p><p>接着由m个桶向汇点连边，每个桶连n条边，流量为1，费用为该桶+1个球后代价的涨幅。由于涨幅是递增的，因此在求最小费用最大流的时候肯定从小到大流。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, next;</span><br><span class="line">  LL c, w;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">7070</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">0x3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">const</span> LL inf = (<span class="number">1L</span>L&lt;&lt;<span class="number">55</span>);</span><br><span class="line"><span class="keyword">int</span> tot, head[maxn];</span><br><span class="line">LL dist[maxn];</span><br><span class="line">LL cost, flow;</span><br><span class="line">Node e[maxm];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> S, T, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S = T = N = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c:容量, w:费用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL c, LL w)</span> </span>&#123;</span><br><span class="line">  e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">  e[tot].u = v; e[tot].v = u; e[tot].c = <span class="number">0</span>; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dist[i] = inf;</span><br><span class="line">    visit[i] = <span class="number">0</span>;</span><br><span class="line">    pre[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">  Q.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  pre[s] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q.front();</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(e[j].c &gt; <span class="number">0</span> &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123;</span><br><span class="line">        dist[e[j].v] = dist[u] + e[j].w;</span><br><span class="line">        pre[e[j].v] = j;</span><br><span class="line">        <span class="keyword">if</span>(!visit[e[j].v]) &#123;</span><br><span class="line">          Q.push(e[j].v);</span><br><span class="line">          visit[e[j].v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return dist[t] &lt; 0; // 求可行流</span></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 求最小费用流</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ChangeFlow</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  LL det = mod;</span><br><span class="line">  <span class="keyword">int</span> u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    det = min(det, e[u].c);</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    e[u].c -= det;</span><br><span class="line">    e[u ^ <span class="number">1</span>].c += det;</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> det;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">MinCostFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  LL mincost, maxflow;</span><br><span class="line">  mincost = maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(spfa(s, t, n)) &#123;</span><br><span class="line">    LL det = ChangeFlow(t);</span><br><span class="line">    mincost += det * dist[t];</span><br><span class="line">    maxflow += det;</span><br><span class="line">  &#125;</span><br><span class="line">  cost = mincost;</span><br><span class="line">  flow = maxflow;</span><br><span class="line">  <span class="keyword">return</span> mincost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    init();</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>; N = T + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) adde(S, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">      adde(i, n+a, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      adde(i, n+b, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        adde(i+n, T, <span class="number">1</span>, j*j-(j<span class="number">-1</span>)*(j<span class="number">-1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, MinCostFlow(S, T, N));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小费用最大流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[总结] 反素数</title>
      <link href="/blog/2018/10/05/emirp/"/>
      <url>/blog/2018/10/05/emirp/</url>
      <content type="html"><![CDATA[<p><strong>素数</strong>的定义可以为：因子只有2个的数（一个是1，另一个是本身），也就是因子最少的数。</p><p>那么，<strong>反素数</strong>可以定义成<strong>因子数最多的数，假如因子个数相同那么是最小的那个数</strong>，反素数是相对于一个集合来说的（比如在$n$个数以内的数）。</p><p>简而言之，<strong>因素最多并且值最小的数，就是反素数</strong>。</p><a id="more"></a><p>朴素求法：利用整数唯一分解定理若$x=p_1^{k_1}p_2^{k_2}…p_n^{k_n}$，那么$x$就有$(k_1+1)(k_2+1)…(k_n+1)$个因数。给某个集合扫一遍求下$max$即可。</p><p>反素数有两个特点：</p><ol><li>反素数肯定是从$2$开始的连续素数的幂次形式的乘积。</li><li>数值小的素数的幂次大于等于数值大的素数：$x=p_1^{k_1}p_2^{k_2}…p_n^{k_n}$，那么有$k1 \geq k2 \geq…k_n$。    </li></ol><p>解释：</p><ol><li>反证，若存在不从$2$开始的连续素数之积$p$，那么必然存在一个从2开始的连续素数之积$q$，除了一个$2$以外，其他值均与$p$相等，而此时$q &lt; p$。</li><li>若存在$k_i, k_j$，使得$i&lt;j,k_i&gt;k_j$成立。那么我们可以交换一下$p_i$与$p_j$，使得这个数更小。</li></ol><p>想要求给定自然数$n$，求$[1,n]$内的反素数。这个问题似乎没有什么更加牛X的解决方法，实际上还是要通过<strong>枚举</strong>的方法，为了解决这个问题，我们再提出两个问题：</p><ol><li><strong>对于给定的$n$，要枚举到哪一个素数</strong>：枚举到$\leq n$的素数就可以。</li><li><strong>枚举多少次幂</strong>：实际上枚举到最小素数$p$的$k$次幂，使得$p^k&gt;n$，那么枚举到的最大幂次肯定要小于$k$。</li></ol><p>一般这类问题都是DFS+一些分支限界枚举答案的。</p><hr><p>练习1：<a href="http://codeforces.com/contest/27/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/27/problem/E</a></p><p>题意：找含有$n$个因子的最小的那个数，这个数不超过1E18。</p><p>分析：</p><ol><li>设这个数字是$m$，那么可以设$m=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$，其中$(k_1+1)(k_2+1)…(k_r+1)=n$。我们由上述<strong>结论1</strong>可以求出来$p_i$的上界：取$k_1=$2，那么最多也就是$\lceil log_21000 \rceil=10$个不同的素数，贪心取最小的前10个素数就可以。<del>分析到这里就可以打表了。</del></li><li>再考虑这个数在1E18内的问题，也就是$k$的取值范围。取最小的$p=2$，那么顶多是60层。</li></ol><p>于是我们就可以DFS，在每层（即每个素数）暴力枚举这个数选取次数，然后维护上一层的数值以及因数个数就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[maxn] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;;</span><br><span class="line">ull ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, ull cur, <span class="keyword">int</span> cnt, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(depth &gt;= <span class="number">11</span> || cnt &gt; n) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(cnt == n) &#123;</span><br><span class="line">    ret = min(ret, cur);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt * (i + <span class="number">1</span>) &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    cur *= (ull)p[depth];</span><br><span class="line">    dfs(depth+<span class="number">1</span>, cur, cnt*(i+<span class="number">1</span>), i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    ret = <span class="number">1E18</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder190H] CSL的校园卡</title>
      <link href="/blog/2018/09/15/nowcoder190h/"/>
      <url>/blog/2018/09/15/nowcoder190h/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/190/H" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/190/H</a></p><p><strong>中文题面不解释。</strong></p><a id="more"></a><p>很容易想到dp，但是要仔细设计一下状态。</p><p>两个人一起走，可以直接定义状态为dp(ax,ay,bx,by)，但是要维护每个可行点都遍历过，那么可以二进制位压。状态记成dp(sta,ax,ay,bx,by)，然后常规dfs就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ax, ay, bx, by, st;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, es;</span><br><span class="line"><span class="keyword">char</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">16</span>][maxn][maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; (G[x][y] == <span class="string">'S'</span> || G[x][y] == <span class="string">'O'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">  <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">  dp[<span class="number">1</span>&lt;&lt;id(sx, sy)][sx][sy][sx][sy] = <span class="number">0</span>;</span><br><span class="line">  q.push(&#123;sx, sy, sx, sy, <span class="number">1</span> &lt;&lt; id(sx, sy)&#125;);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    Node t = q.front(); q.pop();</span><br><span class="line">    <span class="keyword">if</span>(t.st == es) <span class="keyword">return</span> dp[es][t.ax][t.ay][t.bx][t.by];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> ax = t.ax + dx[i], ay = t.ay + dy[i];</span><br><span class="line">      <span class="keyword">if</span>(!ok(ax, ay)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bx = t.bx + dx[j], by = t.by + dy[j];</span><br><span class="line">        <span class="keyword">if</span>(!ok(bx, by)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> st = t.st | (<span class="number">1</span> &lt;&lt; id(ax, ay));</span><br><span class="line">        st |= (<span class="number">1</span> &lt;&lt; id(bx, by));</span><br><span class="line">        <span class="keyword">if</span>(dp[st][ax][ay][bx][by] == <span class="number">-1</span>) dp[st][ax][ay][bx][by] = dp[t.st][t.ax][t.ay][t.bx][t.by] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        q.push(&#123;ax, ay, bx, by, st&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    es = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[i][j] == <span class="string">'O'</span>) es |= (<span class="number">1</span> &lt;&lt; id(i, j));</span><br><span class="line">        <span class="keyword">if</span>(G[i][j] == <span class="string">'S'</span>) &#123;</span><br><span class="line">          x = i, y = j;</span><br><span class="line">          es |= (<span class="number">1</span> &lt;&lt; id(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs(x, y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> bfs </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Nowcoder180D] xor序列 (线性基)</title>
      <link href="/blog/2018/09/08/Nowcoder-180D/"/>
      <url>/blog/2018/09/08/Nowcoder-180D/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://www.nowcoder.com/acm/contest/180/D" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/180/D</a></p><p><strong>题意就是给你$n$个数和$q$次询问，每次问你一个数$x$能不能被上述$n$个数之间随意异或得到。</strong></p><a id="more"></a><p>这题可以想到构造一组32个异或方程的方程组，每一个方程代表数位中某一位的异或结果。我们需要判断这个方程组是否有解。考虑方程组有无解实际上就是判断这个方程组的参数矩阵构成的一组基底能否表示每次查询的$x$，因此我们可以用线性基的技术解决这个问题。</p><p>关于线性基可以学习这篇blog：<a href="https://blog.sengxian.com/algorithms/linear-basis" target="_blank" rel="noopener">https://blog.sengxian.com/algorithms/linear-basis</a></p><p>由于我们不关心这组方程中最大线性无关组具体是什么，因此我们可以直接向无关组中判断插入每一个方程（就是每一个数字）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, x, y;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">31</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(!a[j]) &#123;</span><br><span class="line">            a[j] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          x ^= a[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">      x ^= y;</span><br><span class="line">      <span class="built_in">memcpy</span>(b, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">31</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(!b[j]) &#123;</span><br><span class="line">            b[j] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          x ^= b[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, x == <span class="number">0</span> ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Nowcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你好，UCAS</title>
      <link href="/blog/2018/09/04/Hello-UCAS/"/>
      <url>/blog/2018/09/04/Hello-UCAS/</url>
      <content type="html"><![CDATA[<p>70多公里，坐了一小时左右的车，终于到这里了。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/tsg.jpg" alt="img"></p><a id="more"></a><p>还真是蛮激动的，毕竟在所里的时候就听师兄师姐们说雁栖湖环境特别好。我来报到的这一天还在下雨，空气极度清晰。</p><p>坐车在学校绕了好久才找到了宿舍，宿舍可以说完全就是在山脚下。。。</p><p>这是宿舍的“客厅”。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/kt.jpg" alt="img"></p><p>一个屋子里一共有9个套间，每个套间只住一个人（单人间好评）。</p><p>套间是这样的。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/ss.jpg" alt="img"></p><p>有一个小窗户，我这里的位置不算太好，但是靠近向左看还是可以看到骆驼山的。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/ch.jpg" alt="img"></p><p>袋子里的全部东西（手写学生证预定）。</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/zb.jpg" alt="img"></p><p>简单收拾了一下 ，于是跑路去买被窝还有一些日常用品了。由于太拥挤，并没有拍食堂。</p><p>下午在学校里转了转，感觉校园有点大啊。。晚上跑回宿舍洗衣服洗澡写论文。</p><hr><p>以上是报到当天的实况，然而最近有点自闭。大概是因为突然到一个新环境，有点不适应吧…</p>]]></content>
      
      <categories>
          
          <category> 只言片语 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SG函数学习笔记</title>
      <link href="/blog/2018/09/04/Note-of-Learning-SG-Function/"/>
      <url>/blog/2018/09/04/Note-of-Learning-SG-Function/</url>
      <content type="html"><![CDATA[<p><strong>这是之前学习SG函数时所记的笔记。</strong></p><a id="more"></a><p><img src="http://pcoln8jiu.bkt.clouddn.com/sgfunction.png" alt="img"></p>]]></content>
      
      <categories>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1029E] Tree with Small Distances (贪心)</title>
      <link href="/blog/2018/08/27/CF1029E-Tree-with-Small-Distances-%E8%B4%AA%E5%BF%83/"/>
      <url>/blog/2018/08/27/CF1029E-Tree-with-Small-Distances-%E8%B4%AA%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1029/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1029/problem/E</a></p><p><strong>给你一棵树，让你从根节点1向其他点上加边，最少加多少边可以让根节点到所有节点的距离≤2。</strong></p><a id="more"></a><p>考虑贪心，假如一个点n到根节点的距离＞2，显然直接连着两个点不如连这个点的父亲和根来的合算。于是我们贪心地连距离最远的点的父亲，并且更新距离可以了。</p><p>先dfs出距离，之后把不满足≤2的点的信息入堆处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      G[u].emplace_back(v);</span><br><span class="line">      G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == v) <span class="keyword">continue</span>;</span><br><span class="line">        dp[v] = dp[u] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[v] &gt; <span class="number">2</span>) q.push(make_tuple(dp[v], v, u));</span><br><span class="line">        dfs(v, u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">      tie(w, v, u) = q.top(); q.pop();</span><br><span class="line">      <span class="keyword">if</span>(dp[v] &lt;= <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">      ret++;</span><br><span class="line">      dp[u] = <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) dp[v] = min(dp[u]+<span class="number">1</span>, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HDOJ6425] Rikka with Badminton (组合数学)</title>
      <link href="/blog/2018/08/20/HDOJ6425-Rikka-with-Badminton/"/>
      <url>/blog/2018/08/20/HDOJ6425-Rikka-with-Badminton/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6425" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6425</a></p><p><strong>$n$个人去打羽毛球，其中$a$个人没球没拍，$b$个人只有拍，$c$个人只有球，$d$个人什么都有。现在规定只要有两个人有拍，一个人有球就能去打。问有多少种组合不能去打。</strong></p><a id="more"></a><p>JLS给的解居然是个dp，惊了。</p><p>直接考虑有几种情况不能去打：球和拍都不够、球够拍不够、拍够球不够。</p><p>($a$个白嫖哥去不去都无所谓，因此他们对答案的整体贡献是$2^a$。)</p><p>球和拍都不够：分两种情况，完全没有拍和只有一个拍。第一种的贡献只有$a$出，第二种贡献从$a$和$b$里出。因此总体答案是$2^a+2^a×C_{b}^{1}$。</p><p>球够拍不够：这个贡献可以拆分成$a$和$c$、$a$和$b$、$a$和$b$和$d$里出。第一种（没有拍子）$c$类人随意去就可以（不能不去），贡献是$2^{a}×(2^{c}-1)$。第二种（只有一个拍子，$b$类人出拍子，$c$类人出球），贡献是$2^{a}×C_{b}^{1}×(2^c-1)$。第三种（只有一个拍子，$d$类人出拍子），贡献是$2^{a}×C_{d}^{1}×2^c$。</p><p>拍够球不够：只有$b$类人，且至少去$2$个，贡献是$2^a×C_{b}^{2}$。</p><p>全加起来就完事了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">LL a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = x * ret % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    x = x * x % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">    LL p1 = mul(<span class="number">2L</span>L, a) * (b + <span class="number">1</span>) % mod;</span><br><span class="line">    LL p2 = mul(<span class="number">2L</span>L, a) * (mul(<span class="number">2L</span>L, c) - <span class="number">1</span>) % mod;</span><br><span class="line">       p2 += ((mul(<span class="number">2L</span>L, a) * b % mod) * (mul(<span class="number">2L</span>L, c) - <span class="number">1</span>)) % mod; p2 %= mod;</span><br><span class="line">       p2 +=(( mul(<span class="number">2L</span>L, a) * d % mod) * mul(<span class="number">2L</span>L, c)) % mod; p2 %= mod;</span><br><span class="line">    LL p3 = (mul(<span class="number">2L</span>L, a) * (mul(<span class="number">2L</span>L, b) - b - <span class="number">1</span> + mod) % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (((p1+p2)%mod)+p3)%mod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 组合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HDOJ6418] Rikka with Stone-Paper-Scissors (纳什均衡)</title>
      <link href="/blog/2018/08/20/HDOJ6418-Rikka-with-Stone-Paper-Scissors/"/>
      <url>/blog/2018/08/20/HDOJ6418-Rikka-with-Stone-Paper-Scissors/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6418" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6418</a></p><p><strong>A和B玩剪子石头布，每个人要出$n$步，现在给你它们剪子、石头、布分别出的次数，每赢一次，获胜方得一分。已知A会随机出，现在求B的分数的最大期望。</strong></p><a id="more"></a><p>一共玩$n$局，每一次出不同的手势，得分的概率和对方守中对应手势的数目有关系，直接把能赢和能输的概率加加减减就OK。证明涉及纳什均衡，JLS直播讲的也没太听懂orz。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL a,b,c,a1,b1,c1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;a1,&amp;b1,&amp;c1);</span><br><span class="line">    LL n = a + b + c;</span><br><span class="line">    LL m = -a*c1-b*a1-c*b1+a1*c+b1*a+c1*b;</span><br><span class="line">    <span class="keyword">if</span>(m % n == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, m / n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>, m/__gcd((LL)<span class="built_in">abs</span>(m),n), n/__gcd((LL)<span class="built_in">abs</span>(m),n));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 博弈 </tag>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[CF1025] Codeforces Round #504 (Div.1+Div.2)</title>
      <link href="/blog/2018/08/20/CF1025-Codeforces-Round-504-Div-1-Div-2/"/>
      <url>/blog/2018/08/20/CF1025-Codeforces-Round-504-Div-1-Div-2/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1025" target="_blank" rel="noopener">http://codeforces.com/contest/1025</a></p><p><strong>这一场大家fst得都好惨啊。</strong></p><a id="more"></a><p>A：水题不多解释，注意$n=1$的时候输出Yes。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">222</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,s)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) vis[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(vis[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ok = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>有$n$个数对，让你找到一个大于1的数字，使得这个数字为这个$n$对数中任意一个数的因数。</strong></p><p>这个数一定是每一对数中某个数的因数，不妨建一个队列，把第一对中两个数的所有质因数去重后压到队里，看看队首的数是不是接下来的数对中任意一个数的因数。如果不是就出队，到最后看看有没有剩下数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">160600</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">  LL a, b;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    vis.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;a,&amp;b);</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= a; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a % j == <span class="number">0</span>) &#123;</span><br><span class="line">            q.push(j);</span><br><span class="line">            vis.insert(j);</span><br><span class="line">            <span class="keyword">while</span>(a % j == <span class="number">0</span>) a /= j;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        q.push(a);</span><br><span class="line">          vis.insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= b; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(b % j == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(vis.find(j) == vis.end()) &#123;</span><br><span class="line">          vis.insert(j);</span><br><span class="line">            q.push(j);</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">while</span>(b % j == <span class="number">0</span>) b /= j;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(vis.find(b) == vis.end()) &#123;</span><br><span class="line">          vis.insert(b);</span><br><span class="line">        q.push(b);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a % q.front() == <span class="number">0</span> || b % q.front() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!q.empty()) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, q.front());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>给你一个只有b和w两种字符的串s，希望让你通过一个操作获得尽可能长的bw交替的子串。这个操作是选中某一个位置切分，让两边都翻转。</strong></p><p>考虑这个操作的本质，两头翻转以后，原本在串两端的字符接到了一起，中间的到了两端。再选一个位置也是这样，那么实际上两头是可以通过这个操作接到一起的。于是我们把整个串看成一个环，找最长的不超过字符串本身长度的bw串就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150500</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)) &#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      s[i+n] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">2</span> * n) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'b'</span>) &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; <span class="number">2</span> * n &amp;&amp; s[i+<span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">          t++; i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(ret, t+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">2</span> * n) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'w'</span>) &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; <span class="number">2</span> * n &amp;&amp; s[i+<span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">          t++; i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(ret, t+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(n, ret));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：<strong>给你n个数，问你能不能构成一棵二叉排序树，并且每2个相邻节点之间的gcd不是1。</strong></p><p>首先想到了暴力枚举每一层的根节点，但是这样复杂度是$O(n^{logn})$的，显然不科学。</p><p>注意到一个点作为根的时候与它和它的儿子具体是谁有关系，我们考虑区间dp，维护$dp(i,j,k)$，表示$[i,j]$区间内的第$k$个数字能否做根，这个关系可以用bitset维护。</p><p>于是我们枚举长度和起止端点，特判端点作为根的时候能否成立，区间里面的数则直接枚举位置，看看这个k是否能分别做左右两棵树的根，如果能的话，直接给大区间做标记。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">707</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;maxn&gt; ok[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">bitset</span>&lt;maxn&gt; dp[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(a[i], a[j]) != <span class="number">1</span>) &#123;</span><br><span class="line">          ok[i][j] = ok[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((ok[i] &amp; dp[i+<span class="number">1</span>][j]).any()) &#123;</span><br><span class="line">          dp[i][j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((ok[j] &amp; dp[i][j<span class="number">-1</span>]).any()) &#123;</span><br><span class="line">          dp[i][j][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(dp[i][k][k] &amp;&amp; dp[k][j][k]) &#123;</span><br><span class="line">            dp[i][j][k] = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[<span class="number">1</span>][n]!=<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 规律 </tag>
            
            <tag> DP </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[BZOJ4017] 小Q的无敌异或（异或, 树状数组）</title>
      <link href="/blog/2018/08/19/BZOJ4017-%E5%B0%8FQ%E7%9A%84%E6%97%A0%E6%95%8C%E5%BC%82%E6%88%96/"/>
      <url>/blog/2018/08/19/BZOJ4017-%E5%B0%8FQ%E7%9A%84%E6%97%A0%E6%95%8C%E5%BC%82%E6%88%96/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4017" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=4017</a></p><p><strong>（这是一道好题）给你n个数，分别问这n个数中任意两个区间的异或和的加和是多少、任意两个区间的和的异或和是多少。</strong></p><a id="more"></a><p><strong>Task 1：求异或的和</strong></p><p>针对第一问，我们首先分析出两个性质：</p><ol><li><strong>设$[1,i]$的异或和为$xor[i]$，那么区间$[l,r]$内数字的异或和为$xor[l-1]⨁xor[r]$。</strong></li><li><strong>某个在数字第k位有贡献的子区间$[l,r]$，它们的前缀异或和$xor[l]$与$xor[r]$的值一定不同。而且很显然，这个区间的贡献为$2^k$。</strong></li></ol><p>有上述的两个性质，我们的目标其实就是拆分数位，针对每个数位，找到整个$[1,n]$区间内有多少对前缀异或和结果不同。假设在$[1,n]$中的第$k$位数字有$x$个数该位是$1$，那么就有$n-x$个位置是$0$。这样只是找到了区间长度≥2的贡献，但是题目规定单个数字也算贡献，不妨再加上一个$x$，问题转化成在两个数字集合中分别挑选一个数字，问有多少对数字，因此第$k$位总体贡献是$x(n-x+1)2^k$。</p><p>实现就很简单，我们针对每一位$k$，求异或和的每一步时，更新这个$x$，最后算一下贡献就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">gao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cur ^= (a[i] &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(cur == <span class="number">1</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += cnt * (n - cnt + <span class="number">1</span>) % mod * (<span class="number">1L</span>L &lt;&lt; k) % mod;</span><br><span class="line">    ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Task 2：求和的异或</strong></p><p>考虑和第一问一样的做法，要求的答案为异或和，考虑这个和的第$k$位什么时候为$1$：当出现的在这一位为$1$时的区间$[l,r]$内数字之和为奇数个的时候贡献为$2^k$。</p><p>我们又能发现一个规律：当区间[l,r]的和的第k位是奇数时，有：<br>$$<br>(s[r]-s[l-1])\ mod \ 2^{k+1}\ ≥\ 2^k<br>$$<br>针对每一位$k$，我们可以预处理出来前i项的和$s[i]$，离散化这个$s$以后用树状数组维护每个位置$i$左右两侧是否满足上述条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;LL&gt; bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, LL v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i+=lowbit(i)) &#123;</span><br><span class="line">    bit[i] ^= v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i-=lowbit(i)) &#123;</span><br><span class="line">    ret ^= bit[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; s(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; h(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> id = [&amp;](LL cur) &#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(h.begin(), h.end(), cur) - h.begin() + <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++) &#123;</span><br><span class="line">    LL tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      h[i] = s[i] &amp; ((<span class="number">1L</span>L &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(h.begin(), h.end());</span><br><span class="line">    bit = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      LL cur = s[i] &amp; ((<span class="number">1L</span>L &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">      add(id(cur), <span class="number">1L</span>L);</span><br><span class="line">      tmp ^= sum(id(cur-(<span class="number">1L</span>L&lt;&lt;k))) ^ sum(id(cur+(<span class="number">1L</span>L&lt;&lt;k))) ^ sum(id(cur));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">1</span>) ret |= (<span class="number">1L</span>L &lt;&lt; k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个题，学到了要去讨论所求结果和计算过程的特点这样的思路。例如本题的两个问就是要针对区间内的异或和或答案的异或和中的每一位做讨论。</p><p>于是，遇到异或和考虑到先讨论一下每一位的贡献就对啦~</p><p>提交的时候报了CE，emmm懒得改就这样吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">"O3"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">998244353L</span>L;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cur ^= (a[i] &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(cur == <span class="number">1</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += cnt * (n - cnt + <span class="number">1</span>) % mod * (<span class="number">1L</span>L &lt;&lt; k) % mod;</span><br><span class="line">    ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, LL v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i+=lowbit(i)) &#123;</span><br><span class="line">    bit[i] ^= v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i-=lowbit(i)) &#123;</span><br><span class="line">    ret ^= bit[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; s(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;LL&gt; h(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> id = [&amp;](LL cur) &#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(h.begin(), h.end(), cur) - h.begin() + <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++) &#123;</span><br><span class="line">    LL tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      h[i] = s[i] &amp; ((<span class="number">1L</span>L &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(h.begin(), h.end());</span><br><span class="line">    bit = <span class="built_in">vector</span>&lt;LL&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      LL cur = s[i] &amp; ((<span class="number">1L</span>L &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">      add(id(cur), <span class="number">1L</span>L);</span><br><span class="line">      tmp ^= sum(id(cur-(<span class="number">1L</span>L&lt;&lt;k))) ^ sum(id(cur+(<span class="number">1L</span>L&lt;&lt;k))) ^ sum(id(cur));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">1</span>) ret |= (<span class="number">1L</span>L &lt;&lt; k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    a.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, gao1(), gao2());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> BZOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[CF1023] Codeforces Round #504(Div.1+Div.2)</title>
      <link href="/blog/2018/08/18/CF1023-Codeforces-Round-504-Div-1-Div-2/"/>
      <url>/blog/2018/08/18/CF1023-Codeforces-Round-504-Div-1-Div-2/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1023" target="_blank" rel="noopener">http://codeforces.com/contest/1023</a></p><p><strong>我，七夕，掉分</strong></p><a id="more"></a><p>A：<strong>两个字符串，其中一个字符串里至多有个“*”表示任何字符都能匹配。问这两个字符串能不能匹配。</strong></p><p>从左到右扫两个字符串的相同前缀和后缀，然后看看是不是存在“*”以及两头不相接。据说这题被cha得很厉害啊？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s,t);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, t) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i] == t[j]) &#123;</span><br><span class="line">      i++,j++;tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = n - <span class="number">1</span>, q = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[p] == t[q]) &#123;</span><br><span class="line">      p--,q--;tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == p) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'*'</span> &amp;&amp; tot &lt;= m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>给你两个数$n$和$k$，问你$k$有多少能用不超过$n$的两个不同的数的和来表示，忽略顺序。</strong></p><p>设$k=x+y$，要满足$x≤n$、$y≤n$和$x≠y$。我们会发现，需要讨论$k≥2n$、$k≤n$和$n＜k＜2n$三个情况。前两个不必多说，第三个我们也是只需要统计从$\frac{k}{2}$数到$n$有多少个整数就行，因为总有$x＜\frac{k}{2}$和它对应。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k / <span class="number">2</span> &gt;= n) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= n) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, k % <span class="number">2</span> == <span class="number">0</span> ? k / <span class="number">2</span> - <span class="number">1</span> : k / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, n-k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>给定长为$n$的合法括号序列，让你求一个长为$k$的合法括号子序列。</strong></p><p>维护每一个下标为$i$的左括号对应的右括号下标$to[i]=j$，然后贪心地从左到右扫符合当前长度条件$k≥to[i]-i+1$的括号序列，每找到一堆符合条件的括号序列要更新$k$和$i$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> to[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">if</span>(n == k) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">    <span class="built_in">memset</span>(to, <span class="number">0</span>, <span class="keyword">sizeof</span>(to));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">        st.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> id = st.top(); st.pop();</span><br><span class="line">        to[i] = id; to[id] = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = k, i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; pos;</span><br><span class="line">    <span class="keyword">while</span>(tot) &#123;</span><br><span class="line">      <span class="keyword">if</span>(to[i] - i + <span class="number">1</span> &lt;= tot  &amp;&amp; to[i] - i + <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tot -= (to[i] - i + <span class="number">1</span>);</span><br><span class="line">        pos.emplace_back(i, to[i]);</span><br><span class="line">        i = to[i] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = pos[i].first; j &lt;= pos[i].second; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：<strong>原本有$n$个范围在$[1,q]$的数，定义染色操作$[l_i,r_i]$表示将$[l_i,r_i]$区间内的数字变为$i$，现在给你$n$个染色后的数字作为结果，其中含有数字$0$表示这里可以是任意数字，问你$q$次操作能不能把原本的序列变成这个序列。</strong></p><p>考虑到每次染色为一个区间，每个数字$i$仅能染色一次。那么在进行过一次染色操作后，这个区间内的数字必然不能比$i$小。</p><p>问题在于如何处理$0$，我们考虑有一个$0$在某个区间$[L,R]$内，且$a_L$与$a_R$相同，$[L,R]$中不存在除了$0$以外小于$a_L$的数字。那么我们可以将这个0置为相邻两侧数字中的任意一个，作为扩展那个数字的区间长度。</p><p>因此我们构造时只需要维护每一个数字的最右侧相同的那个数字，整个区间必然会被覆盖一次。然后用线段树维护区间最小值，存在有小于区间端点的数字时必然无法构造。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> r[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">int</span> seg[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  seg[rt] = min(seg[lrt], seg[rrt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    seg[rt] = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(l,m,lrt);</span><br><span class="line">  build(m+<span class="number">1</span>,r,rrt);</span><br><span class="line">  pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="keyword">return</span> seg[rt];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">  <span class="keyword">if</span>(m &gt;= L) ret = min(ret, query(L, R, l, m, lrt));</span><br><span class="line">  <span class="keyword">if</span>(m &lt; R) ret = min(ret, query(L, R, m+<span class="number">1</span>, r, rrt));</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(r));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">      r[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!r[q]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!r[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> a[r[<span class="number">0</span>]] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="number">0</span>) a[i] = a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="number">0</span>) a[i] = a[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">    build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> tmp;</span><br><span class="line">      <span class="keyword">if</span>(!r[a[i]]) <span class="keyword">continue</span>;</span><br><span class="line">      tmp = query(i, r[a[i]], <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(tmp &lt; a[i]) &#123;</span><br><span class="line">        ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, a[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 规律 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 构造 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Hackerrank] CodeKnight 1.0 A-D题解（线段树, 二分, 组合计数, 尺取）</title>
      <link href="/blog/2018/08/16/Hackerrank-CodeKnight-1-0-A-D%E9%A2%98%E8%A7%A3/"/>
      <url>/blog/2018/08/16/Hackerrank-CodeKnight-1-0-A-D%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.hackerrank.com/contests/codeknight-1/challenges" target="_blank" rel="noopener">https://www.hackerrank.com/contests/codeknight-1/challenges</a></p><p><strong>这些题好蛋疼啊。。。。</strong></p><a id="more"></a><p>Magical Cards：<strong>给你一个整数$n$，问你有多少种拆分方法，将这个数拆成素数的乘积。</strong></p><p>首先将这个数分解质因数，并记下每个素因数的个数$c[i]$以及一共有多少个素因数$tot$，问题转化成将这$tot$个素因数有多少种排列方式了。直接考虑每一类素因数$p[i]$要在$tot$个位置中占据$c[i]$个位置，每一种素因数的排放实际上是相互独立的。则位置有$C_{tot}^{p[i]}$种，剩下$tot-p[i]$个空位下一个质因数再放就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line">LL f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    f[<span class="number">1</span>] = f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) f[i] = f[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        LL m = n, tot = <span class="number">0</span>;</span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt++; n /= i;</span><br><span class="line">                    tot++;</span><br><span class="line">                &#125;</span><br><span class="line">                c.emplace_back(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            c.emplace_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LL ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">            ret = f[tot] / f[c[i]] / f[tot-c[i]] * ret;</span><br><span class="line">            tot -= c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shubham and Subarrays：<strong>给你n个数，和一个整数k。让你求有多少个子区间的乘积为k。</strong></p><p>考虑这样的区间问题首先想到尺取，但是仅尺取还不够。考虑k=1的情况，假如有连续的1存在（如：1 1 1 1），那么实际上有6种（$\frac{3×(3+1)}{2}$）。特殊处理掉这个情况，剩下的再计算乘积恰好为k时，左右两个指针外部的1的贡献就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL k, x[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;PLL&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">    v.clear(); v.emplace_back(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x[i]);</span><br><span class="line">      <span class="keyword">if</span>(x[i] != <span class="number">1</span>) &#123;</span><br><span class="line">        v.emplace_back(x[i], i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v.emplace_back(<span class="number">0</span>, n);</span><br><span class="line">    LL one = <span class="number">0</span>, ret = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">      cur = v[i].second - v[i<span class="number">-1</span>].second;</span><br><span class="line">      one += (cur - <span class="number">1</span>) * cur / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, one);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; v.size() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(cur * v[r].first == k) &#123;</span><br><span class="line">        cur *= v[r].first;</span><br><span class="line">        r++;</span><br><span class="line">        ret += (v[r].second - v[r<span class="number">-1</span>].second) * (v[l].second - v[l<span class="number">-1</span>].second);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(cur * v[r].first &lt; k) &#123;</span><br><span class="line">        cur *= v[r].first;</span><br><span class="line">        r++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(cur * v[r].first &gt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) l++, r++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          cur /= v[l].first;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chef and Cakes：这题太水，不多说了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        vis.clear();</span><br><span class="line">        <span class="keyword">int</span> x, a = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            vis[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : vis) &#123;</span><br><span class="line">            a = max(a, x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, vis.size(), a);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Domino’s：<strong>n个多米诺骨牌，每个骨牌的位置为$x_i$，高度为$h_i$，每个骨牌向右倒下能砸到$[x+1,x+h-1]$范围的骨牌。现在让你统计每一个骨牌从它的位置向右倒下后能砸倒多少骨牌（多米诺骨牌后面的骨牌被砸倒还会影响到后面的）。</strong></p><p>我们给n个多米诺骨牌按$x_i$排序后发现，由于最右边的骨牌倒下的影响只有自己，即为1，于是我们考虑从右往左开始处理：设我们骨牌的结果为$dp_i$，每当处理到第$i$个骨牌时，我们单张骨牌砸中的范围为$[x_i+1,x_i+h_i-1]$，我们对再它右边的骨牌中找到能砸中骨牌最多的那张牌即可（当然这里也有递推关系）。使用线段树维护每一个骨牌的dp值，每次查询的时候首先二分$[x_i+1,x_i+h_i-1]$（即受到当前骨牌影响的骨牌）中的下标$aim$，然后在线段树上查询$[pos+1, aim]$内dp值最大的下标id$，对于每一个骨牌$i$，答案为这个骨牌右边的dp值+这个骨牌左边至$i$骨牌中的骨牌数量$id-pos-1+dp$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> PLL = pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">using</span> Node = struct &#123;</span><br><span class="line">  LL x, h, id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Node p[maxn];</span><br><span class="line">LL dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line">LL seg[maxn&lt;&lt;<span class="number">4</span>], id[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(LL rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(seg[lrt] &gt; seg[rrt]) &#123;</span><br><span class="line">    seg[rt] = seg[lrt];</span><br><span class="line">    id[rt] = id[lrt];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    seg[rt] = seg[rrt];</span><br><span class="line">    id[rt] = id[rrt];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(LL l, LL r, LL rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    seg[rt] = <span class="number">1</span>;</span><br><span class="line">    id[rt] = l;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LL m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(l, m, lrt);</span><br><span class="line">  build(m+<span class="number">1</span>, r, rrt);</span><br><span class="line">  pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(LL x, LL p, LL l, LL r, LL rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    seg[rt] = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LL m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(p &lt;= m) update(x, p, l, m, lrt);</span><br><span class="line">  <span class="keyword">else</span> update(x, p, m+<span class="number">1</span>, r, rrt);</span><br><span class="line">  pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PLL <span class="title">query</span><span class="params">(LL L, LL R, LL l, LL r, LL rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="keyword">return</span> make_pair(seg[rt], id[rt]);</span><br><span class="line">  &#125;</span><br><span class="line">  LL m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  PLL ret = make_pair(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span>(L &lt;= m) &#123;</span><br><span class="line">    ret = max(ret, query(L, R, l, m, lrt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(R &gt; m) &#123;</span><br><span class="line">    ret = max(ret, query(L, R, m+<span class="number">1</span>, r, rrt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(LL pos)</span> </span>&#123;</span><br><span class="line">  LL l = pos + <span class="number">1</span>, r = n;</span><br><span class="line">  LL hi = p[pos].x + p[pos].h - <span class="number">1</span>;</span><br><span class="line">  LL aim = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p[m].x &lt;= hi) &#123;</span><br><span class="line">      aim = m;</span><br><span class="line">      l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(aim == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  PLL id = query(pos+<span class="number">1</span>, aim, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> (id.second - pos - <span class="number">1</span>) + id.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="comment">// freopen("out", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].h;</span><br><span class="line">      p[i].id = i;</span><br><span class="line">      dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, [](Node a, Node b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.x == b.x ? a.h &lt; b.h : a.x &lt; b.x;</span><br><span class="line">    &#125;);</span><br><span class="line">    build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      dp[i] += gao(i);</span><br><span class="line">      update(dp[i], i, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; ret; ret.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ret[p[i].id] = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, ret[i], <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Hackerrank </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 组合 </tag>
            
            <tag> 计数 </tag>
            
            <tag> 尺取 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HDOJ3501] Calculation 2 (容斥 or 欧拉函数)</title>
      <link href="/blog/2018/08/13/HDOJ3501-Calculation-2-%E5%AE%B9%E6%96%A5-or-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2018/08/13/HDOJ3501-Calculation-2-%E5%AE%B9%E6%96%A5-or-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3501" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=3501</a></p><p><strong>求一个数n的所有小于它并且与它不互质的数的和。</strong></p><a id="more"></a><p>打算复习一波欧拉函数的，结果这题发现可以容斥。</p><p>我们知道如果一个数$n$含有因数$x$，那么$x$的倍数都和$n$不互质，且质因数至少为$x$。</p><p>我们可以知道，对于任意小于$n$的因数$x$，对本题的贡献为$x+2x+3x+…+kx=\frac{k(k+1)}{2}x$，其中$k$为$n$对$x$的倍数。</p><p>于是直接对$n$分解因数，再容斥。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LL ret = exgcd(b, a%b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span> </span>&#123;</span><br><span class="line">  LL x, y;</span><br><span class="line">  exgcd(a, mod, x, y);</span><br><span class="line">  <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r" ,stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">    LL t = n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; p;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(n % i == <span class="number">0</span>) p.push_back(i);</span><br><span class="line">      <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) p.push_back(n);</span><br><span class="line">    <span class="keyword">int</span> nn = <span class="number">1</span> &lt;&lt; p.size();</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nn; i++) &#123;</span><br><span class="line">      LL tmp = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.size(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">          tmp *= p[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      LL cnt = t / tmp;</span><br><span class="line">      tmp = cnt * (cnt - <span class="number">1</span>) % mod * inv(<span class="number">2</span>) % mod * tmp % mod;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(__builtin_popcount(i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ret += tmp; ret %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ret -= tmp; ret += mod; ret %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来考虑欧拉函数，知道一个定理：小于$n$的数，且与$n$互质的数的和为：<br>$$<br>\frac{\phi(n)×n}{2}<br>$$<br>然而小于$n$的数的和为$\frac{n(n-1)}{2}$，于是我们一减：<br>$$<br>\frac{n(n-1-\phi(n))}{2}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r" ,stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">    LL ret = n, t = n;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(n % i == <span class="number">0</span>) ret = ret / i * (i<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) ret = ret / n * (n<span class="number">-1</span>);</span><br><span class="line">    LL p = t * (t - <span class="number">1</span> - ret) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HDOJ6395] Sequence (反演思想，整除分块，矩阵快速幂)</title>
      <link href="/blog/2018/08/13/HDOJ6395-Sequence-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%EF%BC%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/blog/2018/08/13/HDOJ6395-Sequence-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%EF%BC%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6395" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6395</a></p><p><strong>就算个式子。</strong></p><a id="more"></a><p>这题关键在于如何处理后面的下取整分式，会发现如何构造这个矩阵都不太好弄这个式子。知道一点莫比乌斯反演，考虑到了按照整除结果对取整式进行分块，每一块单独跑块长次矩阵快速幂，然后累计到结果上就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  LL m[maxn][maxn];</span><br><span class="line">  LL r;</span><br><span class="line">  LL c;</span><br><span class="line">  Matrix()&#123;</span><br><span class="line">    r = c = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">  &#125; </span><br><span class="line">&#125; Matrix;</span><br><span class="line"><span class="function">Matrix <span class="title">mul</span><span class="params">(Matrix m1, Matrix m2)</span> </span>&#123;</span><br><span class="line">  Matrix ret = Matrix();</span><br><span class="line">  ret.r = m1.r; ret.c = m2.c;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= m1.r; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(LL j = <span class="number">1</span>; j &lt;= m2.r; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(LL k = <span class="number">1</span>; k &lt;= m2.c; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m2.m[j][k] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ret.m[i][k] = (ret.m[i][k] + (m1.m[i][j] * m2.m[j][k]) % mod) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">quickmul</span><span class="params">(Matrix m, LL n)</span> </span>&#123;</span><br><span class="line">  Matrix ret = Matrix();</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= m.r; i++) ret.m[i][i]  = <span class="number">1</span>;</span><br><span class="line">  ret.r = m.r;</span><br><span class="line">  ret.c = m.c;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = mul(m, ret);</span><br><span class="line">    m = mul(m, m);</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL a, b, c, d, p, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">  Matrix mat, ret;</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;p,&amp;n);</span><br><span class="line">    mat.r = mat.c = <span class="number">3</span>;</span><br><span class="line">    ret.r = <span class="number">3</span>; ret.c = <span class="number">1</span>;</span><br><span class="line">    mat.m[<span class="number">1</span>][<span class="number">1</span>] = d, mat.m[<span class="number">1</span>][<span class="number">2</span>] = c;</span><br><span class="line">    mat.m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>; mat.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    mat.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    ret.m[<span class="number">1</span>][<span class="number">1</span>] = b; ret.m[<span class="number">2</span>][<span class="number">1</span>] = a; ret.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">3</span>; i &lt;= n; i=p/(p/i)+<span class="number">1</span>) &#123;</span><br><span class="line">        mat.m[<span class="number">1</span>][<span class="number">1</span>] = d, mat.m[<span class="number">1</span>][<span class="number">2</span>] = c;</span><br><span class="line">        mat.m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>; mat.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        mat.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        mat.m[<span class="number">1</span>][<span class="number">3</span>] = (p / i);</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= p / (p/i)) mat = quickmul(mat, n-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> mat = quickmul(mat, p/(p/i)+<span class="number">1</span>-i);</span><br><span class="line">        ret = mul(mat, ret);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret.m[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">3</span>; i &lt;= p; i=p/(p/i)+<span class="number">1</span>) &#123;</span><br><span class="line">      mat.m[<span class="number">1</span>][<span class="number">1</span>] = d, mat.m[<span class="number">1</span>][<span class="number">2</span>] = c;</span><br><span class="line">      mat.m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>; mat.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">      mat.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">      mat.m[<span class="number">1</span>][<span class="number">3</span>] = (p / i);</span><br><span class="line">      mat = quickmul(mat, p/(p/i)+<span class="number">1</span>-i);</span><br><span class="line">      ret = mul(mat, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    mat.m[<span class="number">1</span>][<span class="number">1</span>] = d, mat.m[<span class="number">1</span>][<span class="number">2</span>] = c;</span><br><span class="line">    mat.m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>; mat.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    mat.m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>; mat.m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    mat.m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0L</span>L;</span><br><span class="line">    mat = quickmul(mat, n-max(p, <span class="number">2L</span>L));</span><br><span class="line">    ret = mul(mat, ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret.m[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018杭电多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵快速幂 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HDOJ6386] Age of Moyu (最短路)</title>
      <link href="/blog/2018/08/13/HDOJ6386-Age-of-Moyu-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/blog/2018/08/13/HDOJ6386-Age-of-Moyu-%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6386" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6386</a></p><p><strong>意思就是地铁换乘，问你怎么坐，换乘次数最少</strong></p><a id="more"></a><p>这题数据水了，我的代码放过去去了。正解应该是维护到点的每个最短的距离的线路，然后更新的时候从这个线路中去找有没有存在的。我这里只是维护了最短路的上一个线路（看来是没有二条以上路径相同但是线路不同的数据），最后正着倒着各跑一次dijkstra取min的。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;LL, LL, LL&gt; TP;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  LL v, w, next;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxm = <span class="number">2001000</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">LL n, m, ee;</span><br><span class="line">LL d[maxn];</span><br><span class="line">LL head[maxn];</span><br><span class="line">Edge e[maxm];</span><br><span class="line">priority_queue&lt;TP, <span class="built_in">vector</span>&lt;TP&gt;, greater&lt;TP&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ee = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(LL u, LL v, LL w)</span> </span>&#123;</span><br><span class="line">  e[ee].v = v; e[ee].w = w; e[ee].next = head[u]; head[u] = ee++;</span><br><span class="line">  e[ee].v = u; e[ee].w = w; e[ee].next = head[v]; head[v] = ee++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dijkstra</span><span class="params">(LL s, LL t)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">  d[s] = <span class="number">0</span>;</span><br><span class="line">  LL pre_cost, pre_id, from;</span><br><span class="line">  pq.push(TP(<span class="number">0</span>, <span class="number">-1</span>, s));</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    tie(pre_cost, pre_id, from) = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(d[from] &lt; pre_cost) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = head[from]; ~i; i=e[i].next) &#123;</span><br><span class="line">      LL v = e[i].v, w = e[i].w;</span><br><span class="line">      LL cost, cur_id;</span><br><span class="line">      <span class="keyword">if</span>(w == pre_id) &#123;</span><br><span class="line">        cost = <span class="number">0</span>; cur_id = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        cost = <span class="number">1</span>; cur_id = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cost + d[from] &lt; d[v]) &#123;</span><br><span class="line">        d[v] = cost + d[from];</span><br><span class="line">        pq.push(TP(d[v], cur_id, v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">find</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == d[x] ? x : d[x] = find(d[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL u, v, w;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      d[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d%I64d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      d[find(u)] = find(v);</span><br><span class="line">      adde(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(find(<span class="number">1</span>) != find(n)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, min(dijkstra(n, <span class="number">1</span>), dijkstra(<span class="number">1</span>, n)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018杭电多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018百度之星-初赛（B）ADF题解</title>
      <link href="/blog/2018/08/12/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E5%88%9D%E8%B5%9B%EF%BC%88B%EF%BC%89ADF%E9%A2%98%E8%A7%A3/"/>
      <url>/blog/2018/08/12/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E5%88%9D%E8%B5%9B%EF%BC%88B%EF%BC%89ADF%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826</a></p><p>只会签到。。。</p><a id="more"></a><p>A： 因为无限添加，考虑先把另外一些树加到这个点上，再把其他子树的叶子加到某一个点上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; pre[find(x)] = find(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T, u, v;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) pre[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">      in[u]++, in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      ret = max(ret, in[i]+n-in[i]<span class="number">-1</span>-max(<span class="number">0</span>, m-in[i]-k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：这题直接二分答案，即最小的那个数字。然后按照这个数字来划分是加还是减，保证加的次数的2倍比减的次数多就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">300200</span>;</span><br><span class="line">LL n;</span><br><span class="line">LL x[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(LL mid)</span> </span>&#123;</span><br><span class="line">  LL a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x[i] &gt; mid+<span class="number">1</span>) &#123;</span><br><span class="line">      b += (x[i] - mid) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> a += max(<span class="number">0L</span>L, mid-x[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  b &gt;= a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x+<span class="number">1</span>, x+n+<span class="number">1</span>);</span><br><span class="line">    LL lo = <span class="number">0</span>, hi = <span class="number">1E9</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">      LL mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(gao(mid)) &#123;</span><br><span class="line">        lo = mid + <span class="number">1</span>;</span><br><span class="line">        ret = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        hi = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F：因为$x_i$和$y_i$不会存在重复的，那么直接垂直接到最近的边上就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL mx, my, q, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; mx &gt;&gt; my &gt;&gt; q;</span><br><span class="line">      LL ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">          LL tmp = x &lt; mx - x ? x : mx - x;</span><br><span class="line">          <span class="keyword">if</span>(x &lt; mx - x) tmp = x;</span><br><span class="line">          <span class="keyword">else</span> tmp = mx - x;</span><br><span class="line">          <span class="keyword">if</span>(tmp &gt;= y) tmp = y;</span><br><span class="line">          <span class="keyword">if</span>(tmp &gt;= my - y) tmp = my - y;</span><br><span class="line">          ret += tmp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018百度之星 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 规律 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[CF1020A-C] Codeforces Round #503 (Div.2)</title>
      <link href="/blog/2018/08/12/CF1020A-C-Codeforces-Round-503-Div-2/"/>
      <url>/blog/2018/08/12/CF1020A-C-Codeforces-Round-503-Div-2/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1020" target="_blank" rel="noopener">http://codeforces.com/contest/1020</a></p><p><strong>上分啦</strong></p><a id="more"></a><p>A：<strong>n个楼每个楼h层，在每栋楼的$[a,b]$层上都有一个横向的通道，可以从一个楼去任意楼。现在给你两个位置，问最少要走多少步。</strong></p><p>对两个位置和通道区间进行讨论，然后抠一下就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL n, h, a, b, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL ta, fa, tb, fb;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;h&gt;&gt;a&gt;&gt;b&gt;&gt;k) &#123;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;ta&gt;&gt;fa&gt;&gt;tb&gt;&gt;fb;</span><br><span class="line">      LL ret = (LL)<span class="built_in">abs</span>(ta - tb);</span><br><span class="line">      <span class="keyword">if</span>(ta == tb) &#123;</span><br><span class="line">        ret += (LL)<span class="built_in">abs</span>(fa - fb);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa &gt; b &amp;&amp; fb &gt; b) &#123;</span><br><span class="line">          ret += (fa + fb - <span class="number">2L</span>L * b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fa &lt; a &amp;&amp; fb &lt; a) &#123;</span><br><span class="line">          ret += (<span class="number">2L</span>L * a - fa - fb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ret += (LL)<span class="built_in">abs</span>(fa - fb);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>意思就是让你从每个人出发找第一个遍历2次的点。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  dfs(p[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(p ,<span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">      p[i] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">      dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>n个人要给m个政党投票，每个人都有自己的投票目标以及花钱收买他的代价。现在希望让1号政党的票数超过其他所有政党的票数，问你至少要花多少钱。</strong></p><p>考虑贪心地选花费最少的，但是直接这样选相当于确定了收买人数，实际上可以买某一个政党的一些票就可以减少收买人数。于是我们考虑枚举1号政党的目标票数，超过该票数的政党则购买所有最少价格的差票，如果还不足我们的目标票数则从剩下的票里选最便宜的买。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3030</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, W;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">int</span> p[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(<span class="keyword">int</span> vote)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  tmp.clear();</span><br><span class="line">  <span class="keyword">int</span> need = vote - W;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[i].size() &gt;= vote) &#123;</span><br><span class="line">      id = f[i].size() - vote + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id &gt; need) <span class="keyword">return</span> <span class="number">1E18</span>;</span><br><span class="line">    need -= id;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; id; j++) &#123;</span><br><span class="line">      ret += f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = id; j &lt; f[i].size(); j++) &#123;</span><br><span class="line">      tmp.push_back(f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(tmp.begin(), tmp.end());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; need; i++) &#123;</span><br><span class="line">    ret += tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i],&amp;w[i]);</span><br><span class="line">      f[p[i]].push_back(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      sort(f[i].begin(), f[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">1E18</span>;</span><br><span class="line">    W = f[<span class="number">1</span>].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = W; i &lt;= n; i++) &#123;</span><br><span class="line">      ret = min(ret, gao(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[2018百度之星] 初赛（A）A-C题解</title>
      <link href="/blog/2018/08/11/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E5%88%9D%E8%B5%9B%EF%BC%88A%EF%BC%89AA-C%E9%A2%98%E8%A7%A3/"/>
      <url>/blog/2018/08/11/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E5%88%9D%E8%B5%9B%EF%BC%88A%EF%BC%89AA-C%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825</a></p><p><strong>这场出的三题，有两道和标算不太一样啊。。。其中一道题还是因为数据弱暴力过的，感觉这样下去不太行啊。。。</strong></p><a id="more"></a><p>A：直接按照长短排序，从大到小连续取3根，看看能不能构成三角形。取最大的三根就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a+n);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>]) &#123;</span><br><span class="line">        ok = <span class="number">1</span>;</span><br><span class="line">        ret = a[i]+a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ok) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：这里直接用deque或者list暴力就行，其实应该手写一个list，然后接头接尾直接翻转两个指针。（其实我想到了，但是写不来。码力太差了啊。。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150100</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&gt; l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">  in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">  <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">    num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">int</span> u, v, w, val;</span><br><span class="line">  <span class="keyword">while</span>(scan_d(n)) &#123;</span><br><span class="line">    l.resize(n+<span class="number">1</span>);</span><br><span class="line">    scan_d(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l[i].clear();</span><br><span class="line">    <span class="keyword">int</span> cmd;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">      scan_d(cmd);</span><br><span class="line">      <span class="keyword">if</span>(cmd == <span class="number">1</span>) &#123;</span><br><span class="line">        scan_d(u); scan_d(w); scan_d(val);</span><br><span class="line">        <span class="keyword">if</span>(w == <span class="number">0</span>) l[u].emplace_front(val);</span><br><span class="line">        <span class="keyword">else</span> l[u].emplace_back(val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cmd == <span class="number">2</span>) &#123;</span><br><span class="line">        scan_d(u); scan_d(w);</span><br><span class="line">        <span class="keyword">if</span>(l[u].size() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l[u].front());</span><br><span class="line">          l[u].pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l[u].back());</span><br><span class="line">          l[u].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cmd == <span class="number">3</span>) &#123;</span><br><span class="line">        scan_d(u); scan_d(v); scan_d(w);</span><br><span class="line">        <span class="keyword">if</span>(w == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(!l[v].empty()) &#123;</span><br><span class="line">            l[u].emplace_back(l[v].front());</span><br><span class="line">            l[v].pop_front();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span>(!l[v].empty()) &#123;</span><br><span class="line">            l[u].emplace_back(l[v].back());</span><br><span class="line">            l[v].pop_back();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：（一道比较简单的签到题），这题我在第17分钟的时候就提交了DP做法，就是先把1串拆出来，两头的花费为1，中间的花费为2，然后做背包容量为k+1的01背包，一开始想的是最左花费为0，后来觉得不太对，有可能拆分后原先最左不在最左了，于是分了两种情况讨论了一下。折腾了2h才步入正轨。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; seg;</span><br><span class="line"><span class="keyword">int</span> f[maxn], L, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gao2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  seg.clear();</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i, tot = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(j &lt; n &amp;&amp; s[j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        tot++, j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>) seg.push_back(make_pair(tot, <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == n) seg.push_back(make_pair(tot, <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">else</span> seg.push_back(make_pair(tot, <span class="number">2</span>));</span><br><span class="line">      i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> seg[<span class="number">0</span>].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seg.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt;= seg[i].second; j--) &#123;</span><br><span class="line">      f[j] = max(f[j], f[j-seg[i].second]+seg[i].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    k++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, gao2());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赛后感觉应该把B C D按照正解做一下。。</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018百度之星 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 规律 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[总结] 关于01背包和完全背包以及优化</title>
      <link href="/blog/2018/08/11/%E6%80%BB%E7%BB%93-%E5%85%B3%E4%BA%8E01%E8%83%8C%E5%8C%85%E5%92%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
      <url>/blog/2018/08/11/%E6%80%BB%E7%BB%93-%E5%85%B3%E4%BA%8E01%E8%83%8C%E5%8C%85%E5%92%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>今天晚上又被问起01背包和完全背包的遍历顺序了，我决定写一篇博文，这样再有人问我就可以直接把这篇文章发给他了。</p><p>我要不要先以我的方式来介绍一下这两个问题？首先我们知道01背包和完全背包的状态转移方程：</p><p>01背包：$f(i,j)=max{f(i-1,j), f(i-1,j-w_i)+v_i}$</p><p>完全背包：$f(i,j)=max{f(i-1,j),f(i-1,j-kw_i)+kv_i}$</p><p>简单解释一下，以01背包为例，我们定义$f(i,j)$为扫到第$i$个物品为止，背包容量为$j$时的最大价值。我们依次从第一个物品开始，决定要不要往这个背包里放，如果放的话，我们一定会从另一个状态转移过来，这个状态即扫到上一个物品、同时容量为$j-w_i$时的状态，为什么不是比$j-w_i$更小的一个状态？因为这个方程满足最优子结构：保证$f(i-1,j-w_i)$一定由上一个最优状态转移来，那么这个状态必然是最优的。完全背包也是如此，只不过朴素的做法需要多枚举一维第$i$个物品放的个数。</p><a id="more"></a><p>我们回到最开始的问题：01背包和完全背包的遍历顺序为什么会不一样？究竟有什么关系？</p><p>在我初学背包问题的时候也想到了这个问题，但是很久之后才去想着弄明白这件事。一般提出这个问题的是已经了解了这两种背包问题并且知道了他们的优化算法的同学。能提出这个问题也说明实际上并没有真正理解这两个状态转移的内涵（以及没认真看背包九讲2333）。</p><p>首先介绍一下01背包的优化，针对01背包的时间复杂度是无法再优化的了，但是朴素地开二维数组是冗余的。有人发现了这个问题，并且进一步发现了01背包的更新规律：<strong>在更新$i,j$时，并不会用到比$j$大的位置，即$f(i-1,k), k&gt;j$。</strong>这很显而易见，因为<strong>物品的重量（花费）是大于等于0的，因此$j-w_i \leq j$</strong></p><p><strong>是一定成立的</strong>。所以我们才会有那个喜闻乐见的一位数组优化，只不过内层的更新顺序是从背包容量到物品重量（花费）的递减遍历顺序，<strong>这样能保证我们的递推是由扫到上一个物品时留下的数组中更新过来的</strong>，我贴一下喜闻乐见的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= w[i]; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得还不够清楚，那我贴一个二维的、滚动数组形式的来帮你理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; w[i]) &#123;</span><br><span class="line">      f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[i][j] = max(f[i][j], f[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; w[i]) &#123;</span><br><span class="line">      f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[i][j] = max(f[i][j], f[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还会发现，一位数组优化后的代码更简洁，因为不需要转移$j&lt;w_i$时的状态（一位数组里，不转移就直接保存在原位了）。</p><p>这就是为什么一位数组优化的01背包内层循环遍历顺序为什么是背包容量到物品重量的原因。</p><p>再看一下完全背包，我们朴素的完全背包更新是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; w[i]) &#123;</span><br><span class="line">      f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k * w[i] &lt;= j; k++) &#123;</span><br><span class="line">      f[i][j] = max(f[i][j], f[i<span class="number">-1</span>][j-k*w[i]]+k*v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多了一层，遍历物品件数，复杂度变高。</p><p>背包九讲里将完全背包转化为01背包来做，我们记得刚刚讨论过的01背包的一位数组优化，为了防止把扫到上一个物品的状态用扫到当前物品的状态更新掉，我们内层循环倒过来更新。但是反过来会发生什么呢？反过来的话，当我们更新$f(j)$的时候，会从$f(j-w_i)$更新过来，但<strong>此时$f(j-w_i)$或许已经包括了当前这个物品，那么$f(j)$再被此状态更新的话，实际上就相当于包括了两个物品$i$</strong>，这也是我们希望的，因为完全背包不限制每种物品数量，这也是这个优化成立的原因。贴份代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= W; j++) &#123;</span><br><span class="line">    f[j] = max(f[j], f[j-w[i]]+v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018牛客多校07 C Bit Compression (DP)</title>
      <link href="/blog/2018/08/10/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A107-C-Bit-Compression-DP/"/>
      <url>/blog/2018/08/10/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A107-C-Bit-Compression-DP/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/acm/contest/145/C" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/145/C</a></p><p><strong>一个长度为$2^n$的01串，每次允许相邻两个数字进行与、或、异或操作，最终希望结果是1，问有多少种不同的操作路径。</strong></p><a id="more"></a><p>$f(i,j)$表示01串从$2^n$开始，扫到长度为$2^i$时，01串变为j时的路径数，用一个map来记录状态，然后暴力dp转移到下一层就行。整体复杂度是$O(2^nn)$，可以过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300200</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; f[<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">22</span>; i++) f[i].clear();</span><br><span class="line">    <span class="built_in">string</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    f[n][s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="built_in">string</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span>(it = f[i].begin(); it != f[i].end(); it++) &#123;</span><br><span class="line">        tmp = it-&gt;first, tot = it-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> nn = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        a = b = c = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nn; j+=<span class="number">2</span>) &#123;</span><br><span class="line">          a += ((tmp[j]-<span class="string">'0'</span>) &amp; (tmp[j+<span class="number">1</span>]-<span class="string">'0'</span>)) + <span class="string">'0'</span>;</span><br><span class="line">          b += ((tmp[j]-<span class="string">'0'</span>) | (tmp[j+<span class="number">1</span>]-<span class="string">'0'</span>)) + <span class="string">'0'</span>;</span><br><span class="line">          c += ((tmp[j]-<span class="string">'0'</span>) ^ (tmp[j+<span class="number">1</span>]-<span class="string">'0'</span>)) + <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i<span class="number">-1</span>][a] += tot;</span><br><span class="line">        f[i<span class="number">-1</span>][b] += tot;</span><br><span class="line">        f[i<span class="number">-1</span>][c] += tot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">0</span>][<span class="string">"1"</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 2018牛客多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces348D] Turtles (DP, LGV引理)</title>
      <link href="/blog/2018/08/10/Codeforces348D-Turtles-LiDP-LGV%E5%BC%95%E7%90%86/"/>
      <url>/blog/2018/08/10/Codeforces348D-Turtles-LiDP-LGV%E5%BC%95%E7%90%86/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/348/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/348/problem/D</a></p><p><strong>两只乌龟在棋盘上从(1,1)出发到(n,m)，其中有的地方有障碍物，两只乌龟希望找到有多少对路径，使得他们到(n,m)的路上不相交。</strong></p><a id="more"></a><p>如果我没有做牛客多校，我也不会知道这个冷艳的Lindstrom-Gessel-Viennot引理。今天翻笔记看到了，还记得CF上有一道考这个的，于是来除草。</p><p>这东西出题很单一，就是用来计算n对起止点不相交路径组合数的，出题也挺单一，其中的一个trick可能是在拆点这方面，给出公式：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/CF348D1.png" alt="img"></p><p>其中$e(a_i,b_j)$表示从起点$a_i$到终点$b_j$的路径数，M的行列式的值就是我们要求的不相交路径的组合数了。</p><p>关于拆点，一般都是移动到起点附近步长为1的位置，终点也是，具体我不太明白，希望有朝一日能证明出来：)</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/CF348D.png" alt="img"></p><p>这题的DP方程就很简单了，看代码吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3030</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line">LL f[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">1</span>][<span class="number">2</span>] == <span class="string">'#'</span> || s[<span class="number">2</span>][<span class="number">1</span>] == <span class="string">'#'</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL a, b, c, d;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">2</span>] = (s[<span class="number">1</span>][<span class="number">2</span>] != <span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][j] == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">f[i][j] += (f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>]) % mod;</span><br><span class="line">f[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a = f[n<span class="number">-1</span>][m], b = f[n][m<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">2</span>][<span class="number">1</span>] = (s[<span class="number">2</span>][<span class="number">1</span>] != <span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][j] == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">f[i][j] += (f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>]) % mod;</span><br><span class="line">f[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c = f[n<span class="number">-1</span>][m], d = f[n][m<span class="number">-1</span>];</span><br><span class="line">LL ret = ((a * d) % mod - (b * c) % mod + mod) % mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈，除草真开心啊！</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1017E] The Supersonic Rocket (凸包, KMP)</title>
      <link href="/blog/2018/08/09/Codeforces1017E-The-Supersonic-Rocket-%E5%87%B8%E5%8C%85-KMP/"/>
      <url>/blog/2018/08/09/Codeforces1017E-The-Supersonic-Rocket-%E5%87%B8%E5%8C%85-KMP/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1017/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1017/problem/E</a></p><p><strong>给你两组点，问你这两组点的凸包是不是同构的。</strong></p><a id="more"></a><p>先分别跑出两组点的凸包，判断一下点数是否相等，然后依次按照凸包的长度和拐点的角度记录下数列，然后可以用最小表示法都调成最小表示，或者对其中一个数列扩大两倍作匹配串，另一个作模式串跑KMP。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">1500500</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> LL x, y; &#125;Point;</span><br><span class="line">Point point[maxn];</span><br><span class="line">LL st[maxn], top;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">cross</span><span class="params">(Point p0, Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dis</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">  LL tmp = cross(point[<span class="number">0</span>], p1, p2);</span><br><span class="line">  <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(tmp == <span class="number">0</span>) <span class="keyword">return</span> dis(point[<span class="number">0</span>], p1) &lt; dis(point[<span class="number">0</span>], p2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graham</span><span class="params">(LL n, <span class="built_in">vector</span>&lt;Point&gt; &amp;ret)</span> </span>&#123;</span><br><span class="line">  ret.clear();</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(point[<span class="number">0</span>].y &gt;= point[i].y) &#123;</span><br><span class="line">      <span class="keyword">if</span>(point[<span class="number">0</span>].y == point[i].y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(point[<span class="number">0</span>].x &gt; point[i].x) swap(point[i], point[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> swap(point[<span class="number">0</span>], point[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(point+<span class="number">1</span>, point+n, cmp);</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  st[top++] = <span class="number">0</span>, st[top++] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(top<span class="number">-2</span> &gt;= <span class="number">0</span> &amp;&amp; cross(point[st[top<span class="number">-2</span>]], point[st[top<span class="number">-1</span>]], point[i]) &lt;= <span class="number">0</span>) --top;</span><br><span class="line">    st[top++] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; top; i++) ret.emplace_back(point[st[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point a[maxn], b[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; conv1, conv2;</span><br><span class="line">LL n, m;</span><br><span class="line"></span><br><span class="line">LL na, nb;</span><br><span class="line">LL x[maxn];</span><br><span class="line">LL y[maxn];</span><br><span class="line">LL pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpre</span><span class="params">(LL *y, LL *pre)</span> </span>&#123;</span><br><span class="line">  LL j, k;</span><br><span class="line">  <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="number">-1</span>));</span><br><span class="line">  pre[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  j = <span class="number">0</span>; k = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(j &lt; nb) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">-1</span> || y[j] == y[k]) &#123;</span><br><span class="line">      j++; k++;</span><br><span class="line">      <span class="keyword">if</span>(y[j] != y[k]) pre[j] = k;</span><br><span class="line">      <span class="keyword">else</span> pre[j] = pre[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> k = pre[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  LL i = <span class="number">0</span>;</span><br><span class="line">  LL j = <span class="number">0</span>;</span><br><span class="line">  getpre(y, pre);</span><br><span class="line">  <span class="keyword">while</span>(i &lt; na) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">-1</span> || x[i] == y[j]) &#123;</span><br><span class="line">      i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> j = pre[j];</span><br><span class="line">    <span class="keyword">if</span>(j == nb) ans++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="keyword">sizeof</span>(y));</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;b[i].x,&amp;b[i].y);</span><br><span class="line">    conv1.clear(); conv2.clear();</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n; i++) point[i] = a[i];</span><br><span class="line">    graham(n, conv1);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; m; i++) point[i] = b[i];</span><br><span class="line">    graham(m, conv2);</span><br><span class="line">    <span class="keyword">if</span>(conv1.size() != conv2.size()) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      na = conv1.size() * <span class="number">6</span>, nb = conv2.size() * <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; conv1.size(); i++) &#123;</span><br><span class="line">        x[i*<span class="number">3</span>] = dis(conv1[i],conv1[(i+<span class="number">1</span>)%conv1.size()]);</span><br><span class="line">        x[i*<span class="number">3</span>+<span class="number">1</span>] = cross(conv1[(i+<span class="number">1</span>)%conv1.size()],conv1[i],conv1[(i+<span class="number">2</span>)%conv1.size()]);</span><br><span class="line">        x[i*<span class="number">3</span>+<span class="number">2</span>] = dis(conv1[(i+<span class="number">1</span>)%conv1.size()],conv1[(i+<span class="number">2</span>)%conv1.size()]);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x[i*3]&lt;&lt;" "&lt;&lt;x[i*3+1]&lt;&lt;" "&lt;&lt;x[i*3+2]&lt;&lt;" ";</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; conv1.size(); i++) &#123;</span><br><span class="line">        x[i*<span class="number">3</span>+na/<span class="number">2</span>] = x[i*<span class="number">3</span>];</span><br><span class="line">        x[i*<span class="number">3</span>+<span class="number">1</span>+na/<span class="number">2</span>] = x[i*<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line">        x[i*<span class="number">3</span>+<span class="number">2</span>+na/<span class="number">2</span>] = x[i*<span class="number">3</span>+<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x[i*3+na/2]&lt;&lt;" "&lt;&lt;x[i*3+1+na/2]&lt;&lt;" "&lt;&lt;x[i*3+2+na/2]&lt;&lt;" ";</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; conv2.size(); i++) &#123;</span><br><span class="line">        y[i*<span class="number">3</span>] = dis(conv2[i],conv2[(i+<span class="number">1</span>)%conv2.size()]);</span><br><span class="line">        y[i*<span class="number">3</span>+<span class="number">1</span>] = cross(conv2[(i+<span class="number">1</span>)%conv2.size()],conv2[i],conv2[(i+<span class="number">2</span>)%conv2.size()]);</span><br><span class="line">        y[i*<span class="number">3</span>+<span class="number">2</span>] = dis(conv2[(i+<span class="number">1</span>)%conv2.size()],conv2[(i+<span class="number">2</span>)%conv2.size()]);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; y[i*3]&lt;&lt;" "&lt;&lt;y[i*3+1]&lt;&lt;" "&lt;&lt;y[i*3+2]&lt;&lt;" ";</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">      LL ret = kmp();</span><br><span class="line">      <span class="keyword">if</span>(ret) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 凸包 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1017A-D] Codeforces Round 502 (Div.1+Div.2)</title>
      <link href="/blog/2018/08/09/Codeforces1017A-D-Codeforces-Round-502-Div-1-Div-2/"/>
      <url>/blog/2018/08/09/Codeforces1017A-D-Codeforces-Round-502-Div-1-Div-2/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1017" target="_blank" rel="noopener">http://codeforces.com/contest/1017</a></p><p><strong>这把肯定要上分的，结果因为服务器爆炸，unrated了好气。。</strong></p><a id="more"></a><p>A：太水了不多说。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> P = struct &#123;</span><br><span class="line">  <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">  <span class="keyword">int</span> s, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">P p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; p[i].a&gt;&gt;p[i].b&gt;&gt;p[i].c&gt;&gt;p[i].d;</span><br><span class="line">      p[i].s = p[i].a+p[i].b+p[i].c+p[i].d;</span><br><span class="line">      p[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, [](P a, P b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.s == b.s ? a.id &lt; b.id : a.s &gt; b.s;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(p[i].id == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>给你两个01串，要求你交换第一个串中的任意两个数，使得这两个串“或”操作后的结果和原始的不一样，问多少种换法。</strong></p><p>手写一下会发现导致变化的a、b串某一位置的组合是“10”（用0换掉第一个1）和“00”（用1换掉第一个0），我们统计这样的位置，以及0、1的出现次数，把这两种结果加起来，再减掉一次10和00出现的组合乘积就行了（因为10中的1和00中的0会多进行一次）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line">LL tot;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    LL o = <span class="number">0</span>, z = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      vis[a[i]-<span class="string">'0'</span>]++;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="string">'1'</span>) o++;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="string">'0'</span>) z++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[<span class="number">0</span>] == n || vis[<span class="number">1</span>] == n) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="string">'0'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) x++;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="string">'1'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) y++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; o*x+z*y-x*y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>构造一个长度为n排列，使得这个排列的LIS和LDS长度之和最小。</strong></p><p>遇事不决打个表：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/CF1017C.png" alt="img"></p><p>我们发现一个规律：当要构造长度为n的排列时，我们可以找到第一个比n大的平方数$k^2$，然后我们依次放入$k^2-k+1,…k^2-1,k^2,…,1,2,…,k$，当要放的数比n大的时候不输出就ok了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line">LL n, nn;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp, gen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    gen.clear();</span><br><span class="line">    LL nn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(nn * nn &lt; n) nn++;</span><br><span class="line">    LL circle = nn;</span><br><span class="line">    nn = nn * nn;</span><br><span class="line">    LL del = nn - n;</span><br><span class="line">    <span class="keyword">while</span>(nn) &#123;</span><br><span class="line">      tmp.clear();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; circle; i++, nn--) tmp.emplace_back(nn);</span><br><span class="line">      reverse(tmp.begin(), tmp.end());</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp) gen.emplace_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : gen) <span class="keyword">if</span>(x &lt;= n) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打表代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] &gt; a[j]) f[i] = max(f[i], f[j]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = max(ret, f[i]);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] &lt; a[j]) f[i] = max(f[i], f[j]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = max(ret, f[i]);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = i, b[i] = i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> tmp = lis() + lds();</span><br><span class="line">      <span class="keyword">if</span>(tmp &lt;= ret) &#123;</span><br><span class="line">        ret = tmp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: "</span>, ret);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">          b[i] = a[i];</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(a+<span class="number">1</span>, a+n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d: "</span>, ret);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：<strong>两个01串有个匹配的价值，对应位相同的话就要加上那位的价值。给你一些询问串，问有多少串和它的匹配价值不超过k。</strong>  </p><p>这题n给的很小，考虑预处理出任意串和所给串的价值，然后统计当前串这个价值下的字符串数，维护一个前缀和，然后查询就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> wu[<span class="number">4096</span>][<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">int</span> ret[<span class="number">4096</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">500500</span>];</span><br><span class="line"><span class="keyword">char</span> tmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">conv</span><span class="params">(<span class="keyword">char</span> *x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]); </span><br><span class="line">  <span class="keyword">int</span> nn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, tmp);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      x += tmp[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nn; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nn; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(((<span class="number">1</span>&lt;&lt;k)&amp;i) == ((<span class="number">1</span>&lt;&lt;k)&amp;j)) &#123;</span><br><span class="line">          tmp += w[n<span class="number">-1</span>-k];</span><br><span class="line">          <span class="keyword">if</span>(tmp &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(tmp &lt;= <span class="number">100</span>) ret[i][tmp] += vis[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nn; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">100</span>; k++) &#123;</span><br><span class="line">      ret[i][k] += ret[i][k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,tmp,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      x += tmp[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret[x][k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规律 </tag>
            
            <tag> 构造 </tag>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[AtCoderARC100D] Equal Cut (枚举, 二分)</title>
      <link href="/blog/2018/08/08/AtCoderARC100D-Equal-Cut-%E6%9E%9A%E4%B8%BE-%E4%BA%8C%E5%88%86/"/>
      <url>/blog/2018/08/08/AtCoderARC100D-Equal-Cut-%E6%9E%9A%E4%B8%BE-%E4%BA%8C%E5%88%86/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://arc100.contest.atcoder.jp/tasks/arc100_b" target="_blank" rel="noopener">https://arc100.contest.atcoder.jp/tasks/arc100_b</a></p><p><strong>给你n个数，要求你不改变顺序将这n个数字切分成4段，问四段中各段求和后最大和与最小和之间的差</strong></p><a id="more"></a><p>切三刀，可以首先枚举中间拿刀，然后再在两边分别二分各自的那一刀，让各自拆分成的两个集合的和的差值最小，这样才能保证整体的差值最小。这题对我来说挺难写的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; a, s;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gao</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1E18</span>, tmp = <span class="number">1E18</span>;</span><br><span class="line">  <span class="keyword">int</span> lo = <span class="number">1</span>, hi = id, s1 = <span class="number">1</span>, s2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">1E18</span> || tmp &gt; (LL)<span class="built_in">abs</span>(s[id]-s[mid]-s[mid])) &#123;</span><br><span class="line">      tmp = (LL)<span class="built_in">abs</span>(s[id]-s[mid]-s[mid]);</span><br><span class="line">      s1 = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[id]-s[mid]&lt;s[mid]) hi = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lo = id + <span class="number">1</span>, hi = n, tmp = <span class="number">1E18</span>;</span><br><span class="line">  <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">1E18</span> || tmp &gt; (LL)<span class="built_in">abs</span>(s[n]-s[mid]-(s[mid]-s[id]))) &#123;</span><br><span class="line">      tmp = (LL)<span class="built_in">abs</span>(s[n]-s[mid]-(s[mid]-s[id]));</span><br><span class="line">      s2 = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[n]-s[mid]&lt;s[mid]-s[id]) hi = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LL L = min(&#123;s[s1], s[id]-s[s1], s[s2]-s[id], s[n]-s[s2]&#125;);</span><br><span class="line">  LL R = max(&#123;s[s1], s[id]-s[s1], s[s2]-s[id], s[n]-s[s2]&#125;);</span><br><span class="line">  ret = min(ret, R-L);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    a.resize(n+<span class="number">1</span>); s.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">      s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">1E18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ret = min(ret, gao(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://arc100.contest.atcoder.jp/tasks/arc100_b" target="_blank" rel="noopener">https://arc100.contest.atcoder.jp/tasks/arc100_b</a></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[POJ3744] Scout YYF I（概率, DP, 矩阵优化）</title>
      <link href="/blog/2018/08/07/POJ3744-Scout-YYF-I%EF%BC%88%E6%A6%82%E7%8E%87-DP-%E7%9F%A9%E9%98%B5%E4%BC%98%E5%8C%96%EF%BC%89/"/>
      <url>/blog/2018/08/07/POJ3744-Scout-YYF-I%EF%BC%88%E6%A6%82%E7%8E%87-DP-%E7%9F%A9%E9%98%B5%E4%BC%98%E5%8C%96%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://cn.vjudge.net/problem/POJ-3744" target="_blank" rel="noopener">https://cn.vjudge.net/problem/POJ-3744</a></p><p><strong>一个人在一条线上走，线上有n个点有地雷，这个人每次有一定概率$p$走一步，也有$1-p$的概率跳两步。问这个人不踩地雷的概率是多少</strong>。</p><a id="more"></a><p>我们根据题意能推出递推式：$f(i)$表示走到$i$处的概率为多少。$f(1)=1$，$f(i)=p×f(i-1)+(1-p)×f(i-2)$。</p><p>由于线很长，但是地雷很少。我们观察这个递推式是线性的，于是可以用矩阵快速幂优化，构造矩阵：<br>$$<br>\begin{pmatrix}f(n)\f(n-1)\end{pmatrix}=\begin{pmatrix}p&amp;1-p\1&amp;0\end{pmatrix}\begin{pmatrix}f(n-1)\f(n-2)\end{pmatrix}<br>$$<br>对于每一个雷的位置进行分段，计算到那个地方不踩中的概率，递推所有段走到雷处不中的概率，用乘法原理就能求出来结果了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> m[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;Matrix;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">mul</span><span class="params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">  Matrix ret;</span><br><span class="line">  <span class="built_in">memset</span>(ret.m, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret.m));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b.m[j][k] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ret.m[i][k] += a.m[i][j] * b.m[j][k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">M</span><span class="params">(Matrix a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  Matrix ret;</span><br><span class="line">  <span class="built_in">memset</span>(ret.m, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret.m));</span><br><span class="line">  ret.m[<span class="number">0</span>][<span class="number">0</span>] = ret.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  Matrix tmp = a;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ret = mul(ret, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    tmp = mul(tmp, tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">    sort(x, x+n);</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">double</span> tot = <span class="number">1.0</span>;</span><br><span class="line">    Matrix p;</span><br><span class="line">    p.m[<span class="number">0</span>][<span class="number">0</span>] = q, p.m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>-q;</span><br><span class="line">    p.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, p.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    ret = M(p, x[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">    tot *= (<span class="number">1</span> - ret.m[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(x[i] == x[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      ret = M(p, x[i]-x[i<span class="number">-1</span>]<span class="number">-1</span>);</span><br><span class="line">      tot *= (<span class="number">1</span> - ret.m[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7f\n"</span>, tot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> POJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 概率 </tag>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[AtCoderSoundHound18D] Saving Snuuk （最短路）</title>
      <link href="/blog/2018/08/07/AtCoderSoundHound18D-Saving-Snuuk-%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89/"/>
      <url>/blog/2018/08/07/AtCoderSoundHound18D-Saving-Snuuk-%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_d" target="_blank" rel="noopener">https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_d</a></p><p><strong>有n个城市，一个人从s出发到t。手里一开始有1E15日元，现在有两种货币，这个人只能将日元兑换成另一种货币，并且是全部兑换。每到一个城市，这人就会在该城市呆一年。城市之间有火车，火车票价格是$a_i$yen或$b_i$snuuk，在每一个城市$i$，第$i$年的时候可以在该城市将yen兑换成snuuk。现在希望让这人剩的snuuk最多，问这人在1~n年内剩最多为多少snuuk。</strong></p><a id="more"></a><p>我们首先关注火车票的花费，希望snuuk剩的最多，只有在买火车票时才会花费，因此直接将火车票花费最小化就可以。</p><p>我们做两次最短路：$s$到各点，使用yen做货币，价格为$d1_i$；$t$到各点，使用snuuk做货币，价格为$d2_i$。这样我们可以获得每一个点的总计花费就是$d1_i+d2_i$。</p><p>然后再考虑每一年，这人要在每一个城市呆最少一年，最长无限。那么按照城市的兑换开始时间倒着扫一遍，用年份多的剩的多的更新前几年的就可以了。</p><p>（流下了不会写C++的眼泪）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;LL, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> Edge = tuple&lt;<span class="keyword">int</span>, LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; d1, d2;</span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; ret;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; G;</span><br><span class="line">priority_queue&lt;pli, <span class="built_in">vector</span>&lt;pli&gt;, greater&lt;pli&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">  d1[s] = <span class="number">0</span>; pq.emplace(<span class="number">0</span>, s);</span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  LL w, tw;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    tie(tw, u) = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(d1[u] &lt; tw) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> edge : G[u]) &#123;</span><br><span class="line">      tie(v, w, ignore) = edge;</span><br><span class="line">      <span class="keyword">if</span>(d1[v] &gt; d1[u] + w) &#123;</span><br><span class="line">        d1[v] = d1[u] + w;</span><br><span class="line">        pq.emplace(d1[v], v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">  d2[t] = <span class="number">0</span>; pq.emplace(<span class="number">0</span>, t);</span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  LL w, tw;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    tie(tw, u) = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(d2[u] &lt; tw) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> edge : G[u]) &#123;</span><br><span class="line">      tie(v, ignore, w) = edge;</span><br><span class="line">      <span class="keyword">if</span>(d2[v] &gt; d2[u] + w) &#123;</span><br><span class="line">        d2[v] = d2[u] + w;</span><br><span class="line">        pq.emplace(d2[v], v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  LL a, b;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t) &#123;</span><br><span class="line">    G.resize(n+<span class="number">1</span>); ret.resize(n+<span class="number">1</span>);</span><br><span class="line">    d1.resize(n+<span class="number">1</span>); d1.assign(d1.size(), numeric_limits&lt;LL&gt;::max());</span><br><span class="line">    d2.resize(n+<span class="number">1</span>); d2.assign(d2.size(), numeric_limits&lt;LL&gt;::max());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; a &gt;&gt; b;</span><br><span class="line">      G[u].emplace_back(v, a, b);</span><br><span class="line">      G[v].emplace_back(u, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    gao1(); gao2();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret[i] = d1[i] + d2[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--) ret[i] = min(ret[i], ret[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; (LL)<span class="number">1E15</span> - ret[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[AtCoderSoundHound18C] Ordinary Beauty（概率, 期望）</title>
      <link href="/blog/2018/08/07/AtCoderSoundHound18C-Ordinary-Beauty%EF%BC%88%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B%EF%BC%89/"/>
      <url>/blog/2018/08/07/AtCoderSoundHound18C-Ordinary-Beauty%EF%BC%88%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_c" target="_blank" rel="noopener">https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_c</a></p><p><strong>给你1~n这n个数，现在允许你随机在m个位置上方这n个数，问你放好后的数组中，相邻两个数字的差为d的数对的概率。</strong></p><a id="more"></a><p>m个位置存在m-1对数，由于期望的线性可加性，我们知道答案为$(m-1)</p><p>×在m个数字中挑选出一对差为d的概率$。</p><p>当$d=0$时，相邻两个数字相同的时候才会有贡献，则有一对数字相同的概率为$\frac{n}{n^2}$。</p><p>当$d≠0$时，我们有$(1,d+1),…,(n-d,n)$和$(d+1,1),…,(n,n-d)$这些可能，共有$2×(n-d-d-1+1)=2(n-d)$种，因此一对数字相同的概率是$\frac{2(n-d)}{n^2}$。</p><p>求期望的话，乘上$m-1$就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> n, m, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; d) &#123;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%.15f\n"</span>, (m<span class="number">-1</span>)/n);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.15f\n"</span>, <span class="number">2.0</span>*(n-d)*(m<span class="number">-1</span>)/n/n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[POJ2096] Collecting Bugs （期望, DP）</title>
      <link href="/blog/2018/08/07/POJ2096-Collecting-Bugs-%EF%BC%88%E6%9C%9F%E6%9C%9B-DP%EF%BC%89/"/>
      <url>/blog/2018/08/07/POJ2096-Collecting-Bugs-%EF%BC%88%E6%9C%9F%E6%9C%9B-DP%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://cn.vjudge.net/problem/POJ-2096" target="_blank" rel="noopener">https://cn.vjudge.net/problem/POJ-2096</a></p><p><strong>有一个程序员要在$s$个子系统里找$n$个不同的BUG，问在$s$种子系统里找到$n$个BUG的天数期望。</strong></p><a id="more"></a><p>这题是求期望的入门经典，我想拿这道题来做一个总结。</p><p>首先是最重要的、也就是期望的一些性质：</p><p>1：当$X$和$Y$两个<strong>并不一定相互独立</strong>随机变量时，我们有如下性质：<br>$$<br>E(aX+bY)=aE(X)+bE(Y)<br>$$<br>上述性质称为<strong>期望的线性性（可加性）</strong>，证明很容易，略。</p><p>2：<strong>全期望公式</strong>：<br>$$<br>E(Y)=E(E(Y|X))=\sum_{i}P(X=x_i)E(Y|X=x_i)<br>$$<br>当期望存在条件时，可以类比全概率公式获得全期望公式。</p><p>以及解决期望问题的常用方法：</p><p>解决期望问题有两种方法：<strong>高斯消元</strong>或者<strong>DP</strong>。</p><p>1：高斯消元不必多说，我们根据题意枚举出所有状态，并根据状态列出期望方程组，使用高斯消元求得各个状态的期望解。</p><p>2：当所求状态的期望之间存在一定关系的时候，可以使用<strong>动态规划</strong>解决期望问题：首先做的事自然是找准<strong>递推状态</strong>，这是肯定的。找到状态后，接下来要枚举出所有的<strong>状态转移</strong>，同时计算出转移的<strong>条件</strong>和<strong>代价</strong>。我们描述一下上述步骤执行后应该得到的结果：状态$i$、状态$i$下的期望$E(i)$、状态$i$下的递推状态$(j|j由i转移得到)$，每一种状态转移所需的代价$w_i$。</p><p>我们可以由状态i下递推出来的状态j获得i状态的期望：$\sum w_jE(j)$。我们利用<strong>期望的可加性</strong>，就可以得到$i$的期望了。</p><p>对于本题，我们可以设$f(i,j)$表示在$j$个系统中找到$i$个BUG后期望天数。很明显，当$n$天$s$个系统中找到BUG后，该天的期望$E(n,s)=0$。</p><p>接下来我们以找到一个BUG为转移条件，由$(i,j)$可以转移出四个不同的状态：</p><p>$(i,j)$表示在$j$个系统中没有再找到新BUG，转移代价为$p_1=\frac{i}{n} × \frac{j}{s}$。</p><p>$(i+1,j)$表示在$j$个系统中找到了一个新BUG，转移代价为$p_2=\frac{n-i}{n} × \frac{j}{s}$。</p><p>$(i,j+1)$表示在一个新系统中找到了一个已有BUG，转移代价为$p_3=\frac{i}{n} × \frac{s-j}{s}$。</p><p>$(i+1,j+1)$表示在一个新系统中找到了一个新BUG，转移代价为$p_4=\frac{n-i}{n} × \frac{s-j}{s}$。</p><p>我们可以列出状态$(i,j)$的期望等式：<br>$$<br>E(i,j)=p_1E(i,j)+p_2E(i+1,j)+p_3E(i,j+1)+p_4E(i+1,j+1)<br>$$<br>移项得：<br>$$<br>E(i,j)=\frac{p_2E(i+1,j)+p_3E(i,j+1)+p_4E(i+1,j+1)}{1-p_1}<br>$$<br>我们由$(n,s)$倒着递推，递推到$(0,0)$时即为要在s个系统中找到n个BUG的期望了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">double</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;s)) &#123;</span><br><span class="line">    f[n][s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> q = n * s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = s; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n &amp;&amp; j == s) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">double</span> p1 = <span class="keyword">double</span>(i * j) / q;</span><br><span class="line">        <span class="keyword">double</span> p2 = <span class="keyword">double</span>((n - i) * j) / q;</span><br><span class="line">        <span class="keyword">double</span> p3 = <span class="keyword">double</span>(i * (s - j)) / q;</span><br><span class="line">        <span class="keyword">double</span> p4 = <span class="keyword">double</span>((n - i) * (s - j)) / q;</span><br><span class="line">        f[i][j] = (p2*f[i+<span class="number">1</span>][j]+p3*f[i][j+<span class="number">1</span>]+p4*f[i+<span class="number">1</span>][j+<span class="number">1</span>]+<span class="number">1.</span>)/(<span class="number">1.0</span>-p1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4f\n"</span>, f[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> POJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 概率 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HDOJ6351] 18多校05 Beautiful Now (暴力，全排列，置换群)</title>
      <link href="/blog/2018/08/06/HDOJ6351-18%E5%A4%9A%E6%A0%A105-Beautiful-Now-%E6%9A%B4%E5%8A%9B%EF%BC%8C%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E7%BD%AE%E6%8D%A2%E7%BE%A4/"/>
      <url>/blog/2018/08/06/HDOJ6351-18%E5%A4%9A%E6%A0%A105-Beautiful-Now-%E6%9A%B4%E5%8A%9B%EF%BC%8C%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E7%BD%AE%E6%8D%A2%E7%BE%A4/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6351" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6351</a></p><p><strong>给你一个数字$n$和交换次数$k$，问你最多交换$k$次，这个数最大能变为多大，最小能变为多小。</strong></p><a id="more"></a><p>暴力枚举这个数字的全排列，然后计算和之前数字之间的交换次数。用置换的方法，总计的最少交换次数为所有环的长度-1的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; perm[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">9</span>; t++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">      a[i] = i;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        now = now * <span class="number">10</span> + a[i];</span><br><span class="line">      <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        <span class="keyword">if</span>(vis[i] != now)</span><br><span class="line">        &#123;</span><br><span class="line">          vis[i] = now;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = a[i]; j != i; j = a[j])</span><br><span class="line">          &#123;</span><br><span class="line">            vis[j] = now;</span><br><span class="line">            tmp++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      perm[t][tmp].push_back(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(next_permutation(a + <span class="number">1</span>, a + t + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(mask)</span><br><span class="line">  &#123;</span><br><span class="line">    ret += a[mask % <span class="number">10</span>] * tmp;</span><br><span class="line">    mask /= <span class="number">10</span>;</span><br><span class="line">    tmp *= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> n[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> t, k, mn, mx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, n, &amp;k);</span><br><span class="line">  t = <span class="built_in">strlen</span>(n);</span><br><span class="line">  <span class="keyword">if</span>(t == <span class="number">10</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1000000000 1000000000\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(k &gt;= t)</span><br><span class="line">    k = t - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">    a[i] = n[i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">  mn = <span class="number">1000000000</span>;</span><br><span class="line">  mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> lj = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t; i++)</span><br><span class="line">    lj *= <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = perm[t][i].begin(); it != perm[t][i].end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> now = apply(*it);</span><br><span class="line">      <span class="keyword">if</span>(now &lt; lj)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      now &lt; mn ? mn = now : <span class="number">0</span>;</span><br><span class="line">      now &gt; mx ? mx = now : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, mn, mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> t1 = <span class="number">1</span>; t1 &lt;= T; t1++)</span><br><span class="line">    solve();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018杭电多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 置换群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HDOJ6354] 18多校05 Everything Has Changed (计算几何)</title>
      <link href="/blog/2018/08/06/HDOJ6354-18%E5%A4%9A%E6%A0%A105-Everything-Has-Changed-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
      <url>/blog/2018/08/06/HDOJ6354-18%E5%A4%9A%E6%A0%A105-Everything-Has-Changed-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6354" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6354</a></p><p><strong>给你一个圆和互不相交的n个小圆，让你计算这个大圆被n个小圆切割后的周长，大圆内部的不计算。</strong></p><a id="more"></a><p>很容易发现小圆和大圆相交以后，周长增加了小圆的弧长-大圆的弧长。用余弦定理计算一下大小圆关于交处的角度，然后用弧长公式算一下即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x, y, r;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">Node p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gao</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b.x &lt; <span class="number">0</span>) b.x = -b.x;</span><br><span class="line">  <span class="keyword">if</span>(b.y &lt; <span class="number">0</span>) b.y = -b.y;</span><br><span class="line">  <span class="keyword">double</span> d = dis(a, b);</span><br><span class="line">  <span class="keyword">double</span> theta1 = <span class="number">2.0</span> * <span class="built_in">acos</span>((d*d+a.r*a.r-b.r*b.r)/(<span class="number">2</span>*d*a.r));</span><br><span class="line">  <span class="keyword">double</span> theta2 = <span class="number">2.0</span> * <span class="built_in">acos</span>((d*d+b.r*b.r-a.r*a.r)/(<span class="number">2</span>*d*b.r));</span><br><span class="line">  <span class="keyword">double</span> L1 = theta1 * a.r;</span><br><span class="line">  <span class="keyword">double</span> L2 = theta2 * b.r;</span><br><span class="line">  <span class="keyword">return</span> L2 - L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">2</span> * pi * r;</span><br><span class="line">    Node o = &#123;<span class="number">0</span>, <span class="number">0</span>, r&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">double</span> d = dis(o, p[i]);</span><br><span class="line">      <span class="keyword">double</span> R = o.r, r = p[i].r;</span><br><span class="line">      <span class="keyword">if</span>(d &gt;= R + r) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(d == R - r) &#123;</span><br><span class="line">        ret += p[i].r * pi * <span class="number">2.0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(R - r &lt; d &amp;&amp; d &lt; R + r) &#123;</span><br><span class="line">        ret += gao(o, p[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.15f\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018杭电多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[AtCoderABC103D] Islands War (贪心，思维)</title>
      <link href="/blog/2018/08/06/AtCoderABC103D-Islands-War-%E8%B4%AA%E5%BF%83%EF%BC%8C%E6%80%9D%E7%BB%B4/"/>
      <url>/blog/2018/08/06/AtCoderABC103D-Islands-War-%E8%B4%AA%E5%BF%83%EF%BC%8C%E6%80%9D%E7%BB%B4/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://abc103.contest.atcoder.jp/tasks/abc103_d" target="_blank" rel="noopener">https://abc103.contest.atcoder.jp/tasks/abc103_d</a></p><p><strong>有n个岛练成一条线，每两个岛之间有一个桥。现在有m个岛之间发生了冲突，发生冲突的岛就不能连通了，问最少要切断几座桥？</strong></p><a id="more"></a><p>这题很有意思，贪心地去考虑，希望切到的边影响尽可能地大，可以考虑贪心地将发生冲突的右端点从小到大排，然后从左到右开始切。</p><p>可以反证一下：假如选中的某次冲突的右端点不是最优的解，那么可能存在一个在此点左侧的点待切，显然存在的左侧点不是最优点，因为左侧已经统计完将此点之前发生冲突的点对分割开的桥数，再添加一条是冗余的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">pii p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].first,&amp;p[i].second);</span><br><span class="line">      <span class="keyword">if</span>(p[i].first &gt; p[i].second) swap(p[i].first, p[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p+<span class="number">1</span>, p+m+<span class="number">1</span>, [](pii x, pii y)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x.second != y.second) <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">      <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = p[<span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pre &gt; p[i].first) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        tot++;</span><br><span class="line">        pre = p[i].second;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[AtCoderABC104D] We Love ABC (DP, 计数)</title>
      <link href="/blog/2018/08/06/AtCoderABC104D-We-Love-ABC-DP-%E8%AE%A1%E6%95%B0/"/>
      <url>/blog/2018/08/06/AtCoderABC104D-We-Love-ABC-DP-%E8%AE%A1%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://abc104.contest.atcoder.jp/tasks/abc104_d" target="_blank" rel="noopener">https://abc104.contest.atcoder.jp/tasks/abc104_d</a></p><p><strong>给一个只含有ABC?四种字符的字符串，?可以替换成ABC中的任意一个字符，现在要你统计所有的ABC的组合个数。</strong></p><a id="more"></a><p><em>这题比赛时间内写搓了，因为误读了题目的统计结果，比如?ABC，答案应该是4（AABC BABC CABC）。</em></p><p>我们可以考虑枚举B的位置，并以这个B为链接，那么问题就变成了统计左侧A的个数和右侧C的个数。这里也不能是简单地将左右两侧的A?和C?的个数乘起来，因为固定了某一对A、C后其他字符的变化也是要算作不同组合的。<br>我们将每一个B的位置的计数结果拆成四项来统计，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A、B、C</span><br><span class="line">?、B、C</span><br><span class="line">A、B、?</span><br><span class="line">?、B、?</span><br></pre></td></tr></table></figure><p>第一项很好统计，由于不存在?所以可以直接计数。<br>第二、三项的本质是相同的，我们在B的某一侧存在?时，要枚举任意一个?（让这个?作为A或C出现），那么其他位置的?则是任意的，那么每一个位置对答案的贡献是$3^{k-1}$，其中$k$为?的左侧或右侧总数。<br>第四项和第二、三项也是一样的，但是要在左右两边各取一个?，假设左侧有$x_1$个?，右侧有$x_2$个?，那么计数结果为$3^{x_1-1}×3^{x_2-1}$，整理为$3^{x_1+x_2-2}$。<br>这样我们就推出了每一个B对总体答案的分步贡献，我们维护A、C、?出现次数的前缀和，之后就可以分类讨论了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line">LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line">LL f[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ret *= x; ret %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    x *= x; x %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      f[i][<span class="number">0</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>] + (s[i] == <span class="string">'A'</span>);</span><br><span class="line">      f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">1</span>] + (s[i] == <span class="string">'C'</span>);</span><br><span class="line">      f[i][<span class="number">2</span>] = f[i<span class="number">-1</span>][<span class="number">2</span>] + (s[i] == <span class="string">'?'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] == <span class="string">'B'</span> || s[i] == <span class="string">'?'</span>) &#123;</span><br><span class="line">        LL q = f[n][<span class="number">2</span>] - (s[i] == <span class="string">'?'</span>);</span><br><span class="line">        ret += mul(<span class="number">3L</span>L, q) * (f[i<span class="number">-1</span>][<span class="number">0</span>] * (f[n][<span class="number">1</span>] - f[i][<span class="number">1</span>]) % mod);</span><br><span class="line">        ret %= mod;</span><br><span class="line">        <span class="keyword">if</span>(q &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">          ret += mul(<span class="number">3L</span>L, q<span class="number">-1</span>) * (f[i<span class="number">-1</span>][<span class="number">0</span>] * (f[n][<span class="number">2</span>] - f[i][<span class="number">2</span>]) % mod);</span><br><span class="line">          ret %= mod;</span><br><span class="line">          ret += mul(<span class="number">3L</span>L, q<span class="number">-1</span>) * (f[i<span class="number">-1</span>][<span class="number">2</span>] * (f[n][<span class="number">1</span>] - f[i][<span class="number">1</span>]) % mod);</span><br><span class="line">          ret %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">          ret += mul(<span class="number">3L</span>L, q<span class="number">-2</span>) * (f[i<span class="number">-1</span>][<span class="number">2</span>] * (f[n][<span class="number">2</span>] - f[i][<span class="number">2</span>]) % mod);</span><br><span class="line">          ret %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[2018百度之星] 资格赛1003 整数规划 (最大匹配)</title>
      <link href="/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1003-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/"/>
      <url>/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1003-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1003" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1003</a></p><a id="more"></a><p>希望最大化目标函数，事实上满足 Kuhn–Munkres algorithm 求解最小权匹配过程中的顶标的定义，现在就是要计算最大顶标和，而这正好就是最小权匹配 ，按照$x_i$和$y_i$给定的约束条件连边，同时边权置为负值。然后跑最大匹配，输出结果的相反数。</p><p>这题一般的KM算法是过不了的，因为网上流传的KM代码都到不了$O(n^3)$。于是去UOJ上扒了一份KM模版……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">405</span>;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> lx[N], ly[N];</span><br><span class="line"><span class="keyword">int</span> lmatch[N], rmatch[N];</span><br><span class="line"><span class="keyword">bool</span> lvis[N], rvis[N];</span><br><span class="line"><span class="keyword">int</span> slack[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dt = INF, ru;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">if</span> (!rvis[j] &amp;&amp; slack[j] &lt; dt) &#123;</span><br><span class="line">            dt = slack[j];</span><br><span class="line">            ru = j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lvis[i]) lx[i] -= dt;</span><br><span class="line">        <span class="keyword">if</span> (rvis[i])</span><br><span class="line">            ly[i] += dt;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            slack[i] -= dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ru;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; u; swap(u, lmatch[pre[u]])) rmatch[u] = pre[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    lvis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp;</span><br><span class="line">                <span class="keyword">if</span> (rvis[v] || (tmp = lx[u] + ly[v] - w[u][v]) &gt; slack[v])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                pre[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!rmatch[v]) <span class="keyword">return</span> match(v);</span><br><span class="line">                    rvis[v] = lvis[rmatch[v]] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(rmatch[v]);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    slack[v] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        u = update(n);</span><br><span class="line">        <span class="keyword">if</span> (!rmatch[u]) <span class="keyword">return</span> match(u);</span><br><span class="line">        rvis[u] = lvis[rmatch[u]] = <span class="literal">true</span>;</span><br><span class="line">        q.push(rmatch[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">KM</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        lmatch[i] = rmatch[i] = lx[i] = ly[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            lx[i] = max(lx[i], w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            slack[j] = INF;</span><br><span class="line">            lvis[j] = rvis[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res += lx[i] + ly[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T_T, _ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T_T);</span><br><span class="line">  <span class="keyword">while</span>(T_T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i][j]);</span><br><span class="line">        w[i][j] = -w[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %I64d\n"</span>, ++_, -KM(n));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018百度之星 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 匹配问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[2018百度之星] 资格赛1005 序列计数 (DP, 树状数组, 随机)</title>
      <link href="/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1005-%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0-DP-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E9%9A%8F%E6%9C%BA/"/>
      <url>/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1005-%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0-DP-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E9%9A%8F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1005" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1005</a></p><p><strong>这题随机给你一个1~n的排列，要你统计这1~n的排列中长度为1~n的上升子序列的个数分别是多少。</strong></p><a id="more"></a><p>由于数据是随机的，因此这个序列中的LIS满足下面这个工作：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/2018astar1005.jpg" alt="img"></p><p>LIS的长度大概是$2\sqrt{N}$，当$N=10000$时，LIS的最长长度大约为$200$。</p><p>我们很容易就推出LIS的计数公式：<br>$$<br>f(i,k) += (p_i &gt; p_j)? f(j,k-1) : 0<br>$$<br>可以考虑枚举LIS的长度$l$，用bit维护到第$i$个位置的数字$p[i]$、长度为$l-1$的上升子序列的总数，这样每次扫一个位置的时候，就可以直接查前缀和了。</p><p>由于要更新bit，所以维护一个滚动的dp数组，在查询长度为$l-1$的计数结果的同时，更新答案以及$l$的计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL n;</span><br><span class="line">LL p[maxn];</span><br><span class="line">LL bit[maxn];</span><br><span class="line">LL f[<span class="number">2</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">lowbit</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(LL x, LL val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(LL i = x; i &lt;= n; i+=lowbit(i)) &#123;</span><br><span class="line">    bit[i] += val; bit[i] %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(LL i = x; i; i-=lowbit(i)) &#123;</span><br><span class="line">    ret += bit[i];</span><br><span class="line">    ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  LL T, _ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    LL x = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%I64d:"</span>, ++_);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %I64d"</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(LL l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">      x = !x;</span><br><span class="line">      LL ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit));</span><br><span class="line">        <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">          f[x][i] = sum(p[i] - <span class="number">1</span>);</span><br><span class="line">          ret += f[x][i]; ret %= mod;</span><br><span class="line">          add(p[i], f[!x][i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(ret == <span class="number">0</span>) flag = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">" %I64d"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018百度之星 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[2018百度之星] 资格赛1006 三原色图 (最小生成树)</title>
      <link href="/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1006-%E4%B8%89%E5%8E%9F%E8%89%B2%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1006-%E4%B8%89%E5%8E%9F%E8%89%B2%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1006" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1006</a></p><a id="more"></a><p>这题很简单，按照RG、BG的组合分别跑最小生成树，假如某一种情况无法构造出则抛弃那一种情况。同时给边打标记，最后再取k-(n+1)条最短的未添加到生成树里的边就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id, u, v, w;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Node a, Node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, eid;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; G[maxn];</span><br><span class="line">priority_queue&lt;Node&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  x = find(x); y = find(y);</span><br><span class="line">  <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    pre[y] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; gao1(<span class="keyword">int</span> k) &#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) pre[i] = i;</span><br><span class="line">  <span class="keyword">while</span> (!pq.empty()) pq.pop();</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(G[i][j].c == <span class="string">'R'</span> || G[i][j].c == <span class="string">'G'</span>) &#123;</span><br><span class="line">        pq.push(G[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    Node p = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(unite(p.u, p.v)) &#123;</span><br><span class="line">      tot++;</span><br><span class="line">      ret += p.w;</span><br><span class="line">      vis[p.id] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[G[i][j].id]) pq.push(G[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ret += pq.top().w; pq.pop(); pq.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> make_pair(ret, tot == n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; gao2(<span class="keyword">int</span> k) &#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) pre[i] = i;</span><br><span class="line">  <span class="keyword">while</span> (!pq.empty()) pq.pop();</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(G[i][j].c == <span class="string">'B'</span> || G[i][j].c == <span class="string">'G'</span>) &#123;</span><br><span class="line">        pq.push(G[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">    Node p = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span>(unite(p.u, p.v)) &#123;</span><br><span class="line">      tot++;</span><br><span class="line">      ret += p.w;</span><br><span class="line">      vis[p.id] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[G[i][j].id]) pq.push(G[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ret += pq.top().w; pq.pop(); pq.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> make_pair(ret, tot == n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">  <span class="keyword">char</span> c[<span class="number">5</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    eid = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d%s"</span>,&amp;u,&amp;v,&amp;w,c);</span><br><span class="line">      G[u].push_back(&#123;eid, u, v, w, c[<span class="number">0</span>]&#125;);</span><br><span class="line">      G[v].push_back(&#123;eid++, v, u, w, c[<span class="number">0</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++_);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(k &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> ret = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">      tmp = gao1(k);</span><br><span class="line">      <span class="keyword">if</span>(tmp.second) &#123;</span><br><span class="line">        ret = min(ret, tmp.first);</span><br><span class="line">      &#125;</span><br><span class="line">      tmp = gao2(k);</span><br><span class="line">      <span class="keyword">if</span>(tmp.second) &#123;</span><br><span class="line">        ret = min(ret, tmp.first);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(ret == <span class="number">0x7f7f7f7f</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018百度之星 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[2018百度之星] 资格赛1001 调查问卷 (状压枚举, 计数)</title>
      <link href="/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1001-%E8%B0%83%E6%9F%A5%E9%97%AE%E5%8D%B7-%E7%8A%B6%E5%8E%8B%E6%9E%9A%E4%B8%BE-%E8%AE%A1%E6%95%B0/"/>
      <url>/blog/2018/08/05/2018%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E8%B5%84%E6%A0%BC%E8%B5%9B1001-%E8%B0%83%E6%9F%A5%E9%97%AE%E5%8D%B7-%E7%8A%B6%E5%8E%8B%E6%9E%9A%E4%B8%BE-%E8%AE%A1%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1001" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1001</a></p><a id="more"></a><p>没啥好解释的，中文题意。</p><p>因为题目最多10道，因此枚举所有题目的组合，然后把每一份问卷的对应答案存出来，对每一类单独统计数目。之后每一类中的问卷答案数$k$与其他问卷答案成的对数为$p×(n-p)$，累加所有问卷答案对数再除以2，跟目标k比较一下就ok。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">char</span> s[maxn][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> cur[maxn][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T, _ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mm = <span class="number">1</span> &lt;&lt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mm; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> qq = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) &#123;</span><br><span class="line">            cur[l][qq] = s[l][j] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          qq++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) f[j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; qq; l++) &#123;</span><br><span class="line">          f[j] &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          f[j] |= (cur[j][l] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      vis.clear();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) vis[f[j]]++;</span><br><span class="line">      <span class="keyword">int</span> tot = n, tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> p : vis) &#123;</span><br><span class="line">        tmp += (n - p.second) * p.second;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(tmp / <span class="number">2</span> &gt;= k) ret++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, ++_, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018百度之星 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1016C] Vasya And The Mushrooms (DP)</title>
      <link href="/blog/2018/08/04/Codeforces1016C-Vasya-And-The-Mushrooms-DP/"/>
      <url>/blog/2018/08/04/Codeforces1016C-Vasya-And-The-Mushrooms-DP/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1016/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/1016/problem/C</a></p><p><strong>给出一个$2×n$的矩阵，一个人从$(1,1)$出发，每一个格子只能走一次，走完这$2n$个格子后使得带权和最大，问最大的带权和是多少。</strong></p><a id="more"></a><p>容易发现走到最后一个格子之前路径可以分为两个部分：前半部分蛇皮走位，后半部分一个大回环。</p><p>但是决定走大回环的位置也是分奇偶的，于是我们预处理出每一行的前缀和$sa_i$和$sb_i$，以及两组后缀和，分别为拐弯前（$da_i、db_i$）和拐弯后（$ia_i、ib_i$）。</p><p>然后我们可以枚举拐弯的结点，并同时记录前面走蛇皮位的结果，同时讨论目前在下还是在上，决定大回环值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300003</span>;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL a[maxn], b[maxn];</span><br><span class="line">LL sa[maxn], sb[maxn], ia[maxn], ib[maxn], da[maxn], db[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b[i]);</span><br><span class="line">    <span class="built_in">memset</span>(sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="built_in">memset</span>(sb, <span class="number">0</span>, <span class="keyword">sizeof</span>(sb));</span><br><span class="line">    <span class="built_in">memset</span>(ia, <span class="number">0</span>, <span class="keyword">sizeof</span>(ia));</span><br><span class="line">    <span class="built_in">memset</span>(ib, <span class="number">0</span>, <span class="keyword">sizeof</span>(ib));</span><br><span class="line">    <span class="built_in">memset</span>(da, <span class="number">0</span>, <span class="keyword">sizeof</span>(da));</span><br><span class="line">    <span class="built_in">memset</span>(db, <span class="number">0</span>, <span class="keyword">sizeof</span>(db));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      sa[i] = sa[i+<span class="number">1</span>] + a[i];</span><br><span class="line">      sb[i] = sb[i+<span class="number">1</span>] + b[i];</span><br><span class="line">      ia[i] = ia[i+<span class="number">1</span>] + a[i] * (LL)(n-i<span class="number">-1L</span>L);</span><br><span class="line">      ib[i] = ib[i+<span class="number">1</span>] + b[i] * (LL)(n-i<span class="number">-1L</span>L);</span><br><span class="line">      da[i] = da[i+<span class="number">1</span>] + a[i] * (LL)i;</span><br><span class="line">      db[i] = db[i+<span class="number">1</span>] + b[i] * (LL)i;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        LL tr = db[i] + sb[i] * (<span class="number">2L</span>L*i - i);</span><br><span class="line">        tr += ia[i] + sa[i] * (<span class="number">2L</span>L*i + n - i);</span><br><span class="line">        ret = max(ret, tmp+tr);</span><br><span class="line">        tmp += (<span class="number">2L</span>L*i*b[i]);</span><br><span class="line">        tmp += (<span class="number">2L</span>L*i+<span class="number">1L</span>L)*a[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        LL tr = da[i] + sa[i] * (<span class="number">2L</span>L*i - i);</span><br><span class="line">        tr += ib[i] + sb[i] * (<span class="number">2L</span>L*i + n - i);</span><br><span class="line">        ret = max(ret, tmp+tr);</span><br><span class="line">        tmp += (<span class="number">2L</span>L*i*a[i]);</span><br><span class="line">        tmp += (<span class="number">2L</span>L*i+<span class="number">1L</span>L)*b[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1016D] Vasya And The Matrix (构造)</title>
      <link href="/blog/2018/08/04/Codeforces1016D-Vasya-And-The-Matrix-%E6%9E%84%E9%80%A0/"/>
      <url>/blog/2018/08/04/Codeforces1016D-Vasya-And-The-Matrix-%E6%9E%84%E9%80%A0/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1016/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1016/problem/D</a></p><p><strong>给出一个矩阵的行和列的大小$n，m$以及每一行和每一列的异或和$a_i$和$b_i$，让你构造这样一个矩阵。</strong></p><a id="more"></a><p>考虑将每一行的异或和放到第一列上，每一列的异或和放到第一行上。问题在$(1,1)$处，这里可以用$a_2、a_3、…、a_n$。接下来判断这个数和第一行的异或和是否为$b_1$即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], ret;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">      ret ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">      ret ^= b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    G[<span class="number">1</span>][<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      G[<span class="number">1</span>][<span class="number">1</span>] ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      G[<span class="number">1</span>][i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      G[i][<span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      p ^= G[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p != a[<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, G[i][j], <span class="string">" \n"</span>[j==m]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018牛客多校05 E room (费用流)</title>
      <link href="/blog/2018/08/03/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A105-E-room-%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
      <url>/blog/2018/08/03/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A105-E-room-%E8%B4%B9%E7%94%A8%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/acm/contest/143/E" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/143/E</a></p><p><strong>n个宿舍，每个宿舍住4个人，给两年的住宿情况，问最少调换多少人，能从前一年的住宿状态调换到后一年的住宿状态（宿舍顺序不影响）。</strong></p><a id="more"></a><p>比赛的时候没时间看，补题的时候发现是一道挺好想的费用流问题。</p><p>考虑宿舍整体，当一个宿舍变为另一个宿舍的时候，我们的代价是这两个宿舍中不同人的个数，按照这条规律，我们可以建图：</p><p>单独建超级源和超级汇，之后按照不同年份和不同宿舍建点，不同年的每个宿舍之间连接一条边，容量为1，费用为不同人的个数。源点连接前一年的点，容量为1费用为0，后一年的点连汇点，容量为1费用为0。这样跑一下最小费用最大流就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, next;</span><br><span class="line">  LL c, w;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">40100</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">0x3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">const</span> LL inf = (<span class="number">1L</span>L&lt;&lt;<span class="number">55</span>);</span><br><span class="line"><span class="keyword">int</span> tot, head[maxn];</span><br><span class="line">LL dist[maxn];</span><br><span class="line">LL cost, flow;</span><br><span class="line">Node e[maxm];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> S, T, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S = T = N = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL c, LL w)</span> </span>&#123;</span><br><span class="line">  e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">  e[tot].u = v; e[tot].v = u; e[tot].c = <span class="number">0</span>; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dist[i] = inf;</span><br><span class="line">    visit[i] = <span class="number">0</span>;</span><br><span class="line">    pre[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">  Q.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  pre[s] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q.front();</span><br><span class="line">    visit[u] = <span class="literal">false</span>;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(e[j].c &gt; <span class="number">0</span> &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123;</span><br><span class="line">        dist[e[j].v] = dist[u] + e[j].w;</span><br><span class="line">        pre[e[j].v] = j;</span><br><span class="line">        <span class="keyword">if</span>(!visit[e[j].v]) &#123;</span><br><span class="line">          Q.push(e[j].v);</span><br><span class="line">          visit[e[j].v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return dist[t] &lt; 0; // 求可行流</span></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 求最小费用流</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ChangeFlow</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  LL det = mod;</span><br><span class="line">  <span class="keyword">int</span> u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    det = min(det, e[u].c);</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  u = t;</span><br><span class="line">  <span class="keyword">while</span>(~pre[u]) &#123;</span><br><span class="line">    u = pre[u];</span><br><span class="line">    e[u].c -= det;</span><br><span class="line">    e[u ^ <span class="number">1</span>].c += det;</span><br><span class="line">    u = e[u].u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> det;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">MinCostFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  LL mincost, maxflow;</span><br><span class="line">  mincost = maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(spfa(s, t, n)) &#123;</span><br><span class="line">    LL det = ChangeFlow(t);</span><br><span class="line">    mincost += det * dist[t];</span><br><span class="line">    maxflow += det;</span><br><span class="line">  &#125;</span><br><span class="line">  cost = mincost;</span><br><span class="line">  flow = maxflow;</span><br><span class="line">  <span class="keyword">return</span> mincost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    init();T = <span class="number">2</span> * n + <span class="number">1</span>; N = T + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">int</span> tot = n * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        vis[i][x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        vis[i][x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      adde(S, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      adde(i+n, T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tot; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(vis[i][k][<span class="number">0</span>] == vis[j][k][<span class="number">1</span>] &amp;&amp; vis[i][k][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            diff++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        adde(i, j+n, <span class="number">1</span>, <span class="number">4</span>-diff);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MinCostFlow(S, T, N) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 2018牛客多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HDOJ6301] 18多校01 Distinct Values (莫队算法, 构造)</title>
      <link href="/blog/2018/08/03/HDOJ6301-Distinct-Values-%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2018/08/03/HDOJ6301-Distinct-Values-%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6301" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6301</a></p><p><strong>给出m个区间，要求构造一个指定区间内的数字不能相等，并且数字在$[1,n]$之间，求构造的字典序最小的方案。</strong> </p><a id="more"></a><p>首先给区间排个序，按照左端点小、右端点小的规则排。接下来维护两个指针L、R，从左到右往里塞，然后用类似莫队的更新方法去维护数列，同时维护目前可用的数字。 整体复杂度为$O(n+m)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Node = struct &#123;</span><br><span class="line">  <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[maxn];</span><br><span class="line">Node p[maxn];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    st.clear();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].l,&amp;p[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p+<span class="number">1</span>, p+m+<span class="number">1</span>, [](Node a, Node b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.l == b.l ? a.r &lt; b.r : a.l &lt; b.l;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      st.insert(i);</span><br><span class="line">      a[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = p[<span class="number">1</span>].l, R = p[<span class="number">1</span>].r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt;= R; i++) &#123;</span><br><span class="line">      a[i] = *st.begin();</span><br><span class="line">      st.erase(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span>(L &lt; p[i].l) &#123;</span><br><span class="line">        st.insert(a[L++]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(R &lt; p[i].r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(R + <span class="number">1</span> &lt; p[i].l) R++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          a[++R] = *st.begin();</span><br><span class="line">          st.erase(a[R]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, a[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018杭电多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫队算法 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HDOJ6299] 18多校01 Balanced Sequence (贪心)</title>
      <link href="/blog/2018/08/03/HDOJ6299-Balanced-Sequence-%E8%B4%AA%E5%BF%83/"/>
      <url>/blog/2018/08/03/HDOJ6299-Balanced-Sequence-%E8%B4%AA%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6299" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6299</a></p><p><strong>n个括号串，问如何排列这n个串，使得连起来后()匹配的对数最多（不用连续）。</strong></p><a id="more"></a><p>首先串内匹配并记录答案。之后尽可能让左括号多的在左边，右括号多的在右边排序，再贪心扫一遍，只维护左括号的个数，同时根据下一个串右括号的个数统计答案。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Node = struct &#123;</span><br><span class="line">  <span class="keyword">int</span> l, r, v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; p;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    p.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">      <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; s[j]; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[j] == <span class="string">'('</span>) &#123;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(l != <span class="number">0</span>) l--, tot++;</span><br><span class="line">          <span class="keyword">else</span> r++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      p[i].l = l, p[i].r = r, p[i].v = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p.begin(), p.end(), [](Node a, Node b) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a.l &gt; a.r) &#123;</span><br><span class="line">        <span class="keyword">return</span> b.l &gt; b.r ? a.r &lt; b.r : <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> b.l &lt;= b.r ? a.l &gt; b.l : <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      ret += p[i].v;</span><br><span class="line">      l += p[i].l; r += p[i+<span class="number">1</span>].r;</span><br><span class="line">      ret += min(l, r);</span><br><span class="line">      l -= min(l, r); r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += p[n<span class="number">-1</span>].v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret * <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> HDOJ </category>
          
          <category> 2018杭电多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Hackerrank] Array Partition (并查集, 数学)</title>
      <link href="/blog/2018/08/03/Hackerrank-Array-Partition-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%95%B0%E5%AD%A6/"/>
      <url>/blog/2018/08/03/Hackerrank-Array-Partition-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%95%B0%E5%AD%A6/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.hackerrank.com/contests/hourrank-29/challenges/array-partition" target="_blank" rel="noopener">https://www.hackerrank.com/contests/hourrank-29/challenges/array-partition</a></p><p><strong>给n个数，让你将这n个数拆分成两个集合，使得两个集合分别乘积互质，求拆分方案数。</strong></p><a id="more"></a><p>第一次打Hackerrank，一个小时三道题还是很刺激的。这道题比赛的时候没调出来，只拿了部分分，有点遗憾啊~）ps：衣服还是很难拿的，top10 才有，这场出现了tourist等众神牛，这种场拿衣服还是不想了。</p><p>根据题目的要求，显然拥有相同因数的数字必须呆在同一个集合（1除外，这是个trick，后面会说），考虑用一个方法，将所有拥有至少一个公共因数的数字划为同一个集合，然后再对所有不连通的集合进行计数，会发现：当有$n$个集合的时候，我们的划分方案数为$2^{n}-2$。</p><p>很显然可以用并查集维护每一个数的因数的连通情况，因此我们在枚举每一个数的因数的同时，将因数和这个数并到一起就可以了。这里需要特别注意的是，每一个1都可以分到一个单独的集合里，因此计数的时候需要单独考虑~</p><p>整体复杂度为$O(n\sqrt{n})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  x = find(x); y = find(y);</span><br><span class="line">  <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">    pre[x] = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> nn = <span class="number">1</span> &lt;&lt; a.size();</span><br><span class="line">  vis.clear();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) pre[i] = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == <span class="number">1</span>) cnt++;</span><br><span class="line">    vis.insert(a[i]);</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">    <span class="keyword">int</span> aa = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(a[i]) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= aa; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tmp % j == <span class="number">0</span>) &#123;</span><br><span class="line">        unite(a[i], j);</span><br><span class="line">        vis.insert(j);</span><br><span class="line">        <span class="keyword">while</span>(tmp % j == <span class="number">0</span>) tmp /= j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp != <span class="number">1</span>) unite(a[i], tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; block;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis.find(i) != vis.end()) &#123;</span><br><span class="line">      block[find(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(block.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LL ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block.size(); i++) &#123;</span><br><span class="line">    ret *= <span class="number">2</span>;</span><br><span class="line">    ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ret *= <span class="number">2</span>;</span><br><span class="line">    ret %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  ret -= <span class="number">2</span>; ret += mod; ret %= mod;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Hackerrank </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018牛客多校05 J plan(数学，规律)</title>
      <link href="/blog/2018/08/02/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A105-J-plan-%E6%95%B0%E5%AD%A6%EF%BC%8C%E8%A7%84%E5%BE%8B/"/>
      <url>/blog/2018/08/02/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A105-J-plan-%E6%95%B0%E5%AD%A6%EF%BC%8C%E8%A7%84%E5%BE%8B/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/acm/contest/143/J" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/143/J</a></p><p><strong>n个人住宾馆，双人间价格为p2，三人间价格为p3，如何安排，使总花费最少。</strong></p><a id="more"></a><p>列方程，枚举最近的6个结果即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL n, a, b;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;a,&amp;b)) &#123;</span><br><span class="line">    LL ret = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">      ret = min(ret, (n+<span class="number">1</span>-i)/<span class="number">2</span>*a+(i+<span class="number">2</span>)/<span class="number">3</span>*b);</span><br><span class="line">      ret = min(ret, (n+<span class="number">2</span>-i)/<span class="number">3</span>*b+(i+<span class="number">1</span>)/<span class="number">2</span>*a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 2018牛客多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 规律 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018牛客多校05 G max(数学，规律)</title>
      <link href="/blog/2018/08/02/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A105-G-max-%E6%95%B0%E5%AD%A6%EF%BC%8C%E8%A7%84%E5%BE%8B/"/>
      <url>/blog/2018/08/02/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A105-G-max-%E6%95%B0%E5%AD%A6%EF%BC%8C%E8%A7%84%E5%BE%8B/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/acm/contest/143/G" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/143/G</a></p><p><strong>给定c、n，求两个整数a、b，使得$gcd(a,b)=c, 1≤a,b≤n$</strong></p><a id="more"></a><p>很容易发现只需要选择最接近n的c的倍数数、以及次接近n的c的倍数乘积就是最大的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL c, n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;c,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(c &gt; n) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, n*(n<span class="number">-1</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == c) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, c * c);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n % c == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, n*(n-c));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      LL t = n / c * c;</span><br><span class="line">      <span class="keyword">if</span>(t == c) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t*t);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t*(t-c));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 2018牛客多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 规律 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018牛客多校05 A gpa (01分数规划)</title>
      <link href="/blog/2018/08/02/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A105-A-gpa-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
      <url>/blog/2018/08/02/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A105-A-gpa-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/acm/contest/143/A" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/143/A</a></p><p><strong>一个人有n个成绩，然后现在他可以删掉其中至多k个，使得目标方程$\frac{\sum[s[i]c[i]}{\sum s[i]}$的值最大，问这个值可以是多少。</strong></p><a id="more"></a><p>这题和<a href="https://www.cnblogs.com/kirai/p/5812548.html" target="_blank" rel="noopener">POJ2976</a>是很类似的，是用01分数规划可以解决的问题。01分数规划可以看做是一种思想，可以用二分查找实现。针对这一道题，我们希望让目标方程尽可能大，于是可以假设：<br>$$<br>\frac{\sum[s[i]c[i]}{\sum s[i]} \geq L<br>$$<br>移项后得：<br>$$<br>\sum{s_ic_i-L×s_i}\geq0<br>$$<br>于是我们可以二分$L$，对该式中的$s_ic_i-L×s_i$进行计算并排序，删掉最小的k个后，查看是否满足题意。当收敛时，即$L$近似为式子的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">101000</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"><span class="keyword">int</span> s[maxn], c[maxn];</span><br><span class="line"><span class="keyword">double</span> d[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">double</span> L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) d[i] = (<span class="keyword">double</span>)(s[i] * c[i]) - L * (<span class="keyword">double</span>)s[i];</span><br><span class="line">  sort(d+<span class="number">1</span>, d+n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">double</span> tot = <span class="number">.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = k+<span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    tot += d[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">    <span class="keyword">double</span> lo = <span class="number">.0</span>, hi = <span class="number">1e3</span>;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hi - lo &gt; eps) &#123;</span><br><span class="line">      <span class="keyword">double</span> mid = (lo + hi) / <span class="number">2.0</span>;</span><br><span class="line">      <span class="keyword">if</span>(ok(mid)) lo = mid;</span><br><span class="line">      <span class="keyword">else</span> hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.11f\n"</span>, lo);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 2018牛客多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 01分数规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1006E] Military Problem(DFS)</title>
      <link href="/blog/2018/08/01/Codeforces1006E-Military-Problem-DFS/"/>
      <url>/blog/2018/08/01/Codeforces1006E-Military-Problem-DFS/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1006/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1006/problem/E</a></p><p><strong>给一棵$n$个节点的树和$q$次询问，每次询问两个数$u、k$，表示第u个节点的第k个前序遍历的结果是谁。</strong></p><a id="more"></a><p>这么水的题竟然放在了E，可能这就是div 3吧…</p><p>dfs一遍，维护出每个节点$i$的前序遍历的次序$ret_i$，以及该节点的子树中共计多少个节点$sz_i$，可以利用$ret_i$维护出第$j$号遍历的节点是$id_i$。当我们要求的某节点开始往后数$k$个数不存在时，输出-1；否则我们的答案就是$ret[id[u]+k-1]$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> ret[maxn], sz[maxn], id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  ret[++tot] = u;</span><br><span class="line">  <span class="keyword">int</span> son = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">    son += dfs(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sz[u] = son;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> u, k;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q)) &#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    <span class="built_in">memset</span>(sz, <span class="number">0</span>, <span class="keyword">sizeof</span>(sz));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;u);</span><br><span class="line">      G[i].push_back(u);</span><br><span class="line">      G[u].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sz[<span class="number">1</span>] = dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) id[ret[i]] = i;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;k);</span><br><span class="line">      <span class="keyword">if</span>(k - <span class="number">1</span> &gt;= sz[u]) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret[id[u]+k<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1006D] Two Strings Swaps(规律)</title>
      <link href="/blog/2018/08/01/Codeforces1006D-Two-Strings-Swaps-%E8%A7%84%E5%BE%8B/"/>
      <url>/blog/2018/08/01/Codeforces1006D-Two-Strings-Swaps-%E8%A7%84%E5%BE%8B/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1006/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1006/problem/D</a></p><p><strong>给你两个字符串，定义三种操作。要求你事先给其中一个字符串替换某几个字符，然后再经过任一种上述操作变成两个一样的字符串，问预处理替换的字符最少要几个</strong></p><a id="more"></a> <p>一个很容易发现的规律就是每次处理的时候仅需要关心操作涉及的四个字符，然后再分类讨论一下就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s,t);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a;</span><br><span class="line">      a[s[i]]++; a[s[n-i<span class="number">-1</span>]]++;</span><br><span class="line">      a[t[i]]++; a[t[n-i<span class="number">-1</span>]]++;</span><br><span class="line">      <span class="keyword">if</span>(a.size() == <span class="number">4</span>) ret += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.size() == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[n-i<span class="number">-1</span>]) ret += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.size() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[s[i]] != <span class="number">2</span>) ret++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[n/<span class="number">2</span>] != t[n/<span class="number">2</span>]) ret++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规律 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1015E(1,2)] Stars Drawing (贪心,暴力)</title>
      <link href="/blog/2018/08/01/Codeforces1015E-1-2-Stars-Drawing-%E8%B4%AA%E5%BF%83-%E6%9A%B4%E5%8A%9B/"/>
      <url>/blog/2018/08/01/Codeforces1015E-1-2-Stars-Drawing-%E8%B4%AA%E5%BF%83-%E6%9A%B4%E5%8A%9B/</url>
      <content type="html"><![CDATA[<p>链接：</p><p><a href="http://codeforces.com/contest/1015/problem/E1" target="_blank" rel="noopener">http://codeforces.com/contest/1015/problem/E1</a></p><p><a href="http://codeforces.com/contest/1015/problem/E2" target="_blank" rel="noopener">http://codeforces.com/contest/1015/problem/E2</a></p><p><strong>给你一个$n×m$的矩阵，里面的*组成十字（至少要5个构成十字，比如5个的十字大小为1，一次类推），问这里面的*是否能都组成十字。并输出一个方案。</strong></p><a id="more"></a> <p>这题暴力，贪心地让每一个*向四个方向延拓尽可能长的范围，并打好标记，存下所有可能的十字，看看这些标记里有没有是*但是为标记的就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">using</span> Node = struct &#123;</span><br><span class="line">  <span class="keyword">int</span> x, y, v;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; p, ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">bool</span> yes = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> tx = x + dx[i] * tot;</span><br><span class="line">      <span class="keyword">int</span> ty = y + dy[i] * tot;</span><br><span class="line">      <span class="keyword">if</span>(ok(tx, ty) &amp;&amp; G[tx][ty] == <span class="string">'*'</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> tx = x + dx[i] * tot;</span><br><span class="line">      <span class="keyword">int</span> ty = y + dy[i] * tot;</span><br><span class="line">      vis[tx][ty] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    yes = <span class="literal">true</span>;</span><br><span class="line">    tot++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(yes) &#123;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    ret.push_back(&#123;x+<span class="number">1</span>, y+<span class="number">1</span>, tot<span class="number">-1</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    p.clear(); ret.clear();</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[i][j] == <span class="string">'*'</span>) p.push_back(&#123;i, j, <span class="number">0</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : p) gao(t.x, t.y);</span><br><span class="line">    <span class="keyword">if</span>(ret.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i][j] &amp;&amp; G[i][j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">          flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : ret) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, t.x, t.y, t.v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1015D] Walking Between Houses (构造)</title>
      <link href="/blog/2018/08/01/Codeforces1015D-Walking-Between-Houses-%E6%9E%84%E9%80%A0/"/>
      <url>/blog/2018/08/01/Codeforces1015D-Walking-Between-Houses-%E6%9E%84%E9%80%A0/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1015/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1015/problem/D</a></p><p><strong>有$1~n$个房子，一个人从$1$出发，每次可以走任意步，现在希望走$k$次，求一个方案，这$k$次能走够$s$步（走到一个房子的地方，下一次再走的时候要以那个地方为起点）。</strong></p><a id="more"></a> <p>提供两种构造方法：</p><p>1：首先尽可能多地走$n-1$步，然后再走$s-(k-1)$步，最后剩下的都走$1$步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">100100</span>;</span><br><span class="line">LL n, k, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;k,&amp;s)) &#123;</span><br><span class="line">    LL tot = (n - <span class="number">1</span>) * k;</span><br><span class="line">    <span class="keyword">if</span>(tot &lt; s) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &gt; s) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL cur = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; ret;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">      LL t = min(n - <span class="number">1</span>, s - (k - <span class="number">1</span>));</span><br><span class="line">      cur = cur - t &gt; <span class="number">0</span> ? cur - t : cur + t;</span><br><span class="line">      s -= t;</span><br><span class="line">      k--;</span><br><span class="line">      ret.push_back(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, ret[i], <span class="string">" \n"</span>[i==ret.size()<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2：$p=\frac{s}{k}$，$q=s%k$，走$q$个$p+1$步，$k-q$个$p$步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL n, k, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;k,&amp;s)) &#123;</span><br><span class="line">    LL tot = (n - <span class="number">1</span>) * k;</span><br><span class="line">    <span class="keyword">if</span>(tot &lt; s) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &gt; s) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL p = s / k;</span><br><span class="line">    LL q = s % k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; ret;</span><br><span class="line">    LL cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">      ret.push_back((i % <span class="number">2</span> == <span class="number">0</span>) ? p+<span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">      cur = (i % <span class="number">2</span> == <span class="number">0</span>) ? p+<span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - q; i++) &#123;</span><br><span class="line">        cur += (i % <span class="number">2</span> == <span class="number">0</span>) ? p : -p;</span><br><span class="line">        ret.push_back(cur);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - q; i++) &#123;</span><br><span class="line">        cur += (i % <span class="number">2</span> == <span class="number">0</span>) ? -p : p;</span><br><span class="line">        ret.push_back(cur);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, ret[i], <span class="string">" \n"</span>[i==ret.size()<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1013E] Hills(DP)</title>
      <link href="/blog/2018/07/31/Codeforces1013E-Hills-DP/"/>
      <url>/blog/2018/07/31/Codeforces1013E-Hills-DP/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1013/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1013/problem/E</a></p><p><strong>给n个数，允许让每个数删减，现想要求k个严格的局部最大值，k取值为$[1,\lceil\frac{n}{2}\rceil]$。</strong></p><a id="more"></a> <p>这dp考的时候没想出来，可以这么做：$f(i,j,k)$表示前$i$个数里有$j$个最大值，此时还讨论第$i$个数是($k=1$)否($k=0$)是局部最大值。</p><p>状态转移如下：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/cf1013E1.png" alt="img"></p><p>$k=0$时，$f(i,j,0)$可以更新到$f(i+1,j,0)$上，因为此时$i$和$i+1$都不是局部最大值，因此$j$不会变；或者更新到$f(i+1,j+1,1)$上，此时在$i+1$处为一个局部最大值。</p><p>$k=1$时，$f(i,k,1)$更新到$f(i+1,j,0)$上，但是相应地要有删减的代价；也可以更新到$f(i+2,j+1,1)$上，显然$i+1$处必然是一个极小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y ? <span class="number">0</span> : y - x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> K = (<span class="keyword">int</span>)<span class="built_in">ceil</span>(n / <span class="number">2.0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(f[i][j][k] == inf) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">            f[i+<span class="number">1</span>][j+<span class="number">1</span>][<span class="number">1</span>] = min(f[i+<span class="number">1</span>][j+<span class="number">1</span>][<span class="number">1</span>], f[i][j][k] + update(a[i+<span class="number">1</span>], a[i]));</span><br><span class="line">            f[i+<span class="number">1</span>][j][<span class="number">0</span>] = min(f[i+<span class="number">1</span>][j][<span class="number">0</span>], f[i][j][k]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i+<span class="number">2</span>][j+<span class="number">1</span>][<span class="number">1</span>] = min(f[i+<span class="number">2</span>][j+<span class="number">1</span>][<span class="number">1</span>], f[i][j][k] + update(min(a[i], a[i+<span class="number">2</span>]), a[i+<span class="number">1</span>]));</span><br><span class="line">            f[i+<span class="number">1</span>][j][<span class="number">0</span>] = min(f[i+<span class="number">1</span>][j][<span class="number">0</span>], f[i][j][k] + update(a[i], a[i+<span class="number">1</span>]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, min(f[n][i][<span class="number">0</span>], f[n][i][<span class="number">1</span>]), <span class="string">" \n"</span>[i==K]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1013] Round #500 (Div. 2) [based on EJOI]</title>
      <link href="/blog/2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/"/>
      <url>/blog/2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/</url>
      <content type="html"><![CDATA[<p>链接：<a href="http://codeforces.com/contest/1013" target="_blank" rel="noopener">http://codeforces.com/contest/1013</a></p><a id="more"></a> <p>A：<strong>n堆贝壳，第一天每一堆有ai个，现在可以拿走也可以移动任意个，然后给出第二天每一堆的贝壳的数量，问有没有可能。</strong></p><p>两天的贝壳求和，如果不等就不可能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1111</span>;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">      a += t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">      b += t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= b) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>给n个数ai，以及一个数x，现在允许x和ai进行与（&amp;）操作后替换ai，问最少操作多少次，n个数中出现两个相同的数字。</strong></p><p>由于和x进行与操作后的结果再和x进行操作的结果不会变，因此每一个数至多和x与1次。考虑到结果只可能是-1 0 1 2，因此存下与操作后的数字结果，讨论一下就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, x;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn], vis1[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(vis1, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis1));</span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">      maxx = max(maxx, a[i]);</span><br><span class="line">      vis[a[i]]++;</span><br><span class="line">      vis1[a[i]&amp;x]++;</span><br><span class="line">      maxx = max(maxx, a[i] &amp; x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxx; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(vis[i] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>((a[i] &amp; x) == a[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis1[a[i]] &gt;= <span class="number">2</span>) flag = min(flag, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis1[a[i]]) flag = min(flag, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxx; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(vis1[i] &gt;= <span class="number">2</span> &amp;&amp; !vis[i]) &#123;</span><br><span class="line">        flag = min(flag, <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0x7f7f7f7f</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flag);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>给2n个数字，让你用这2n个数字构成n个二维平面上的点，要求是构造一个平行于坐标轴的、包括所有点的矩形，并且矩形面积最小（面积可以为0）。</strong></p><p>很容易想到的是对a进行排序，之后将2n个数分为x坐标和y坐标两个集合，然后依次结合构成点。画图后发现答案就是两个集合的极差乘积，我们希望让这两个集合的极差尽可能小，因此每次从两个集合中拿出最小的放到对方的集合里，这里滑动窗口模拟一下就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL a[maxn];</span><br><span class="line">pair&lt;LL, LL&gt; p[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="built_in">deque</span>&lt;LL&gt; r, q;</span><br><span class="line"><span class="built_in">multiset</span>&lt;LL&gt; rr, qq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">    vis.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">      vis[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>, a+<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : vis) &#123;</span><br><span class="line">      <span class="keyword">if</span>(p.second &gt;= n) &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.clear(); q.clear();</span><br><span class="line">    rr.clear(); qq.clear();</span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      r.push_back(a[i]);</span><br><span class="line">      rr.insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>; i &lt;= <span class="number">2</span>*n; i++) &#123;</span><br><span class="line">      q.push_back(a[i]);</span><br><span class="line">      qq.insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">9223372036854775800L</span>L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ret = min(ret, ((*rr.rbegin())-(*rr.begin()))*((*qq.rbegin())-(*qq.begin())));</span><br><span class="line">      x = r.front(); y = q.front();</span><br><span class="line">      r.push_back(y); q.push_back(x);</span><br><span class="line">      r.pop_front(); q.pop_front();</span><br><span class="line">      rr.erase(rr.lower_bound(x)), qq.erase(qq.lower_bound(y));</span><br><span class="line">      rr.insert(y); qq.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：<strong>要向一个n×m的矩阵里画叉，并且当三个叉构成如下图所示的操作：</strong></p><p><img src="http://codeforces.com/predownloaded/95/22/95223620a323ec59470718b34958c7f295698ff1.png" alt="img"> </p><p><strong>当到左图的情况时，会如右图：①的位置会补上（也就是构成了一个矩形）。</strong></p><p><strong>现在给你一个n×m的矩阵，以及一些画了叉的位置，问你最少需要手动画多少个叉，能够利用上述操作将整个矩阵填满。</strong></p><p>考虑一个叉都不画的情况，最少需要画n+m-1（就是画一个十字）就能利用上述操作将矩阵填满。</p><p>再来考虑这个操作的实质：比方说现在有了(x1,y1)、(x1,y2)、(x2,y1)三个点，那么第四个点(x2,y2)实际上是没有贡献的，如下图：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180730213701.png" alt="img"></p><p>转换成森林上，希望把坐标这个森林连成一片，问最少要加多少条边。这样我们读入数据的时候，x和y连起来（为了区别x和y，y+n来做分层），当他们的父亲不一样的时候，说明这个连接是必须有的，记一次数。之后用n+m-1减掉这个必要的计数就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4000100</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  x = find(x); y = find(y);</span><br><span class="line">  <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">    pre[x] = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">      <span class="keyword">if</span>(unite(x, y+n)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n+m<span class="number">-1</span>-cnt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Codeforces1011] Round #499 (Div. 2)</title>
      <link href="/blog/2018/07/29/CF1011-Codeforces-Round-499-Div-2/"/>
      <url>/blog/2018/07/29/CF1011-Codeforces-Round-499-Div-2/</url>
      <content type="html"><![CDATA[<p>用hexo搭了博客，以后就在这里写题解和随笔了。</p><a id="more"></a> <p>$$<br>mathjax测试：C_i=\sum_{j×k=i}A_j*B_k<br>$$<br>复健开了一场CF div2，感觉非常不好啊。。</p><p>比赛链接是<a href="http://codeforces.com/contest/1011" target="_blank" rel="noopener">http://codeforces.com/contest/1011</a></p><p>A：<strong>n个字符取k个，不能取字典序相邻的，也不能取相同的。就这样取，问最小的ascii-‘a’+1的和是多少。</strong></p><p>贪心，给字符排个序，取第一个，然后后面的取最小的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    sort(s, s+n);</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, ret = s[<span class="number">0</span>] - <span class="string">'a'</span> + <span class="number">1</span>, tot = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tot &gt;= k) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span>(s[i] - s[pre] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ret += s[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        pre = i;</span><br><span class="line">        tot++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot &lt; k) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B：<strong>n个人吃东西，一共m个东西，每个东西都有一类。每个人每天只能吃一个同一类东西，问怎么分配这m个东西，让这n个人吃得时间最久。</strong></p><p>m很小，直接遍历天数day，然后贪心地check就ok了（数据量大了套个二分就行）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[i] &gt;= day) tot += (<span class="keyword">int</span>)(vis[i] / (<span class="keyword">double</span>)day);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="number">100000</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">      vis[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; m) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">0</span>; mid &lt; <span class="number">101</span>; mid++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ok(mid)) ret = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：<strong>n个星球，一个人坐重量为m的飞船从1出发到n，需要走1-&gt;2-&gt;..-&gt;n-&gt;1这样的路径，从每个点起飞要消耗ai的燃油，在每个点降落要消耗bi的燃油，燃油只能从1上带，问这人要带多少燃油才能完成这个路径。</strong></p><p>二分燃油的量，判断是否满足，或从1-&gt;n-&gt;n-1-&gt;…1逆推，上一次的燃油量是x*m/(x-1)，x为起飞or降落的消耗。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">double</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ok</span><span class="params">(<span class="keyword">double</span> fuel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> tot = fuel + m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    tot -= (<span class="keyword">double</span>)tot / (<span class="keyword">double</span>)a[i];</span><br><span class="line">    tot -= (<span class="keyword">double</span>)tot / (<span class="keyword">double</span>)b[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">    tot -= (<span class="keyword">double</span>)tot / (<span class="keyword">double</span>)a[i];</span><br><span class="line">    tot -= (<span class="keyword">double</span>)tot / (<span class="keyword">double</span>)b[i<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot - m &gt;= eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ret = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    ret = b[i] * ret / (b[i] - <span class="number">1.0</span>);</span><br><span class="line">    ret = a[i+<span class="number">1</span>] * ret / (a[i+<span class="number">1</span>] - <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ret = b[n] * ret / (b[n] - <span class="number">1.0</span>);</span><br><span class="line">  ret = a[<span class="number">1</span>] * ret / (a[<span class="number">1</span>] - <span class="number">1.0</span>);</span><br><span class="line">  ret -= m;</span><br><span class="line">  <span class="keyword">if</span>(ret &gt; <span class="number">1e9</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D：<strong>猜一个1到m的数字x，可以询问最多60次。每次回答有可能是假的，假的情况那么会输出真答案判别的相反数（大于的时候返回1，如果假的情况就返回-1，小于同理），回答的真假情况序列p的长为n，回答按照这个序列循环返回结果。求这个数字x。</strong></p><p>可以用数字1去试探n次（当然答案是1的时候可以直接结束程序了），把n次询问的真假情况预处理出来记下，之后就可以愉快地二分x，根据上面预处理出来的真假情况修改返回结果了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, y);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">  <span class="keyword">if</span>(t == <span class="number">0</span> || t == <span class="number">2</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> t = query(<span class="number">1</span>);</span><br><span class="line">      p[i] = (t == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">2</span>, hi = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span>; ; q++) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> t = query(mid);</span><br><span class="line">      <span class="keyword">if</span>(!p[q%n]) t = -t;</span><br><span class="line">      <span class="keyword">if</span>(t == <span class="number">1</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>E：<strong>n个数，每个数可以取任意次，相加后对k取模。求模的结果的个数。</strong></p><p>统计k和每个数的gcd，答案就是k/gcd，依次取0,k/gcd,2k/gcd…就行了。过阵子尝试证明一下，相关概念有：有限域，生成元，生成多项式，循环群，裴蜀定理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL k;</span><br><span class="line">LL a[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    LL x = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">      x = __gcd(x, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, k / x);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; k; i+=x) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 交互题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018牛客多校01 J Different Integers</title>
      <link href="/blog/2018/07/20/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A101-J-Different-Integers/"/>
      <url>/blog/2018/07/20/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A101-J-Different-Integers/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/acm/contest/139/J" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/139/J</a></p><p><strong>n个数，q次查询l,r。求[1,l]和[r,n]中不同数的个数。</strong></p><a id="more"></a> <p>这题首先开二倍数组，然后在后n个位置重新存一遍这n个数，这样就相当于查询[r, n+l]内不同数的个数，用莫队或者bit离线计数都能做（代码是莫队）。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">scan_d</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> in;<span class="keyword">bool</span> IsN=<span class="literal">false</span>;</span><br><span class="line">    in=getchar();</span><br><span class="line">    <span class="keyword">if</span>(in==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(in!=<span class="string">'-'</span>&amp;&amp;(in&lt;<span class="string">'0'</span>||in&gt;<span class="string">'9'</span>)) in=getchar();</span><br><span class="line">    <span class="keyword">if</span>(in==<span class="string">'-'</span>)&#123; IsN=<span class="literal">true</span>;num=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> num=in-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(in=getchar(),in&gt;=<span class="string">'0'</span>&amp;&amp;in&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        num*=<span class="number">10</span>,num+=in-<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(IsN) num=-num;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">using</span> Query = struct &#123; <span class="keyword">int</span> l, r, ret, id; &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn&lt;&lt;<span class="number">1</span>], be[maxn&lt;&lt;<span class="number">1</span>], L, R;</span><br><span class="line">Query q[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn], sz;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;ret)</span> </span>&#123;</span><br><span class="line">    vis[x]++;</span><br><span class="line">    <span class="keyword">if</span>(vis[x] == <span class="number">1</span>) ret++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;ret)</span> </span>&#123;</span><br><span class="line">    vis[x]--;</span><br><span class="line">    <span class="keyword">if</span>(vis[x] == <span class="number">0</span>) ret--;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">        sz = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(n));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            scan_d(a[i]);</span><br><span class="line">            a[n+i] = a[i];</span><br><span class="line">            be[i] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i / sz);</span><br><span class="line">            be[i+n] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((i + n) / sz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            scan_d(q[i].r); scan_d(q[i].l);</span><br><span class="line">            q[i].r += n;</span><br><span class="line">            q[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q+<span class="number">1</span>, q+m+<span class="number">1</span>, [](Query a, Query b) &#123;</span><br><span class="line">            <span class="keyword">return</span> be[a.l] == be[b.l] ? a.r &lt; b.r : a.l &lt; b.l;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; q[i].l) &#123; remove(a[L], ret); L++; &#125;</span><br><span class="line">            <span class="keyword">while</span>(L &gt; q[i].l) &#123; L--; add(a[L], ret); &#125;</span><br><span class="line">            <span class="keyword">while</span>(R &lt; q[i].r) &#123; R++; add(a[R], ret); &#125;</span><br><span class="line">            <span class="keyword">while</span>(R &gt; q[i].r) &#123; remove(a[R], ret); R--; &#125;</span><br><span class="line">            q[i].ret = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q+<span class="number">1</span>, q+m+<span class="number">1</span>, [](Query a, Query b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, q[i].ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 2018牛客多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫队算法 </tag>
            
            <tag> 离线 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018牛客多校01 D Two Graphs</title>
      <link href="/blog/2018/07/20/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A101-D-Two-Graphs/"/>
      <url>/blog/2018/07/20/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A101-D-Two-Graphs/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/acm/contest/139/D" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/139/D</a></p><p><strong>求G1的同构图，是G2的子图。</strong></p><a id="more"></a> <p>暴力枚举全排列，对于每一个排列，看看G2中是否每一条边都存在，然后再看看是否每一条边都在G1中存在（这里存在的话必然会重复计数），然后用上一个计数结果除以下一个即可。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m1, m2;</span><br><span class="line"><span class="keyword">int</span> id[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn][maxn], c[maxn][maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m1,&amp;m2)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      a[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">      a[x].push_back(y);</span><br><span class="line">      a[y].push_back(x);</span><br><span class="line">      c[x][y] = c[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m2; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">      b[x][y] = b[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m1 &gt; m2) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[x].size(); j++) &#123;</span><br><span class="line">        y = a[x][j];</span><br><span class="line">        <span class="keyword">if</span>(!b[id[x]][id[y]]) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) ret++;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[x].size(); j++) &#123;</span><br><span class="line">        y = a[x][j];</span><br><span class="line">        <span class="keyword">if</span>(!c[id[x]][id[y]]) &#123;</span><br><span class="line">          flag = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) tot++;</span><br><span class="line">  &#125;<span class="keyword">while</span>(next_permutation(id+<span class="number">1</span>, id+n+<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret / tot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 2018牛客多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018牛客多校01 A Monotonic Matrix</title>
      <link href="/blog/2018/07/20/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A101-A-Monotonic-Matrix/"/>
      <url>/blog/2018/07/20/2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A101-A-Monotonic-Matrix/</url>
      <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/acm/contest/139/A" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/139/A</a></p><p><strong>求一个n*m的0、1、2矩阵（满足左上小于右下）的构造方案数。</strong></p><a id="more"></a> <p>方案数就等于这两条可以重合（不可相交）的分界线的种类数，如下图：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/Untitled%20picture.png" alt="img"></p><p>即：给定起点(n,0)、终点(0,m)，只能向上和向右走，问有多少种走法，其实就是向右走m步向上走n步的组合数：<br>$$<br>C_{n+m}^m或C_{n+m}^n<br>$$<br>这里给出<a href="https://en.wikipedia.org/wiki/Lindstr%C3%B6m%E2%80%93Gessel%E2%80%93Viennot_lemma" target="_blank" rel="noopener">Lindström–Gessel–Viennot</a>引理的应用：给一张无权有向无环图，给定n个起点和对应的n个终点，求n条不相交路径的方案数，引理给出结果为：</p><p><img src="http://pcoln8jiu.bkt.clouddn.com/Untitled%20picture1.png" alt="img"></p><p>其中$a_{i}$表示路径i的起点，$b_{i}$表示路径i的终点。答案就是M的行列式的值。</p><p>对于本两条线的起点和终点不能重叠而且得和原方案等价（方案数等价即可），这就需要变换一下。把起终点向左上平移一下，将其中的一对起终点平移到$(n-1,-1)$和$(-1,m-1)$去，就有$e(a_1,b_1)=e(a_2,b_2)=C_{n+m}^n$，$e(a_1,b_2)=C_{n+m}^{n+1}$，$e(a_2,b_1)=C_{n+m}^{m+1}$那么针对本题的答案就是：<br>$$<br>{C_{n+m}^n}^2-C_{n+m}^{n+1}×C_{n+m}^{m+1}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL c[maxn][maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">  c[<span class="number">0</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">    c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">      c[i][j] = c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">      c[i][j] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">    LL ret = c[n+m][n]*c[n+m][n]; ret %= mod;</span><br><span class="line">    LL tmp = c[n+m][n+<span class="number">1</span>]*c[n+m][m+<span class="number">1</span>]; tmp %= mod;</span><br><span class="line">    ret -= tmp; ret += mod; ret %= mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 2018牛客多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
