{"meta":{"title":"Kirai","subtitle":null,"description":null,"author":"Kirai","url":"http://vincentxwd.github.io/blog"},"pages":[{"title":"404","date":"2018-07-29T11:33:50.000Z","updated":"2018-07-29T11:33:50.336Z","comments":true,"path":"404/index.html","permalink":"http://vincentxwd.github.io/blog/404/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-29T12:57:51.000Z","updated":"2018-07-29T13:00:05.998Z","comments":true,"path":"categories/index.html","permalink":"http://vincentxwd.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-29T12:56:26.000Z","updated":"2018-07-29T13:00:19.546Z","comments":true,"path":"tags/index.html","permalink":"http://vincentxwd.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"搜索","date":"2018-07-29T11:33:36.000Z","updated":"2018-07-29T13:00:12.755Z","comments":true,"path":"search/index.html","permalink":"http://vincentxwd.github.io/blog/search/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-07-30T05:59:54.000Z","updated":"2018-07-30T06:01:02.910Z","comments":true,"path":"about/index.html","permalink":"http://vincentxwd.github.io/blog/about/index.html","excerpt":"","text":""}],"posts":[{"title":"[CF1011] Codeforces Round #499 (Div. 2)","slug":"CF1011-Codeforces-Round-499-Div-2","date":"2018-07-29T13:01:44.000Z","updated":"2018-07-30T03:55:28.265Z","comments":true,"path":"2018/07/29/CF1011-Codeforces-Round-499-Div-2/","link":"","permalink":"http://vincentxwd.github.io/blog/2018/07/29/CF1011-Codeforces-Round-499-Div-2/","excerpt":"","text":"用hexo搭了博客，以后就在这里写题解和随笔了。$$mathjax测试：C_i=\\sum_{j×k=i}A_j*B_k$$复健开了一场CF div2，感觉非常不好啊。。 比赛链接是http://codeforces.com/contest/1011 A：n个字符取k个，不能取字典序相邻的，也不能取相同的。就这样取，问最小的ascii-‘a’+1的和是多少。 贪心，给字符排个序，取第一个，然后后面的取最小的。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;char s[maxn];int n, k;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; scanf(\"%s\", s); sort(s, s+n); int pre = 0, ret = s[0] - 'a' + 1, tot = 1; for(int i = 1; i &lt; n; i++) &#123; if(tot &gt;= k) break; if(s[i] - s[pre] &gt; 1) &#123; ret += s[i] - 'a' + 1; pre = i; tot++; &#125; &#125; if(tot &lt; k) &#123; printf(\"-1\\n\"); &#125; else printf(\"%d\\n\", ret); &#125; return 0;&#125; B：n个人吃东西，一共m个东西，每个东西都有一类。每个人每天只能吃一个同一类东西，问怎么分配这m个东西，让这n个人吃得时间最久。 m很小，直接遍历天数day，然后贪心地check就ok了（数据量大了套个二分就行）。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;int n, m;int a[maxn], vis[maxn];int ok(int day) &#123; int tot = 0; for(int i = 0; i &lt; 101; i++) &#123; if(vis[i] &gt;= day) tot += (int)(vis[i] / (double)day); &#125; return tot &gt;= n;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; int lo = 0, hi = 100000; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;a[i]); vis[a[i]]++; &#125; if(n &gt; m) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0; for(int mid = 0; mid &lt; 101; mid++) &#123; if(ok(mid)) ret = mid; &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125; C：n个星球，一个人坐重量为m的飞船从1出发到n，需要走1-&gt;2-&gt;..-&gt;n-&gt;1这样的路径，从每个点起飞要消耗ai的燃油，在每个点降落要消耗bi的燃油，燃油只能从1上带，问这人要带多少燃油才能完成这个路径。 二分燃油的量，判断是否满足，或从1-&gt;n-&gt;n-1-&gt;…1逆推，上一次的燃油量是x*m/(x-1)，x为起飞or降落的消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const double eps = 1e-9;int n, m;double a[maxn], b[maxn];int ok(double fuel) &#123; double tot = fuel + m; for(int i = 1; i &lt;= n - 1; i++) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i+1]; &#125; for(int i = n; i &gt;= 2; i--) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i-1]; &#125; return tot - m &gt;= eps;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; &#125; double ret = m; for(int i = 1; i &lt; n; i++) &#123; ret = b[i] * ret / (b[i] - 1.0); ret = a[i+1] * ret / (a[i+1] - 1.0); &#125; ret = b[n] * ret / (b[n] - 1.0); ret = a[1] * ret / (a[1] - 1.0); ret -= m; if(ret &gt; 1e9) &#123; printf(\"-1\\n\"); &#125; else printf(\"%.10f\\n\", ret); &#125; return 0;&#125; D：猜一个1到m的数字x，可以询问最多60次。每次回答有可能是假的，假的情况那么会输出真答案判别的相反数（大于的时候返回1，如果假的情况就返回-1，小于同理），回答的真假情况序列p的长为n，回答按照这个序列循环返回结果。求这个数字x。 可以用数字1去试探n次（当然答案是1的时候可以直接结束程序了），把n次询问的真假情况预处理出来记下，之后就可以愉快地二分x，根据上面预处理出来的真假情况修改返回结果了。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;int p[maxn];int n, m;int query(int y) &#123; printf(\"%d\\n\", y); fflush(stdout); int t; scanf(\"%d\", &amp;t); if(t == 0 || t == 2) exit(0); return t;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;m,&amp;n)) &#123; memset(p, 0, sizeof(p)); for(int i = 0; i &lt; n; i++) &#123; int t = query(1); p[i] = (t == 1); &#125; int lo = 2, hi = m; for(int q = 0; ; q++) &#123; int mid = (lo + hi) &gt;&gt; 1; int t = query(mid); if(!p[q%n]) t = -t; if(t == 1) lo = mid + 1; else hi = mid - 1; &#125; &#125; return 0;&#125; E：n个数，每个数可以取任意次，相加后对k取模。求模的结果的个数。 统计k和每个数的gcd，答案就是k/gcd，依次取0,k/gcd,2k/gcd…就行了。过阵子尝试证明一下，相关概念有：有限域，生成元，生成多项式，循环群，裴蜀定理。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 100100;int n;LL k;LL a[maxn];bool vis[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%lld\",&amp;n,&amp;k)) &#123; memset(vis, 0, sizeof(vis)); LL x = k; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); x = __gcd(x, a[i]); &#125; printf(\"%lld\\n\", k / x); for(LL i = 0; i &lt; k; i+=x) &#123; printf(\"%lld \", i); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://vincentxwd.github.io/blog/tags/Codeforces/"}]}]}