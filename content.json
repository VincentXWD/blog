{"meta":{"title":"Kirai","subtitle":"我好菜啊 QAQ | I Good Vegetable A QAQ","description":null,"author":"Kirai","url":"http://vincentxwd.github.io/blog"},"pages":[{"title":"404","date":"2018-07-29T11:33:50.000Z","updated":"2018-07-29T11:33:50.336Z","comments":true,"path":"404/index.html","permalink":"http://vincentxwd.github.io/blog/404/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-07-30T05:59:54.000Z","updated":"2018-07-30T12:51:47.710Z","comments":true,"path":"about/index.html","permalink":"http://vincentxwd.github.io/blog/about/index.html","excerpt":"","text":"kirai，在读渣硕，方向是ML和CV。竞赛败犬，科研萌新，喜欢打osu! mania。 如果您在招实习，点击这里可能会多了解一点QAQ。 有问题可以邮箱联系，也可以QQ：107850580。"},{"title":"分类","date":"2018-07-29T12:57:51.000Z","updated":"2018-07-30T07:02:50.215Z","comments":true,"path":"categories/index.html","permalink":"http://vincentxwd.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-29T12:56:26.000Z","updated":"2018-07-30T07:02:56.361Z","comments":true,"path":"tags/index.html","permalink":"http://vincentxwd.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2018-07-29T11:33:36.000Z","updated":"2018-07-30T07:00:53.427Z","comments":true,"path":"search/index.html","permalink":"http://vincentxwd.github.io/blog/search/index.html","excerpt":"","text":""}],"posts":[{"title":"[CF1013] Codeforces Round #500 (Div. 2) [based on EJOI]","slug":"CF1013-Codeforces-Round-500-Div-2-based-on-EJOI","date":"2018-07-30T12:54:12.000Z","updated":"2018-07-30T13:44:05.200Z","comments":true,"path":"2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","link":"","permalink":"http://vincentxwd.github.io/blog/2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","excerpt":"","text":"比赛链接：http://codeforces.com/contest/1013 A：n堆贝壳，第一天每一堆有ai个，现在可以拿走也可以移动任意个，然后给出第二天每一堆的贝壳的数量，问有没有可能。 两天的贝壳求和，如果不等就不可能。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 1111;int a, b;int n;signed main() &#123; // freopen(\"in\", \"r\", stdin); int t; while(~scanf(\"%d\", &amp;n)) &#123; a = 0, b = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;t); a += t; &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\" , &amp;t); b += t; &#125; if(a &gt;= b) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; B：给n个数ai，以及一个数x，现在允许x和ai进行与（&amp;）操作后替换ai，问最少操作多少次，n个数中出现两个相同的数字。 由于和x进行与操作后的结果再和x进行操作的结果不会变，因此每一个数至多和x与1次。考虑到结果只可能是-1 0 1 2，因此存下与操作后的数字结果，讨论一下就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 100100;int n, x;int a[maxn];int vis[maxn], vis1[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;x)) &#123; memset(vis, 0, sizeof(vis)); memset(vis1, 0, sizeof(vis1)); int maxx = -1; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); maxx = max(maxx, a[i]); vis[a[i]]++; vis1[a[i]&amp;x]++; maxx = max(maxx, a[i] &amp; x); &#125; int flag = 0; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis[i] &gt;= 2) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; puts(\"0\"); continue; &#125; flag = 0x7f7f7f7f; for(int i = 1; i &lt;= n; i++) &#123; if((a[i] &amp; x) == a[i]) &#123; if(vis1[a[i]] &gt;= 2) flag = min(flag, 1); &#125; else &#123; if(vis1[a[i]]) flag = min(flag, 1); &#125; &#125; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis1[i] &gt;= 2 &amp;&amp; !vis[i]) &#123; flag = min(flag, 2); &#125; &#125; if(flag == 0x7f7f7f7f) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", flag); &#125; return 0;&#125; C：给2n个数字，让你用这2n个数字构成n个二维平面上的点，要求是构造一个平行于坐标轴的、包括所有点的矩形，并且矩形面积最小（面积可以为0）。 很容易想到的是对a进行排序，之后将2n个数分为x坐标和y坐标两个集合，然后依次结合构成点。画图后发现答案就是两个集合的极差乘积，我们希望让这两个集合的极差尽可能小，因此每次从两个集合中拿出最小的放到对方的集合里，这里滑动窗口模拟一下就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;using LL = unsigned long long;const int maxn = 200100;int n;LL a[maxn];pair&lt;LL, LL&gt; p[maxn];map&lt;LL, int&gt; vis;deque&lt;LL&gt; r, q;multiset&lt;LL&gt; rr, qq;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; vis.clear(); for(int i = 1; i &lt;= 2 * n; i++) &#123; cin &gt;&gt; a[i]; vis[a[i]]++; &#125; sort(a+1, a+2*n+1); bool flag = 0; for(auto p : vis) &#123; if(p.second &gt;= n) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; printf(\"0\\n\"); continue; &#125; r.clear(); q.clear(); rr.clear(); qq.clear(); LL x, y; for(int i = 1; i &lt;= n; i++) &#123; r.push_back(a[i]); rr.insert(a[i]); &#125; for(int i = n+1; i &lt;= 2*n; i++) &#123; q.push_back(a[i]); qq.insert(a[i]); &#125; LL ret = 9223372036854775800LL; for(int i = 1; i &lt;= n; i++) &#123; ret = min(ret, ((*rr.rbegin())-(*rr.begin()))*((*qq.rbegin())-(*qq.begin()))); x = r.front(); y = q.front(); r.push_back(y); q.push_back(x); r.pop_front(); q.pop_front(); rr.erase(rr.lower_bound(x)), qq.erase(qq.lower_bound(y)); rr.insert(y); qq.insert(x); &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; return 0;&#125; D：要向一个n×m的矩阵里画叉，并且当三个叉构成如下图所示的操作： 当到左图的情况时，会如右图：①的位置会补上（也就是构成了一个矩形）。 现在给你一个n×m的矩阵，以及一些画了叉的位置，问你最少需要手动画多少个叉，能够利用上述操作将整个矩阵填满。 考虑一个叉都不画的情况，最少需要画n+m-1（就是画一个十字）就能利用上述操作将矩阵填满。 再来考虑这个操作的实质：比方说现在有了(x1,y1)、(x1,y2)、(x2,y1)三个点，那么第四个点(x2,y2)实际上是没有贡献的，如下图： 转换成森林上，希望把坐标这个森林连成一片，问最少要加多少条边。这样我们读入数据的时候，x和y连起来（为了区别x和y，y+n来做分层），当他们的父亲不一样的时候，说明这个连接是必须有的，记一次数。之后用n+m-1减掉这个必要的计数就行了。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;LL, LL&gt; pll;const int maxn = 4000100;int n, m, q;int pre[maxn];int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;int unite(int x, int y) &#123; x = find(x); y = find(y); if(x != y) &#123; pre[x] = y; return 1; &#125; return 0;&#125;int main() &#123; // freopen(\"in\", \"r\", stdin); int x, y; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q)) &#123; for(int i = 1; i &lt;= n + m; i++) &#123; pre[i] = i; &#125; int cnt = 0; for(int i = 0; i &lt; q; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); if(unite(x, y+n)) cnt++; &#125; printf(\"%d\\n\", n+m-1-cnt); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://vincentxwd.github.io/blog/tags/Codeforces/"}]},{"title":"[CF1011] Codeforces Round #499 (Div. 2)","slug":"CF1011-Codeforces-Round-499-Div-2","date":"2018-07-29T13:01:44.000Z","updated":"2018-07-30T03:55:28.265Z","comments":true,"path":"2018/07/29/CF1011-Codeforces-Round-499-Div-2/","link":"","permalink":"http://vincentxwd.github.io/blog/2018/07/29/CF1011-Codeforces-Round-499-Div-2/","excerpt":"","text":"用hexo搭了博客，以后就在这里写题解和随笔了。$$mathjax测试：C_i=\\sum_{j×k=i}A_j*B_k$$复健开了一场CF div2，感觉非常不好啊。。 比赛链接是http://codeforces.com/contest/1011 A：n个字符取k个，不能取字典序相邻的，也不能取相同的。就这样取，问最小的ascii-‘a’+1的和是多少。 贪心，给字符排个序，取第一个，然后后面的取最小的。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;char s[maxn];int n, k;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; scanf(\"%s\", s); sort(s, s+n); int pre = 0, ret = s[0] - 'a' + 1, tot = 1; for(int i = 1; i &lt; n; i++) &#123; if(tot &gt;= k) break; if(s[i] - s[pre] &gt; 1) &#123; ret += s[i] - 'a' + 1; pre = i; tot++; &#125; &#125; if(tot &lt; k) &#123; printf(\"-1\\n\"); &#125; else printf(\"%d\\n\", ret); &#125; return 0;&#125; B：n个人吃东西，一共m个东西，每个东西都有一类。每个人每天只能吃一个同一类东西，问怎么分配这m个东西，让这n个人吃得时间最久。 m很小，直接遍历天数day，然后贪心地check就ok了（数据量大了套个二分就行）。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;int n, m;int a[maxn], vis[maxn];int ok(int day) &#123; int tot = 0; for(int i = 0; i &lt; 101; i++) &#123; if(vis[i] &gt;= day) tot += (int)(vis[i] / (double)day); &#125; return tot &gt;= n;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; int lo = 0, hi = 100000; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;a[i]); vis[a[i]]++; &#125; if(n &gt; m) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0; for(int mid = 0; mid &lt; 101; mid++) &#123; if(ok(mid)) ret = mid; &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125; C：n个星球，一个人坐重量为m的飞船从1出发到n，需要走1-&gt;2-&gt;..-&gt;n-&gt;1这样的路径，从每个点起飞要消耗ai的燃油，在每个点降落要消耗bi的燃油，燃油只能从1上带，问这人要带多少燃油才能完成这个路径。 二分燃油的量，判断是否满足，或从1-&gt;n-&gt;n-1-&gt;…1逆推，上一次的燃油量是x*m/(x-1)，x为起飞or降落的消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const double eps = 1e-9;int n, m;double a[maxn], b[maxn];int ok(double fuel) &#123; double tot = fuel + m; for(int i = 1; i &lt;= n - 1; i++) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i+1]; &#125; for(int i = n; i &gt;= 2; i--) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i-1]; &#125; return tot - m &gt;= eps;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; &#125; double ret = m; for(int i = 1; i &lt; n; i++) &#123; ret = b[i] * ret / (b[i] - 1.0); ret = a[i+1] * ret / (a[i+1] - 1.0); &#125; ret = b[n] * ret / (b[n] - 1.0); ret = a[1] * ret / (a[1] - 1.0); ret -= m; if(ret &gt; 1e9) &#123; printf(\"-1\\n\"); &#125; else printf(\"%.10f\\n\", ret); &#125; return 0;&#125; D：猜一个1到m的数字x，可以询问最多60次。每次回答有可能是假的，假的情况那么会输出真答案判别的相反数（大于的时候返回1，如果假的情况就返回-1，小于同理），回答的真假情况序列p的长为n，回答按照这个序列循环返回结果。求这个数字x。 可以用数字1去试探n次（当然答案是1的时候可以直接结束程序了），把n次询问的真假情况预处理出来记下，之后就可以愉快地二分x，根据上面预处理出来的真假情况修改返回结果了。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;int p[maxn];int n, m;int query(int y) &#123; printf(\"%d\\n\", y); fflush(stdout); int t; scanf(\"%d\", &amp;t); if(t == 0 || t == 2) exit(0); return t;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;m,&amp;n)) &#123; memset(p, 0, sizeof(p)); for(int i = 0; i &lt; n; i++) &#123; int t = query(1); p[i] = (t == 1); &#125; int lo = 2, hi = m; for(int q = 0; ; q++) &#123; int mid = (lo + hi) &gt;&gt; 1; int t = query(mid); if(!p[q%n]) t = -t; if(t == 1) lo = mid + 1; else hi = mid - 1; &#125; &#125; return 0;&#125; E：n个数，每个数可以取任意次，相加后对k取模。求模的结果的个数。 统计k和每个数的gcd，答案就是k/gcd，依次取0,k/gcd,2k/gcd…就行了。过阵子尝试证明一下，相关概念有：有限域，生成元，生成多项式，循环群，裴蜀定理。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 100100;int n;LL k;LL a[maxn];bool vis[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%lld\",&amp;n,&amp;k)) &#123; memset(vis, 0, sizeof(vis)); LL x = k; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); x = __gcd(x, a[i]); &#125; printf(\"%lld\\n\", k / x); for(LL i = 0; i &lt; k; i+=x) &#123; printf(\"%lld \", i); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://vincentxwd.github.io/blog/tags/Codeforces/"}]}]}