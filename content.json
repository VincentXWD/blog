{"meta":{"title":"Kirai","subtitle":"我好菜啊 QAQ | I Good Vegetable A QAQ","description":null,"author":"Kirai","url":"https://vincentxwd.github.io/blog"},"pages":[{"title":"关于","date":"2018-07-30T05:59:54.000Z","updated":"2018-08-04T13:54:26.899Z","comments":true,"path":"about/index.html","permalink":"https://vincentxwd.github.io/blog/about/index.html","excerpt":"","text":"kirai，在读渣硕，方向是ML和CV。竞赛败犬，科研萌新。魔兽玩家，喜欢打osu! mania。 如果您在招实习，点击这里可能会多了解一点QAQ。 有问题可以邮箱联系，也可以QQ：107850580。"},{"title":"分类","date":"2018-07-29T12:57:51.000Z","updated":"2018-07-31T04:26:10.039Z","comments":true,"path":"categories/index.html","permalink":"https://vincentxwd.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2018-07-29T11:33:50.000Z","updated":"2018-07-29T11:33:50.336Z","comments":true,"path":"404/index.html","permalink":"https://vincentxwd.github.io/blog/404/index.html","excerpt":"","text":""},{"title":"search","date":"2018-07-29T11:33:36.000Z","updated":"2018-07-30T07:00:53.427Z","comments":true,"path":"search/index.html","permalink":"https://vincentxwd.github.io/blog/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-29T12:56:26.000Z","updated":"2018-07-30T07:02:56.361Z","comments":true,"path":"tags/index.html","permalink":"https://vincentxwd.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[CF1025] Codeforces Round #504 (Div.1+Div.2)","slug":"CF1025-Codeforces-Round-504-Div-1-Div-2","date":"2018-08-20T05:16:51.000Z","updated":"2018-08-20T06:37:44.766Z","comments":true,"path":"2018/08/20/CF1025-Codeforces-Round-504-Div-1-Div-2/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/20/CF1025-Codeforces-Round-504-Div-1-Div-2/","excerpt":"链接：http://codeforces.com/contest/1025 这一场大家fst得都好惨啊。","text":"链接：http://codeforces.com/contest/1025 这一场大家fst得都好惨啊。 A：水题不多解释，注意$n=1$的时候输出Yes。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;#pragma optimize(\"O3\")const int maxn = 222;int n;int vis[maxn];char s[100100];signed main() &#123; // freopen(\"in\",\"r\",stdin); while(~scanf(\"%d%s\",&amp;n,s)) &#123; if(n == 1) &#123; printf(\"Yes\\n\"); continue; &#125; memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; i++) vis[s[i]-'a']++; bool ok = 0; for(int i = 0; i &lt; 26; i++) &#123; if(vis[i] &gt; 1) &#123; ok = 1; &#125; &#125; if(ok) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; B：有$n$个数对，让你找到一个大于1的数字，使得这个数字为这个$n$对数中任意一个数的因数。 这个数一定是每一对数中某个数的因数，不妨建一个队列，把第一对中两个数的所有质因数去重后压到队里，看看队首的数是不是接下来的数对中任意一个数的因数。如果不是就出队，到最后看看有没有剩下数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;#pragma optimize(\"O3\")using LL = long long;const int maxn = 160600;int n;signed main() &#123; // freopen(\"in\",\"r\",stdin); LL a, b; queue&lt;int&gt; q; set&lt;int&gt; vis; while(~scanf(\"%d\",&amp;n)) &#123; while(!q.empty()) q.pop(); vis.clear(); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%I64d%I64d\",&amp;a,&amp;b); if(i == 1) &#123; for(int j = 2; j * j &lt;= a; j++) &#123; if(a % j == 0) &#123; q.push(j); vis.insert(j); while(a % j == 0) a /= j; &#125; &#125; if(a &gt; 1) &#123; q.push(a); vis.insert(a); &#125; for(int j = 2; j * j &lt;= b; j++) &#123; if(b % j == 0) &#123; if(vis.find(j) == vis.end()) &#123; vis.insert(j); q.push(j); &#125; while(b % j == 0) b /= j; &#125; &#125; if(b &gt; 1) &#123; if(vis.find(b) == vis.end()) &#123; vis.insert(b); q.push(b); &#125; &#125; &#125; else &#123; while(!q.empty()) &#123; if(a % q.front() == 0 || b % q.front() == 0) &#123; break; &#125; q.pop(); &#125; &#125; &#125; if(!q.empty()) &#123; printf(\"%d\\n\", q.front()); &#125; else printf(\"-1\\n\"); &#125; return 0;&#125; C：给你一个只有b和w两种字符的串s，希望让你通过一个操作获得尽可能长的bw交替的子串。这个操作是选中某一个位置切分，让两边都翻转。 考虑这个操作的本质，两头翻转以后，原本在串两端的字符接到了一起，中间的到了两端。再选一个位置也是这样，那么实际上两头是可以通过这个操作接到一起的。于是我们把整个串看成一个环，找最长的不超过字符串本身长度的bw串就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#pragma optimize(\"O3\")using LL = long long;const int maxn = 150500;int n;char s[maxn&lt;&lt;2];signed main() &#123; // freopen(\"in\",\"r\",stdin); while(~scanf(\"%s\",s)) &#123; n = strlen(s); for(int i = 0; i &lt; n; i++) &#123; s[i+n] = s[i]; &#125; int ret = 1; int t, i = 0; while(i &lt; 2 * n) &#123; if(s[i] == 'b') &#123; t = 0; while(i + 1 &lt; 2 * n &amp;&amp; s[i+1] != s[i]) &#123; t++; i++; &#125; ret = max(ret, t+1); &#125; i++; &#125; i = 0; while(i &lt; 2 * n) &#123; if(s[i] == 'w') &#123; t = 0; while(i + 1 &lt; 2 * n &amp;&amp; s[i+1] != s[i]) &#123; t++; i++; &#125; ret = max(ret, t+1); &#125; i++; &#125; printf(\"%d\\n\", min(n, ret)); &#125; return 0;&#125; D：给你n个数，问你能不能构成一棵二叉排序树，并且每2个相邻节点之间的gcd不是1。 首先想到了暴力枚举每一层的根节点，但是这样复杂度是$O(n^{logn})$的，显然不科学。 注意到一个点作为根的时候与它和它的儿子具体是谁有关系，我们考虑区间dp，维护$dp(i,j,k)$，表示$[i,j]$区间内的第$k$个数字能否做根，这个关系可以用bitset维护。 于是我们枚举长度和起止端点，特判端点作为根的时候能否成立，区间里面的数则直接枚举位置，看看这个k是否能分别做左右两棵树的根，如果能的话，直接给大区间做标记。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#pragma optimize(\"O3\")const int maxn = 707;int n, a[maxn];signed main() &#123; // freopen(\"in\",\"r\",stdin); while(~scanf(\"%d\",&amp;n)) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; bitset&lt;maxn&gt; ok[n+1]; bitset&lt;maxn&gt; dp[n+1][n+1]; for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) &#123; if(__gcd(a[i], a[j]) != 1) &#123; ok[i][j] = ok[j][i] = 1; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++) dp[i][i][i] = 1; for(int len = 2; len &lt;= n; len++) &#123; for(int i = 1; i + len - 1 &lt;= n; i++) &#123; int j = i + len - 1; if((ok[i] &amp; dp[i+1][j]).any()) &#123; dp[i][j][i] = 1; &#125; if((ok[j] &amp; dp[i][j-1]).any()) &#123; dp[i][j][j] = 1; &#125; for(int k = i + 1; k &lt; j; k++) &#123; if(dp[i][k][k] &amp;&amp; dp[k][j][k]) &#123; dp[i][j][k] = 1; &#125; &#125; &#125; &#125; if(dp[1][n]!=0) puts(\"Yes\"); else puts(\"No\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"},{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"}]},{"title":"[BZOJ4017] 小Q的无敌异或（异或, 树状数组）","slug":"BZOJ4017-小Q的无敌异或","date":"2018-08-19T09:54:32.000Z","updated":"2018-08-19T17:25:41.493Z","comments":true,"path":"2018/08/19/BZOJ4017-小Q的无敌异或/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/19/BZOJ4017-小Q的无敌异或/","excerpt":"链接：https://www.lydsy.com/JudgeOnline/problem.php?id=4017 （这是一道好题）给你n个数，分别问这n个数中任意两个区间的异或和的加和是多少、任意两个区间的和的异或和是多少。","text":"链接：https://www.lydsy.com/JudgeOnline/problem.php?id=4017 （这是一道好题）给你n个数，分别问这n个数中任意两个区间的异或和的加和是多少、任意两个区间的和的异或和是多少。 Task 1：求异或的和 针对第一问，我们首先分析出两个性质： 设$[1,i]$的异或和为$xor[i]$，那么区间$[l,r]$内数字的异或和为$xor[l-1]⨁xor[r]$。 某个在数字第k位有贡献的子区间$[l,r]$，它们的前缀异或和$xor[l]$与$xor[r]$的值一定不同。而且很显然，这个区间的贡献为$2^k$。 有上述的两个性质，我们的目标其实就是拆分数位，针对每个数位，找到整个$[1,n]$区间内有多少对前缀异或和结果不同。假设在$[1,n]$中的第$k$位数字有$x$个数该位是$1$，那么就有$n-x$个位置是$0$。这样只是找到了区间长度≥2的贡献，但是题目规定单个数字也算贡献，不妨再加上一个$x$，问题转化成在两个数字集合中分别挑选一个数字，问有多少对数字，因此第$k$位总体贡献是$x(n-x+1)2^k$。 实现就很简单，我们针对每一位$k$，求异或和的每一步时，更新这个$x$，最后算一下贡献就行了。 12345678910111213LL gao1() &#123; LL ret = 0; for(int k = 0; k &lt; 20; k++) &#123; int cur = 0, cnt = 0; for(int i = 1; i &lt;= n; i++) &#123; cur ^= (a[i] &gt;&gt; k) &amp; 1; if(cur == 1) cnt++; &#125; ret += cnt * (n - cnt + 1) % mod * (1LL &lt;&lt; k) % mod; ret %= mod; &#125; return ret;&#125; Task 2：求和的异或 考虑和第一问一样的做法，要求的答案为异或和，考虑这个和的第$k$位什么时候为$1$：当出现的在这一位为$1$时的区间$[l,r]$内数字之和为奇数个的时候贡献为$2^k$。 我们又能发现一个规律：当区间[l,r]的和的第k位是奇数时，有：$$(s[r]-s[l-1])\\ mod \\ 2^{k+1}\\ ≥\\ 2^k$$针对每一位$k$，我们可以预处理出来前i项的和$s[i]$，离散化这个$s$以后用树状数组维护每个位置$i$左右两侧是否满足上述条件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344vector&lt;LL&gt; bit;int lowbit(int x) &#123; return x &amp; (-x);&#125;void add(int x, LL v) &#123; for(int i = x; i &lt;= n; i+=lowbit(i)) &#123; bit[i] ^= v; &#125;&#125;LL sum(int x) &#123; LL ret = 0; for(int i = x; i &gt;= 1; i-=lowbit(i)) &#123; ret ^= bit[i]; &#125; return ret;&#125;LL gao2() &#123; vector&lt;LL&gt; s(n+1, 0); vector&lt;LL&gt; h(n+1, 0); LL ret = 0; for(int i = 1; i &lt;= n; i++) &#123; s[i] = s[i-1] + a[i]; &#125; auto id = [&amp;](LL cur) &#123; return lower_bound(h.begin(), h.end(), cur) - h.begin() + 1; &#125;; for(int k = 0; k &lt; 32; k++) &#123; LL tmp = 0; for(int i = 0; i &lt;= n; i++) &#123; h[i] = s[i] &amp; ((1LL &lt;&lt; (k + 1)) - 1); &#125; sort(h.begin(), h.end()); bit = vector&lt;LL&gt;(n+1, 0); for(int i = 0; i &lt;= n; i++) &#123; LL cur = s[i] &amp; ((1LL &lt;&lt; (k + 1)) - 1); add(id(cur), 1LL); tmp ^= sum(id(cur-(1LL&lt;&lt;k))) ^ sum(id(cur+(1LL&lt;&lt;k))) ^ sum(id(cur)); &#125; if(tmp == 1) ret |= (1LL &lt;&lt; k); &#125; return ret;&#125; 通过这个题，学到了要去讨论所求结果和计算过程的特点这样的思路。例如本题的两个问就是要针对区间内的异或和或答案的异或和中的每一位做讨论。 于是，遇到异或和考虑到先讨论一下每一位的贡献就对啦~ 提交的时候报了CE，emmm懒得改就这样吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#pragma optimize(\"O3\")using LL = long long;const LL mod = 998244353LL;vector&lt;int&gt; a;int n;LL gao1() &#123; LL ret = 0; for(int k = 0; k &lt; 32; k++) &#123; int cur = 0, cnt = 0; for(int i = 1; i &lt;= n; i++) &#123; cur ^= (a[i] &gt;&gt; k) &amp; 1; if(cur == 1) cnt++; &#125; ret += cnt * (n - cnt + 1) % mod * (1LL &lt;&lt; k) % mod; ret %= mod; &#125; return ret;&#125;vector&lt;LL&gt; bit;int lowbit(int x) &#123; return x &amp; (-x);&#125;void add(int x, LL v) &#123; for(int i = x; i &lt;= n; i+=lowbit(i)) &#123; bit[i] ^= v; &#125;&#125;LL sum(int x) &#123; LL ret = 0; for(int i = x; i &gt;= 1; i-=lowbit(i)) &#123; ret ^= bit[i]; &#125; return ret;&#125;LL gao2() &#123; vector&lt;LL&gt; s(n+1, 0); vector&lt;LL&gt; h(n+1, 0); LL ret = 0; for(int i = 1; i &lt;= n; i++) &#123; s[i] = s[i-1] + a[i]; &#125; auto id = [&amp;](LL cur) &#123; return lower_bound(h.begin(), h.end(), cur) - h.begin() + 1; &#125;; for(int k = 0; k &lt; 32; k++) &#123; LL tmp = 0; for(int i = 0; i &lt;= n; i++) &#123; h[i] = s[i] &amp; ((1LL &lt;&lt; (k + 1)) - 1); &#125; sort(h.begin(), h.end()); bit = vector&lt;LL&gt;(n+1, 0); for(int i = 0; i &lt;= n; i++) &#123; LL cur = s[i] &amp; ((1LL &lt;&lt; (k + 1)) - 1); add(id(cur), 1LL); tmp ^= sum(id(cur-(1LL&lt;&lt;k))) ^ sum(id(cur+(1LL&lt;&lt;k))) ^ sum(id(cur)); &#125; if(tmp == 1) ret |= (1LL &lt;&lt; k); &#125; return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; a.resize(n+1); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; printf(\"%lld %lld\\n\", gao1(), gao2()); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"BZOJ","slug":"题解/BZOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/BZOJ/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://vincentxwd.github.io/blog/tags/树状数组/"},{"name":"异或","slug":"异或","permalink":"https://vincentxwd.github.io/blog/tags/异或/"}]},{"title":"[CF1023] Codeforces Round #504(Div.1+Div.2)","slug":"CF1023-Codeforces-Round-504-Div-1-Div-2","date":"2018-08-18T03:45:42.000Z","updated":"2018-08-18T05:05:46.388Z","comments":true,"path":"2018/08/18/CF1023-Codeforces-Round-504-Div-1-Div-2/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/18/CF1023-Codeforces-Round-504-Div-1-Div-2/","excerpt":"链接：http://codeforces.com/contest/1023 我，七夕，掉分","text":"链接：http://codeforces.com/contest/1023 我，七夕，掉分 A：两个字符串，其中一个字符串里至多有个“*”表示任何字符都能匹配。问这两个字符串能不能匹配。 从左到右扫两个字符串的相同前缀和后缀，然后看看是不是存在“*”以及两头不相接。据说这题被cha得很厉害啊？ 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300100;int n, m;char s[maxn], t[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; scanf(\"%s%s\",s,t); if(strcmp(s, t) == 0) &#123; printf(\"YES\\n\"); continue; &#125; int i = 0, j = 0; int tot = 0; while(s[i] == t[j]) &#123; i++,j++;tot++; &#125; int p = n - 1, q = m - 1; while(s[p] == t[q]) &#123; p--,q--;tot++; &#125; if(i == p) &#123; if(s[i] == '*' &amp;&amp; tot &lt;= m) &#123; printf(\"YES\\n\"); &#125; else printf(\"NO\\n\"); &#125; else &#123; printf(\"NO\\n\"); &#125; &#125; return 0;&#125; B：给你两个数$n$和$k$，问你$k$有多少能用不超过$n$的两个不同的数的和来表示，忽略顺序。 设$k=x+y$，要满足$x≤n$、$y≤n$和$x≠y$。我们会发现，需要讨论$k≥2n$、$k≤n$和$n＜k＜2n$三个情况。前两个不必多说，第三个我们也是只需要统计从$\\frac{k}{2}$数到$n$有多少个整数就行，因为总有$x＜\\frac{k}{2}$和它对应。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;LL n, k;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld\",&amp;n,&amp;k)) &#123; if(k / 2 &gt;= n) &#123; printf(\"0\\n\"); continue; &#125; if(k &lt;= n) &#123; printf(\"%lld\\n\", k % 2 == 0 ? k / 2 - 1 : k / 2); &#125; else &#123; printf(\"%lld\\n\", n-k/2); &#125; &#125; return 0;&#125; C：给定长为$n$的合法括号序列，让你求一个长为$k$的合法括号子序列。 维护每一个下标为$i$的左括号对应的右括号下标$to[i]=j$，然后贪心地从左到右扫符合当前长度条件$k≥to[i]-i+1$的括号序列，每找到一堆符合条件的括号序列要更新$k$和$i$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;using pii = pair&lt;int, int&gt;;const int maxn = 200200;int n, k;int to[maxn];stack&lt;int&gt; st;char s[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; scanf(\"%s\", s); if(n == k) &#123; printf(\"%s\\n\", s); continue; &#125; while(!st.empty()) st.pop(); memset(to, 0, sizeof(to)); for(int i = 0; i &lt; n; i++) &#123; if(s[i] == '(') &#123; st.push(i); &#125; else &#123; int id = st.top(); st.pop(); to[i] = id; to[id] = i; &#125; &#125; int tot = k, i = 0; vector&lt;pii&gt; pos; while(tot) &#123; if(to[i] - i + 1 &lt;= tot &amp;&amp; to[i] - i + 1 &gt; 0) &#123; tot -= (to[i] - i + 1); pos.emplace_back(i, to[i]); i = to[i] + 1; &#125; else i++; &#125; for(int i = 0; i &lt; pos.size(); i++) &#123; for(int j = pos[i].first; j &lt;= pos[i].second; j++) &#123; printf(\"%c\", s[j]); &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; D：原本有$n$个范围在$[1,q]$的数，定义染色操作$[l_i,r_i]$表示将$[l_i,r_i]$区间内的数字变为$i$，现在给你$n$个染色后的数字作为结果，其中含有数字$0$表示这里可以是任意数字，问你$q$次操作能不能把原本的序列变成这个序列。 考虑到每次染色为一个区间，每个数字$i$仅能染色一次。那么在进行过一次染色操作后，这个区间内的数字必然不能比$i$小。 问题在于如何处理$0$，我们考虑有一个$0$在某个区间$[L,R]$内，且$a_L$与$a_R$相同，$[L,R]$中不存在除了$0$以外小于$a_L$的数字。那么我们可以将这个0置为相邻两侧数字中的任意一个，作为扩展那个数字的区间长度。 因此我们构造时只需要维护每一个数字的最右侧相同的那个数字，整个区间必然会被覆盖一次。然后用线段树维护区间最小值，存在有小于区间端点的数字时必然无法构造。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200200;int n, q;int r[maxn];int a[maxn];#define lrt rt &lt;&lt; 1#define rrt rt &lt;&lt; 1 | 1int seg[maxn&lt;&lt;2];void pushup(int rt) &#123; seg[rt] = min(seg[lrt], seg[rrt]);&#125;void build(int l, int r, int rt) &#123; if(l == r) &#123; seg[rt] = a[l]; return; &#125; int m = (l + r) &gt;&gt; 1; build(l,m,lrt); build(m+1,r,rrt); pushup(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return seg[rt]; &#125; int m = (l + r) &gt;&gt; 1; int ret = 0x7f7f7f7f; if(m &gt;= L) ret = min(ret, query(L, R, l, m, lrt)); if(m &lt; R) ret = min(ret, query(L, R, m+1, r, rrt)); return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; memset(r, 0, sizeof(r)); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;a[i]); r[a[i]] = i; &#125; if(!r[q]) &#123; if(!r[0]) &#123; printf(\"NO\\n\"); continue; &#125; else a[r[0]] = q; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(a[i] == 0) a[i] = a[i-1]; &#125; for(int i = n; i &gt;= 1; i--) &#123; if(a[i] == 0) a[i] = a[i+1]; &#125; bool ok = 1; build(1, n, 1); for(int i = 1; i &lt;= n; i++) &#123; int tmp; if(!r[a[i]]) continue; tmp = query(i, r[a[i]], 1, n, 1); if(tmp &lt; a[i]) &#123; ok = 0; break; &#125; &#125; if(ok) &#123; printf(\"YES\\n\"); for(int i = 1; i &lt;= n; i++) &#123; printf(\"%d%c\", a[i], \" \\n\"[i==n]); &#125; &#125; else printf(\"NO\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"},{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"},{"name":"线段树","slug":"线段树","permalink":"https://vincentxwd.github.io/blog/tags/线段树/"}]},{"title":"[Hackerrank] CodeKnight 1.0 A-D题解（线段树, 二分, 组合计数, 尺取）","slug":"Hackerrank-CodeKnight-1-0-A-D题解","date":"2018-08-16T13:59:42.000Z","updated":"2018-08-16T14:18:21.516Z","comments":true,"path":"2018/08/16/Hackerrank-CodeKnight-1-0-A-D题解/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/16/Hackerrank-CodeKnight-1-0-A-D题解/","excerpt":"链接：https://www.hackerrank.com/contests/codeknight-1/challenges 这些题好蛋疼啊。。。。","text":"链接：https://www.hackerrank.com/contests/codeknight-1/challenges 这些题好蛋疼啊。。。。 Magical Cards：给你一个整数$n$，问你有多少种拆分方法，将这个数拆成素数的乘积。 首先将这个数分解质因数，并记下每个素因数的个数$c[i]$以及一共有多少个素因数$tot$，问题转化成将这$tot$个素因数有多少种排列方式了。直接考虑每一类素因数$p[i]$要在$tot$个位置中占据$c[i]$个位置，每一种素因数的排放实际上是相互独立的。则位置有$C_{tot}^{p[i]}$种，剩下$tot-p[i]$个空位下一个质因数再放就行。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 10010;LL f[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); int n; vector&lt;int&gt; c; f[1] = f[0] = 1; for(int i = 2; i &lt; maxn; i++) f[i] = f[i-1] * i; while(T--) &#123; scanf(\"%d\", &amp;n); LL m = n, tot = 0; c.clear(); for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; int cnt = 0; while(n % i == 0) &#123; cnt++; n /= i; tot++; &#125; c.emplace_back(cnt); &#125; &#125; if(n &gt; 1) &#123; tot++; c.emplace_back(1); &#125; LL ret = 1; for(int i = 0; i &lt; c.size(); i++) &#123; ret = f[tot] / f[c[i]] / f[tot-c[i]] * ret; tot -= c[i]; &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125; Shubham and Subarrays：给你n个数，和一个整数k。让你求有多少个子区间的乘积为k。 考虑这样的区间问题首先想到尺取，但是仅尺取还不够。考虑k=1的情况，假如有连续的1存在（如：1 1 1 1），那么实际上有6种（$\\frac{3×(3+1)}{2}$）。特殊处理掉这个情况，剩下的再计算乘积恰好为k时，左右两个指针外部的1的贡献就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;using PLL = pair&lt;LL, LL&gt;;const int maxn = 100100;int n;LL k, x[maxn];vector&lt;PLL&gt; v;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d%lld\",&amp;n,&amp;k); v.clear(); v.emplace_back(0, -1); for(int i = 0; i &lt; n; i++) &#123; scanf(\"%lld\", &amp;x[i]); if(x[i] != 1) &#123; v.emplace_back(x[i], i); &#125; &#125; v.emplace_back(0, n); LL one = 0, ret = 0, cur = 0; for(int i = 1; i &lt; v.size(); i++) &#123; cur = v[i].second - v[i-1].second; one += (cur - 1) * cur / 2; &#125; if(k == 1) &#123; printf(\"%lld\\n\", one); continue; &#125; int l = 1, r = 1; cur = 1; while(r &lt; v.size() - 1) &#123; if(cur * v[r].first == k) &#123; cur *= v[r].first; r++; ret += (v[r].second - v[r-1].second) * (v[l].second - v[l-1].second); &#125; else if(cur * v[r].first &lt; k) &#123; cur *= v[r].first; r++; &#125; else if(cur * v[r].first &gt; k) &#123; if(l == r) l++, r++; else &#123; cur /= v[l].first; l++; &#125; &#125; &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125; Chef and Cakes：这题太水，不多说了。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int, int&gt; vis;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); int n; while(T--) &#123; scanf(\"%d\", &amp;n); vis.clear(); int x, a = -1; for(int i = 0; i &lt;n; i++) &#123; scanf(\"%d\",&amp;x); vis[x]++; &#125; for(auto x : vis) &#123; a = max(a, x.second); &#125; printf(\"%d %d\\n\", vis.size(), a); &#125; return 0;&#125; Domino’s：n个多米诺骨牌，每个骨牌的位置为$x_i$，高度为$h_i$，每个骨牌向右倒下能砸到$[x+1,x+h-1]$范围的骨牌。现在让你统计每一个骨牌从它的位置向右倒下后能砸倒多少骨牌（多米诺骨牌后面的骨牌被砸倒还会影响到后面的）。 我们给n个多米诺骨牌按$x_i$排序后发现，由于最右边的骨牌倒下的影响只有自己，即为1，于是我们考虑从右往左开始处理：设我们骨牌的结果为$dp_i$，每当处理到第$i$个骨牌时，我们单张骨牌砸中的范围为$[x_i+1,x_i+h_i-1]$，我们对再它右边的骨牌中找到能砸中骨牌最多的那张牌即可（当然这里也有递推关系）。使用线段树维护每一个骨牌的dp值，每次查询的时候首先二分$[x_i+1,x_i+h_i-1]$（即受到当前骨牌影响的骨牌）中的下标$aim$，然后在线段树上查询$[pos+1, aim]$内dp值最大的下标id$，对于每一个骨牌$i$，答案为这个骨牌右边的dp值+这个骨牌左边至$i$骨牌中的骨牌数量$id-pos-1+dp$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;using PLL = pair&lt;LL, LL&gt;;using Node = struct &#123; LL x, h, id;&#125;;const int maxn = 200100;int n;Node p[maxn];LL dp[maxn];#define lrt rt &lt;&lt; 1#define rrt rt &lt;&lt; 1 | 1LL seg[maxn&lt;&lt;4], id[maxn&lt;&lt;4];void pushup(LL rt) &#123; if(seg[lrt] &gt; seg[rrt]) &#123; seg[rt] = seg[lrt]; id[rt] = id[lrt]; &#125; else &#123; seg[rt] = seg[rrt]; id[rt] = id[rrt]; &#125;&#125;void build(LL l, LL r, LL rt) &#123; if(l == r) &#123; seg[rt] = 1; id[rt] = l; return; &#125; LL m = (l + r) &gt;&gt; 1; build(l, m, lrt); build(m+1, r, rrt); pushup(rt);&#125;void update(LL x, LL p, LL l, LL r, LL rt) &#123; if(l == r) &#123; seg[rt] = x; return; &#125; LL m = (l + r) &gt;&gt; 1; if(p &lt;= m) update(x, p, l, m, lrt); else update(x, p, m+1, r, rrt); pushup(rt);&#125;PLL query(LL L, LL R, LL l, LL r, LL rt) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return make_pair(seg[rt], id[rt]); &#125; LL m = (l + r) &gt;&gt; 1; PLL ret = make_pair(-1, -1); if(L &lt;= m) &#123; ret = max(ret, query(L, R, l, m, lrt)); &#125; if(R &gt; m) &#123; ret = max(ret, query(L, R, m+1, r, rrt)); &#125; return ret; &#125;LL gao(LL pos) &#123; LL l = pos + 1, r = n; LL hi = p[pos].x + p[pos].h - 1; LL aim = -1; while(l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if(p[m].x &lt;= hi) &#123; aim = m; l = m + 1; &#125; else r = m - 1; &#125; if(aim == -1) return 0; PLL id = query(pos+1, aim, 1, n, 1); return (id.second - pos - 1) + id.first;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); // freopen(\"out\", \"w\", stdout); int T; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].h; p[i].id = i; dp[i] = 1; &#125; sort(p+1, p+n+1, [](Node a, Node b) &#123; return a.x == b.x ? a.h &lt; b.h : a.x &lt; b.x; &#125;); build(1, n, 1); for(int i = n - 1; i &gt;= 1; i--) &#123; dp[i] += gao(i); update(dp[i], i, 1, n, 1); &#125; vector&lt;LL&gt; ret; ret.resize(n+1); for(int i = 1; i &lt;= n; i++) &#123; ret[p[i].id] = dp[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; printf(\"%lld%c\", ret[i], ' '); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Hackerrank","slug":"题解/Hackerrank","permalink":"https://vincentxwd.github.io/blog/categories/题解/Hackerrank/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"},{"name":"线段树","slug":"线段树","permalink":"https://vincentxwd.github.io/blog/tags/线段树/"},{"name":"组合","slug":"组合","permalink":"https://vincentxwd.github.io/blog/tags/组合/"},{"name":"计数","slug":"计数","permalink":"https://vincentxwd.github.io/blog/tags/计数/"},{"name":"尺取","slug":"尺取","permalink":"https://vincentxwd.github.io/blog/tags/尺取/"}]},{"title":"[HDOJ3501] Calculation 2 (容斥 or 欧拉函数)","slug":"HDOJ3501-Calculation-2-容斥-or-欧拉函数","date":"2018-08-13T15:24:19.000Z","updated":"2018-08-13T15:45:28.597Z","comments":true,"path":"2018/08/13/HDOJ3501-Calculation-2-容斥-or-欧拉函数/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/13/HDOJ3501-Calculation-2-容斥-or-欧拉函数/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=3501 求一个数n的所有小于它并且与它不互质的数的和。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=3501 求一个数n的所有小于它并且与它不互质的数的和。 打算复习一波欧拉函数的，结果这题发现可以容斥。 我们知道如果一个数$n$含有因数$x$，那么$x$的倍数都和$n$不互质，且质因数至少为$x$。 我们可以知道，对于任意小于$n$的因数$x$，对本题的贡献为$x+2x+3x+…+kx=\\frac{k(k+1)}{2}x$，其中$k$为$n$对$x$的倍数。 于是直接对$n$分解因数，再容斥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL mod = 1e9+7;LL n;LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0) &#123; x = 1; y = 0; return a; &#125; else &#123; LL ret = exgcd(b, a%b, x, y); LL tmp = x; x = y; y = tmp - a / b * y; return ret; &#125;&#125;LL inv(LL a) &#123; LL x, y; exgcd(a, mod, x, y); return (x % mod + mod) % mod;&#125;signed main() &#123; // freopen(\"in\", \"r\" ,stdin); while(~scanf(\"%lld\",&amp;n) &amp;&amp; n) &#123; LL t = n; vector&lt;LL&gt; p; for(LL i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) p.push_back(i); while(n % i == 0) n /= i; &#125; if(n &gt; 1) p.push_back(n); int nn = 1 &lt;&lt; p.size(); LL ret = 0; for(int i = 1; i &lt; nn; i++) &#123; LL tmp = 1; for(int j = 0; j &lt; p.size(); j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; tmp *= p[j]; &#125; &#125; LL cnt = t / tmp; tmp = cnt * (cnt - 1) % mod * inv(2) % mod * tmp % mod; if(__builtin_popcount(i) &amp; 1) &#123; ret += tmp; ret %= mod; &#125; else &#123; ret -= tmp; ret += mod; ret %= mod; &#125; &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125; 再来考虑欧拉函数，知道一个定理：小于$n$的数，且与$n$互质的数的和为：$$\\frac{\\phi(n)×n}{2}$$然而小于$n$的数的和为$\\frac{n(n-1)}{2}$，于是我们一减：$$\\frac{n(n-1-\\phi(n))}{2}$$ 1234567891011121314signed main() &#123; // freopen(\"in\", \"r\" ,stdin); while(~scanf(\"%lld\",&amp;n) &amp;&amp; n) &#123; LL ret = n, t = n; for(LL i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) ret = ret / i * (i-1); while(n % i == 0) n /= i; &#125; if(n &gt; 1) ret = ret / n * (n-1); LL p = t * (t - 1 - ret) / 2; cout &lt;&lt; p % mod &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"容斥","slug":"容斥","permalink":"https://vincentxwd.github.io/blog/tags/容斥/"}]},{"title":"[HDOJ6395] Sequence (反演思想，整除分块，矩阵快速幂)","slug":"HDOJ6395-Sequence-整除分块，矩阵快速幂","date":"2018-08-13T12:57:01.000Z","updated":"2018-08-13T13:03:01.936Z","comments":true,"path":"2018/08/13/HDOJ6395-Sequence-整除分块，矩阵快速幂/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/13/HDOJ6395-Sequence-整除分块，矩阵快速幂/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6395 就算个式子。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6395 就算个式子。 这题关键在于如何处理后面的下取整分式，会发现如何构造这个矩阵都不太好弄这个式子。知道一点莫比乌斯反演，考虑到了按照整除结果对取整式进行分块，每一块单独跑块长次矩阵快速幂，然后累计到结果上就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL maxn = 5;const LL mod = 1e9+7;typedef struct Matrix &#123; LL m[maxn][maxn]; LL r; LL c; Matrix()&#123; r = c = 0; memset(m, 0, sizeof(m)); &#125; &#125; Matrix;Matrix mul(Matrix m1, Matrix m2) &#123; Matrix ret = Matrix(); ret.r = m1.r; ret.c = m2.c; for(LL i = 1; i &lt;= m1.r; i++) &#123; for(LL j = 1; j &lt;= m2.r; j++) &#123; for(LL k = 1; k &lt;= m2.c; k++) &#123; if(m2.m[j][k] == 0) continue; ret.m[i][k] = (ret.m[i][k] + (m1.m[i][j] * m2.m[j][k]) % mod) % mod; &#125; &#125; &#125; return ret;&#125;Matrix quickmul(Matrix m, LL n) &#123; Matrix ret = Matrix(); for(LL i = 1; i &lt;= m.r; i++) ret.m[i][i] = 1; ret.r = m.r; ret.c = m.c; while(n) &#123; if(n &amp; 1) ret = mul(m, ret); m = mul(m, m); n &gt;&gt;= 1; &#125; return ret;&#125;LL a, b, c, d, p, n;signed main() &#123; // freopen(\"in\", \"r\", stdin); LL T; scanf(\"%lld\", &amp;T); Matrix mat, ret; while(T--) &#123; scanf(\"%lld%lld%lld%lld%lld%lld\",&amp;a,&amp;b,&amp;c,&amp;d,&amp;p,&amp;n); mat.r = mat.c = 3; ret.r = 3; ret.c = 1; mat.m[1][1] = d, mat.m[1][2] = c; mat.m[2][1] = 1; mat.m[2][2] = 0; mat.m[2][3] = 0; mat.m[3][1] = 0; mat.m[3][2] = 0; mat.m[3][3] = 1; ret.m[1][1] = b; ret.m[2][1] = a; ret.m[3][1] = 1; if(n == 1) &#123; printf(\"%lld\\n\", a); continue; &#125; if(n &lt; p) &#123; for(LL i = 3; i &lt;= n; i=p/(p/i)+1) &#123; mat.m[1][1] = d, mat.m[1][2] = c; mat.m[2][1] = 1; mat.m[2][2] = 0; mat.m[2][3] = 0; mat.m[3][1] = 0; mat.m[3][2] = 0; mat.m[3][3] = 1; mat.m[1][3] = (p / i); if(n &lt;= p / (p/i)) mat = quickmul(mat, n-i+1); else mat = quickmul(mat, p/(p/i)+1-i); ret = mul(mat, ret); &#125; printf(\"%lld\\n\", ret.m[1][1]); continue; &#125; for(LL i = 3; i &lt;= p; i=p/(p/i)+1) &#123; mat.m[1][1] = d, mat.m[1][2] = c; mat.m[2][1] = 1; mat.m[2][2] = 0; mat.m[2][3] = 0; mat.m[3][1] = 0; mat.m[3][2] = 0; mat.m[3][3] = 1; mat.m[1][3] = (p / i); mat = quickmul(mat, p/(p/i)+1-i); ret = mul(mat, ret); &#125; mat.m[1][1] = d, mat.m[1][2] = c; mat.m[2][1] = 1; mat.m[2][2] = 0; mat.m[2][3] = 0; mat.m[3][1] = 0; mat.m[3][2] = 0; mat.m[3][3] = 1; mat.m[1][3] = 0LL; mat = quickmul(mat, n-max(p, 2LL)); ret = mul(mat, ret); printf(\"%lld\\n\", ret.m[1][1]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://vincentxwd.github.io/blog/tags/矩阵快速幂/"},{"name":"分块","slug":"分块","permalink":"https://vincentxwd.github.io/blog/tags/分块/"}]},{"title":"[HDOJ6386] Age of Moyu (最短路)","slug":"HDOJ6386-Age-of-Moyu-最短路","date":"2018-08-13T12:56:35.000Z","updated":"2018-08-13T13:00:20.975Z","comments":true,"path":"2018/08/13/HDOJ6386-Age-of-Moyu-最短路/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/13/HDOJ6386-Age-of-Moyu-最短路/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6386 意思就是地铁换乘，问你怎么坐，换乘次数最少","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6386 意思就是地铁换乘，问你怎么坐，换乘次数最少 这题数据水了，我的代码放过去去了。正解应该是维护到点的每个最短的距离的线路，然后更新的时候从这个线路中去找有没有存在的。我这里只是维护了最短路的上一个线路（看来是没有二条以上路径相同但是线路不同的数据），最后正着倒着各跑一次dijkstra取min的。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;typedef tuple&lt;LL, LL, LL&gt; TP;typedef struct Edge &#123; LL v, w, next;&#125;Edge;const LL maxn = 100100;const LL maxm = 2001000;const LL inf = 0x7f7f7f7f;LL n, m, ee;LL d[maxn];LL head[maxn];Edge e[maxm];priority_queue&lt;TP, vector&lt;TP&gt;, greater&lt;TP&gt;&gt; pq;void init() &#123; ee = 0; memset(head, -1, sizeof(head));&#125;void adde(LL u, LL v, LL w) &#123; e[ee].v = v; e[ee].w = w; e[ee].next = head[u]; head[u] = ee++; e[ee].v = u; e[ee].w = w; e[ee].next = head[v]; head[v] = ee++;&#125;LL dijkstra(LL s, LL t) &#123; memset(d, 0x7f, sizeof(d)); d[s] = 0; LL pre_cost, pre_id, from; pq.push(TP(0, -1, s)); while(!pq.empty()) &#123; tie(pre_cost, pre_id, from) = pq.top(); pq.pop(); if(d[from] &lt; pre_cost) continue; for(LL i = head[from]; ~i; i=e[i].next) &#123; LL v = e[i].v, w = e[i].w; LL cost, cur_id; if(w == pre_id) &#123; cost = 0; cur_id = w; &#125; else &#123; cost = 1; cur_id = w; &#125; if(cost + d[from] &lt; d[v]) &#123; d[v] = cost + d[from]; pq.push(TP(d[v], cur_id, v)); &#125; &#125; &#125; return d[t];&#125;LL find(LL x) &#123; return x == d[x] ? x : d[x] = find(d[x]);&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); LL u, v, w; while(~scanf(\"%I64d%I64d\",&amp;n,&amp;m)) &#123; init(); for(LL i = 1; i &lt;= n; i++)&#123; d[i] = i; &#125; for(LL i = 0; i &lt; m; i++) &#123; scanf(\"%I64d%I64d%I64d\",&amp;u,&amp;v,&amp;w); d[find(u)] = find(v); adde(u, v, w); &#125; if(find(1) != find(n)) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%I64d\\n\", min(dijkstra(n, 1), dijkstra(1, n))); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://vincentxwd.github.io/blog/tags/最短路/"}]},{"title":"2018百度之星-初赛（B）ADF题解","slug":"2018百度之星-初赛（B）ADF题解","date":"2018-08-12T13:11:30.000Z","updated":"2018-08-12T13:20:01.675Z","comments":true,"path":"2018/08/12/2018百度之星-初赛（B）ADF题解/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/12/2018百度之星-初赛（B）ADF题解/","excerpt":"链接：http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826 只会签到。。。","text":"链接：http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826 只会签到。。。 A： 因为无限添加，考虑先把另外一些树加到这个点上，再把其他子树的叶子加到某一个点上。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200200;int n, m, k;int in[maxn];int pre[maxn];int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]); &#125;int unite(int x, int y) &#123; pre[find(x)] = find(y); &#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T, u, v; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); memset(in, 0, sizeof(in)); for(int i = 0; i &lt; n; i++) pre[i] = i; for(int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d\",&amp;u,&amp;v); in[u]++, in[v]++; &#125; int ret = 0; for(int i = 0; i &lt; n; i++) &#123; ret = max(ret, in[i]+n-in[i]-1-max(0, m-in[i]-k)); &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125; D：这题直接二分答案，即最小的那个数字。然后按照这个数字来划分是加还是减，保证加的次数的2倍比减的次数多就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const LL maxn = 300200;LL n;LL x[maxn];LL gao(LL mid) &#123; LL a = 0, b = 0; for(int i = 1; i &lt;= n; i++) &#123; if(x[i] &gt; mid+1) &#123; b += (x[i] - mid) / 2; &#125; else a += max(0LL, mid-x[i]); &#125; return b &gt;= a;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); LL T; scanf(\"%I64d\", &amp;T); while(T--) &#123; scanf(\"%I64d\", &amp;n); for(LL i = 1; i &lt;= n; i++) &#123; scanf(\"%I64d\", &amp;x[i]); &#125; sort(x+1, x+n+1); LL lo = 0, hi = 1E9; LL ret = 0; while(lo &lt;= hi) &#123; LL mid = (lo + hi) &gt;&gt; 1; if(gao(mid)) &#123; lo = mid + 1; ret = mid; &#125; else &#123; hi = mid - 1; &#125; &#125; printf(\"%I64d\\n\", ret); &#125; return 0;&#125; F：因为$x_i$和$y_i$不会存在重复的，那么直接垂直接到最近的边上就行。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;LL mx, my, q, x, y;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; mx &gt;&gt; my &gt;&gt; q; LL ret = 0; while(q--) &#123; cin &gt;&gt; x &gt;&gt; y; LL tmp = x &lt; mx - x ? x : mx - x; if(x &lt; mx - x) tmp = x; else tmp = mx - x; if(tmp &gt;= y) tmp = y; if(tmp &gt;= my - y) tmp = my - y; ret += tmp; &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"[CF1020A-C] Codeforces Round #503 (Div.2)","slug":"CF1020A-C-Codeforces-Round-503-Div-2","date":"2018-08-12T05:15:17.000Z","updated":"2018-08-12T05:25:18.404Z","comments":true,"path":"2018/08/12/CF1020A-C-Codeforces-Round-503-Div-2/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/12/CF1020A-C-Codeforces-Round-503-Div-2/","excerpt":"链接：http://codeforces.com/contest/1020 上分啦","text":"链接：http://codeforces.com/contest/1020 上分啦 A：n个楼每个楼h层，在每栋楼的$[a,b]$层上都有一个横向的通道，可以从一个楼去任意楼。现在给你两个位置，问最少要走多少步。 对两个位置和通道区间进行讨论，然后抠一下就行了。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;LL n, h, a, b, k;signed main() &#123; // freopen(\"in\", \"r\", stdin); LL ta, fa, tb, fb; while(cin&gt;&gt;n&gt;&gt;h&gt;&gt;a&gt;&gt;b&gt;&gt;k) &#123; while(k--) &#123; cin&gt;&gt;ta&gt;&gt;fa&gt;&gt;tb&gt;&gt;fb; LL ret = (LL)abs(ta - tb); if(ta == tb) &#123; ret += (LL)abs(fa - fb); &#125; else &#123; if(fa &gt; b &amp;&amp; fb &gt; b) &#123; ret += (fa + fb - 2LL * b); &#125; else if(fa &lt; a &amp;&amp; fb &lt; a) &#123; ret += (2LL * a - fa - fb); &#125; else ret += (LL)abs(fa - fb); &#125; printf(\"%lld\\n\", ret); &#125; &#125; return 0;&#125; B：意思就是让你从每个人出发找第一个遍历2次的点。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;int n, p[maxn];int vis[maxn];void dfs(int u) &#123; if(vis[u]) &#123; printf(\"%d \", u); return; &#125; vis[u] = 1; dfs(p[u]);&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\", &amp;n)) &#123; memset(p ,0, sizeof(p)); int u; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;u); p[i] = u; &#125; for(int i = 1; i &lt;= n; i++) &#123; memset(vis, 0, sizeof(vis)); dfs(i); &#125; printf(\"\\n\"); &#125; return 0;&#125; C：n个人要给m个政党投票，每个人都有自己的投票目标以及花钱收买他的代价。现在希望让1号政党的票数超过其他所有政党的票数，问你至少要花多少钱。 考虑贪心地选花费最少的，但是直接这样选相当于确定了收买人数，实际上可以买某一个政党的一些票就可以减少收买人数。于是我们考虑枚举1号政党的目标票数，超过该票数的政党则购买所有最少价格的差票，如果还不足我们的目标票数则从剩下的票里选最便宜的买。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 3030;int n, m, W;vector&lt;int&gt; f[maxn];vector&lt;int&gt; tmp;int p[maxn], w[maxn];LL gao(int vote) &#123; LL ret = 0; tmp.clear(); int need = vote - W; for(int i = 2; i &lt;= m; i++) &#123; int id = 0; if(f[i].size() &gt;= vote) &#123; id = f[i].size() - vote + 1; &#125; if(id &gt; need) return 1E18; need -= id; for(int j = 0; j &lt; id; j++) &#123; ret += f[i][j]; &#125; for(int j = id; j &lt; f[i].size(); j++) &#123; tmp.push_back(f[i][j]); &#125; &#125; sort(tmp.begin(), tmp.end()); for(int i = 0; i &lt; need; i++) &#123; ret += tmp[i]; &#125; return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; i++) f[i].clear(); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d%d\",&amp;p[i],&amp;w[i]); f[p[i]].push_back(w[i]); &#125; for(int i = 1; i &lt;= m; i++) &#123; sort(f[i].begin(), f[i].end()); &#125; LL ret = 1E18; W = f[1].size(); for(int i = W; i &lt;= n; i++) &#123; ret = min(ret, gao(i)); &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"},{"name":"dfs","slug":"dfs","permalink":"https://vincentxwd.github.io/blog/tags/dfs/"}]},{"title":"[2018百度之星] 初赛（A）A-C题解","slug":"2018百度之星-初赛（A）AA-C题解","date":"2018-08-11T11:48:32.000Z","updated":"2018-08-11T12:10:02.046Z","comments":true,"path":"2018/08/11/2018百度之星-初赛（A）AA-C题解/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/11/2018百度之星-初赛（A）AA-C题解/","excerpt":"链接：http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825 这场出的三题，有两道和标算不太一样啊。。。其中一道题还是因为数据弱暴力过的，感觉这样下去不太行啊。。。","text":"链接：http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825 这场出的三题，有两道和标算不太一样啊。。。其中一道题还是因为数据弱暴力过的，感觉这样下去不太行啊。。。 A：直接按照长短排序，从大到小连续取3根，看看能不能构成三角形。取最大的三根就行。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1100;int n, a[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\", &amp;n)) &#123; for(int i = 0; i &lt; n; i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; sort(a, a+n); int ret = 0; int ok = 0; for(int i = n - 1; i &gt; 1; i--) &#123; if(a[i]&lt;a[i-1]+a[i-2]) &#123; ok = 1; ret = a[i]+a[i-1]+a[i-2]; break; &#125; &#125; if(!ok) printf(\"-1\\n\"); else printf(\"%d\\n\", ret); &#125; return 0;&#125; B：这里直接用deque或者list暴力就行，其实应该手写一个list，然后接头接尾直接翻转两个指针。（其实我想到了，但是写不来。码力太差了啊。。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150100;int n, q;vector&lt;deque&lt;int&gt;&gt; l;inline bool scan_d(int &amp;num) &#123; char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!='-'&amp;&amp;(in&lt;'0'||in&gt;'9')) in=getchar(); if(in=='-')&#123; IsN=true;num=0;&#125; else num=in-'0'; while(in=getchar(),in&gt;='0'&amp;&amp;in&lt;='9')&#123; num*=10,num+=in-'0'; &#125; if(IsN) num=-num; return true;&#125;signed main() &#123; freopen(\"in\", \"r\", stdin); int u, v, w, val; while(scan_d(n)) &#123; l.resize(n+1); scan_d(q); for(int i = 1; i &lt;= n; i++) l[i].clear(); int cmd; while(q--) &#123; scan_d(cmd); if(cmd == 1) &#123; scan_d(u); scan_d(w); scan_d(val); if(w == 0) l[u].emplace_front(val); else l[u].emplace_back(val); &#125; if(cmd == 2) &#123; scan_d(u); scan_d(w); if(l[u].size() == 0) &#123; printf(\"-1\\n\"); continue; &#125; if(w == 0) &#123; printf(\"%d\\n\", l[u].front()); l[u].pop_front(); &#125; else &#123; printf(\"%d\\n\", l[u].back()); l[u].pop_back(); &#125; &#125; if(cmd == 3) &#123; scan_d(u); scan_d(v); scan_d(w); if(w == 0) &#123; while(!l[v].empty()) &#123; l[u].emplace_back(l[v].front()); l[v].pop_front(); &#125; &#125; else &#123; while(!l[v].empty()) &#123; l[u].emplace_back(l[v].back()); l[v].pop_back(); &#125; &#125; &#125; &#125; &#125; return 0;&#125; C：（一道比较简单的签到题），这题我在第17分钟的时候就提交了DP做法，就是先把1串拆出来，两头的花费为1，中间的花费为2，然后做背包容量为k+1的01背包，一开始想的是最左花费为0，后来觉得不太对，有可能拆分后原先最左不在最左了，于是分了两种情况讨论了一下。折腾了2h才步入正轨。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10100;int n, k;char s[maxn];vector&lt;pair&lt;int, int&gt;&gt; seg;int f[maxn], L, R;int gao2() &#123; seg.clear(); int i = 0; while(i &lt; n) &#123; if(s[i] == '1') &#123; int j = i, tot = 0; while(j &lt; n &amp;&amp; s[j] == '1') &#123; tot++, j++; &#125; if(i == 0) seg.push_back(make_pair(tot, 1)); else if(j == n) seg.push_back(make_pair(tot, 1)); else seg.push_back(make_pair(tot, 2)); i = j; &#125; else i++; &#125; if(k == 1) &#123; if(s[0] == '1') &#123; return seg[0].first; &#125; else return 0; &#125; memset(f, 0, sizeof(f)); for(int i = 0; i &lt; seg.size(); i++) &#123; for(int j = k; j &gt;= seg[i].second; j--) &#123; f[j] = max(f[j], f[j-seg[i].second]+seg[i].first); &#125; &#125; return f[k];&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; scanf(\"%s\", s); k++; printf(\"%d\\n\", gao2()); &#125; return 0;&#125; 赛后感觉应该把B C D按照正解做一下。。","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"},{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[总结] 关于01背包和完全背包以及优化","slug":"总结-关于01背包和完全背包","date":"2018-08-10T17:22:48.000Z","updated":"2018-08-10T18:02:04.132Z","comments":true,"path":"2018/08/11/总结-关于01背包和完全背包/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/11/总结-关于01背包和完全背包/","excerpt":"今天晚上又被问起01背包和完全背包的遍历顺序了，我决定写一篇博文，这样再有人问我就可以直接把这篇文章发给他了。 我要不要先以我的方式来介绍一下这两个问题？首先我们知道01背包和完全背包的状态转移方程： 01背包：$f(i,j)=max{f(i-1,j), f(i-1,j-w_i)+v_i}$ 完全背包：$f(i,j)=max{f(i-1,j),f(i-1,j-kw_i)+kv_i}$ 简单解释一下，以01背包为例，我们定义$f(i,j)$为扫到第$i$个物品为止，背包容量为$j$时的最大价值。我们依次从第一个物品开始，决定要不要往这个背包里放，如果放的话，我们一定会从另一个状态转移过来，这个状态即扫到上一个物品、同时容量为$j-w_i$时的状态，为什么不是比$j-w_i$更小的一个状态？因为这个方程满足最优子结构：保证$f(i-1,j-w_i)$一定由上一个最优状态转移来，那么这个状态必然是最优的。完全背包也是如此，只不过朴素的做法需要多枚举一维第$i$个物品放的个数。","text":"今天晚上又被问起01背包和完全背包的遍历顺序了，我决定写一篇博文，这样再有人问我就可以直接把这篇文章发给他了。 我要不要先以我的方式来介绍一下这两个问题？首先我们知道01背包和完全背包的状态转移方程： 01背包：$f(i,j)=max{f(i-1,j), f(i-1,j-w_i)+v_i}$ 完全背包：$f(i,j)=max{f(i-1,j),f(i-1,j-kw_i)+kv_i}$ 简单解释一下，以01背包为例，我们定义$f(i,j)$为扫到第$i$个物品为止，背包容量为$j$时的最大价值。我们依次从第一个物品开始，决定要不要往这个背包里放，如果放的话，我们一定会从另一个状态转移过来，这个状态即扫到上一个物品、同时容量为$j-w_i$时的状态，为什么不是比$j-w_i$更小的一个状态？因为这个方程满足最优子结构：保证$f(i-1,j-w_i)$一定由上一个最优状态转移来，那么这个状态必然是最优的。完全背包也是如此，只不过朴素的做法需要多枚举一维第$i$个物品放的个数。 我们回到最开始的问题：01背包和完全背包的遍历顺序为什么会不一样？究竟有什么关系？ 在我初学背包问题的时候也想到了这个问题，但是很久之后才去想着弄明白这件事。一般提出这个问题的是已经了解了这两种背包问题并且知道了他们的优化算法的同学。能提出这个问题也说明实际上并没有真正理解这两个状态转移的内涵（以及没认真看背包九讲2333）。 首先介绍一下01背包的优化，针对01背包的时间复杂度是无法再优化的了，但是朴素地开二维数组是冗余的。有人发现了这个问题，并且进一步发现了01背包的更新规律：在更新$i,j$时，并不会用到比$j$大的位置，即$f(i-1,k), k&gt;j$。这很显而易见，因为物品的重量（花费）是大于等于0的，因此$j-w_i≥j$是一定成立的。所以我们才会有那个喜闻乐见的一位数组优化，只不过内层的更新顺序是从背包容量到物品重量（花费）的递减遍历顺序，这样能保证我们的递推是由扫到上一个物品时留下的数组中更新过来的，我贴一下喜闻乐见的代码： 12345for(int i = 1; i &lt;= n; i++) &#123; for(int j = m; j &gt;= w[i]; j--) &#123; dp[j] = max(dp[j], dp[j-w[i]]+v[i]); &#125;&#125; 如果觉得还不够清楚，那我贴一个二维的、滚动数组形式的来帮你理解： 123456789for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= W; j++) &#123; if(j &lt; w[i]) &#123; f[i][j] = f[i-1][j]; continue; &#125; f[i][j] = max(f[i][j], f[i-1][j-w[i]]+v[i]); &#125;&#125; 123456789for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= W; j++) &#123; if(j &lt; w[i]) &#123; f[i][j] = f[i-1][j]; continue; &#125; f[i][j] = max(f[i][j], f[i-1][j-w[i]]+v[i]); &#125;&#125; 我们还会发现，一位数组优化后的代码更简洁，因为不需要转移$j&lt;w_i$时的状态（一位数组里，不转移就直接保存在原位了）。 这就是为什么一位数组优化的01背包内层循环遍历顺序为什么是背包容量到物品重量的原因。 再看一下完全背包，我们朴素的完全背包更新是这样的： 1234567891011for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= W; j++) &#123; if(j &lt; w[i]) &#123; f[i][j] = f[i-1][j]; continue; &#125; for(int k = 0; k * w[i] &lt;= j; k++) &#123; f[i][j] = max(f[i][j], f[i-1][j-k*w[i]]+k*v[i]); &#125; &#125;&#125; 多了一层，遍历物品件数，复杂度变高。 背包九讲里将完全背包转化为01背包来做，我们记得刚刚讨论过的01背包的一位数组优化，为了防止把扫到上一个物品的状态用扫到当前物品的状态更新掉，我们内层循环倒过来更新。但是反过来会发生什么呢？反过来的话，当我们更新$f(j)$的时候，会从$f(j-w_i)$更新过来，但此时$f(j-w_i)$或许已经包括了当前这个物品，那么$f(j)$再被此状态更新的话，实际上就相当于包括了两个物品$i$，这也是我们希望的，因为完全背包不限制每种物品数量，这也是这个优化成立的原因。贴份代码： 12345for(int i = 1; i &lt;= n; i++) &#123; for(int j = w[i]; j &lt;= W; j++) &#123; f[j] = max(f[j], f[j-w[i]]+v[i]); &#125;&#125;","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://vincentxwd.github.io/blog/categories/算法总结/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"},{"name":"总结","slug":"总结","permalink":"https://vincentxwd.github.io/blog/tags/总结/"}]},{"title":"2018牛客多校07 C Bit Compression (DP)","slug":"2018牛客多校07-C-Bit-Compression-DP","date":"2018-08-10T08:04:38.000Z","updated":"2018-08-10T08:08:40.854Z","comments":true,"path":"2018/08/10/2018牛客多校07-C-Bit-Compression-DP/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/10/2018牛客多校07-C-Bit-Compression-DP/","excerpt":"链接：https://www.nowcoder.com/acm/contest/145/C 一个长度为$2^n$的01串，每次允许相邻两个数字进行与、或、异或操作，最终希望结果是1，问有多少种不同的操作路径。","text":"链接：https://www.nowcoder.com/acm/contest/145/C 一个长度为$2^n$的01串，每次允许相邻两个数字进行与、或、异或操作，最终希望结果是1，问有多少种不同的操作路径。 $f(i,j)$表示01串从$2^n$开始，扫到长度为$2^i$时，01串变为j时的路径数，用一个map来记录状态，然后暴力dp转移到下一层就行。整体复杂度是$O(2^nn)$，可以过。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300200;int n;char s[maxn];map&lt;string,int&gt; f[22];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; scanf(\"%s\", s); for(int i = 0; i &lt; 22; i++) f[i].clear(); string tmp; int tot; f[n][s] = 1; map&lt;string,int&gt;::iterator it; string a, b, c; for(int i = n; i &gt;= 1; i--) &#123; for(it = f[i].begin(); it != f[i].end(); it++) &#123; tmp = it-&gt;first, tot = it-&gt;second; int nn = (1 &lt;&lt; i); a = b = c = \"\"; for(int j = 0; j &lt; nn; j+=2) &#123; a += ((tmp[j]-'0') &amp; (tmp[j+1]-'0')) + '0'; b += ((tmp[j]-'0') | (tmp[j+1]-'0')) + '0'; c += ((tmp[j]-'0') ^ (tmp[j+1]-'0')) + '0'; &#125; f[i-1][a] += tot; f[i-1][b] += tot; f[i-1][c] += tot; &#125; &#125; printf(\"%d\\n\", f[0][\"1\"]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[Codeforces348D] Turtles (DP, LGV引理)","slug":"Codeforces348D-Turtles-LiDP-LGV引理","date":"2018-08-09T17:57:32.000Z","updated":"2018-08-09T18:05:16.583Z","comments":true,"path":"2018/08/10/Codeforces348D-Turtles-LiDP-LGV引理/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/10/Codeforces348D-Turtles-LiDP-LGV引理/","excerpt":"链接：http://codeforces.com/contest/348/problem/D 两只乌龟在棋盘上从(1,1)出发到(n,m)，其中有的地方有障碍物，两只乌龟希望找到有多少对路径，使得他们到(n,m)的路上不相交。","text":"链接：http://codeforces.com/contest/348/problem/D 两只乌龟在棋盘上从(1,1)出发到(n,m)，其中有的地方有障碍物，两只乌龟希望找到有多少对路径，使得他们到(n,m)的路上不相交。 如果我没有做牛客多校，我也不会知道这个冷艳的Lindstrom-Gessel-Viennot引理。今天翻笔记看到了，还记得CF上有一道考这个的，于是来除草。 这东西出题很单一，就是用来计算n对起止点不相交路径组合数的，出题也挺单一，其中的一个trick可能是在拆点这方面，给出公式： 其中$e(a_i,b_j)$表示从起点$a_i$到终点$b_j$的路径数，M的行列式的值就是我们要求的不相交路径的组合数了。 关于拆点，一般都是移动到起点附近步长为1的位置，终点也是，具体我不太明白，希望有朝一日能证明出来：) 这题的DP方程就很简单了，看代码吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 3030;const LL mod = 1E9+7;int n, m;char s[maxn][maxn];LL f[maxn][maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", s[i]+1); &#125; memset(f, 0, sizeof(f)); if(s[1][2] == '#' || s[2][1] == '#') &#123; printf(\"0\\n\"); continue; &#125; LL a, b, c, d; f[1][2] = (s[1][2] != '#'); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 2; j &lt;= m; j++) &#123; if(s[i][j] == '#') continue; f[i][j] += (f[i-1][j] + f[i][j-1]) % mod; f[i][j] %= mod; &#125; &#125; a = f[n-1][m], b = f[n][m-1]; memset(f, 0, sizeof(f)); f[2][1] = (s[2][1] != '#'); for(int i = 2; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(s[i][j] == '#') continue; f[i][j] += (f[i-1][j] + f[i][j-1]) % mod; f[i][j] %= mod; &#125; &#125; c = f[n-1][m], d = f[n][m-1]; LL ret = ((a * d) % mod - (b * c) % mod + mod) % mod; printf(\"%lld\\n\", ret); &#125; return 0;&#125; 哈，除草真开心啊！","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://vincentxwd.github.io/blog/tags/组合数学/"}]},{"title":"[Codeforces1017E] The Supersonic Rocket (凸包, KMP)","slug":"Codeforces1017E-The-Supersonic-Rocket-凸包-KMP","date":"2018-08-09T14:50:12.000Z","updated":"2018-08-09T14:52:39.164Z","comments":true,"path":"2018/08/09/Codeforces1017E-The-Supersonic-Rocket-凸包-KMP/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/09/Codeforces1017E-The-Supersonic-Rocket-凸包-KMP/","excerpt":"链接：http://codeforces.com/contest/1017/problem/E 给你两组点，问你这两组点的凸包是不是同构的。","text":"链接：http://codeforces.com/contest/1017/problem/E 给你两组点，问你这两组点的凸包是不是同构的。 先分别跑出两组点的凸包，判断一下点数是否相等，然后依次按照凸包的长度和拐点的角度记录下数列，然后可以用最小表示法都调成最小表示，或者对其中一个数列扩大两倍作匹配串，另一个作模式串跑KMP。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const LL maxn = 1500500;typedef struct Point &#123; LL x, y; &#125;Point;Point point[maxn];LL st[maxn], top;LL cross(Point p0, Point p1, Point p2) &#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x);&#125;LL dis(Point p1, Point p2) &#123; return (p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y); &#125;bool cmp(Point p1, Point p2) &#123; LL tmp = cross(point[0], p1, p2); if(tmp &gt; 0) return 1; if(tmp == 0) return dis(point[0], p1) &lt; dis(point[0], p2); return 0;&#125;void graham(LL n, vector&lt;Point&gt; &amp;ret) &#123; ret.clear(); for(LL i = 0; i &lt; n; i++) &#123; if(point[0].y &gt;= point[i].y) &#123; if(point[0].y == point[i].y) &#123; if(point[0].x &gt; point[i].x) swap(point[i], point[i]); &#125; else swap(point[0], point[i]); &#125; &#125; sort(point+1, point+n, cmp); top = 0; st[top++] = 0, st[top++] = 1; for(LL i = 0; i &lt; n; i++) &#123; while(top-2 &gt;= 0 &amp;&amp; cross(point[st[top-2]], point[st[top-1]], point[i]) &lt;= 0) --top; st[top++] = i; &#125; for(LL i = 0; i &lt; top; i++) ret.emplace_back(point[st[i]]);&#125;Point a[maxn], b[maxn];vector&lt;Point&gt; conv1, conv2;LL n, m;LL na, nb;LL x[maxn];LL y[maxn];LL pre[maxn];void getpre(LL *y, LL *pre) &#123; LL j, k; memset(pre, -1, sizeof(-1)); pre[0] = -1; j = 0; k = -1; while(j &lt; nb) &#123; if(k == -1 || y[j] == y[k]) &#123; j++; k++; if(y[j] != y[k]) pre[j] = k; else pre[j] = pre[k]; &#125; else k = pre[k]; &#125;&#125;LL kmp() &#123; LL ans = 0; LL i = 0; LL j = 0; getpre(y, pre); while(i &lt; na) &#123; if(j == -1 || x[i] == y[j]) &#123; i++; j++; &#125; else j = pre[j]; if(j == nb) ans++; &#125; return ans;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld\",&amp;n,&amp;m)) &#123; memset(x, 0, sizeof(x)); memset(y, 0, sizeof(y)); for(LL i = 0; i &lt; n; i++) scanf(\"%lld%lld\",&amp;a[i].x,&amp;a[i].y); for(LL i = 0; i &lt; m; i++) scanf(\"%lld%lld\",&amp;b[i].x,&amp;b[i].y); conv1.clear(); conv2.clear(); for(LL i = 0; i &lt; n; i++) point[i] = a[i]; graham(n, conv1); for(LL i = 0; i &lt; m; i++) point[i] = b[i]; graham(m, conv2); if(conv1.size() != conv2.size()) printf(\"NO\\n\"); else &#123; na = conv1.size() * 6, nb = conv2.size() * 3; for(LL i = 0; i &lt; conv1.size(); i++) &#123; x[i*3] = dis(conv1[i],conv1[(i+1)%conv1.size()]); x[i*3+1] = cross(conv1[(i+1)%conv1.size()],conv1[i],conv1[(i+2)%conv1.size()]); x[i*3+2] = dis(conv1[(i+1)%conv1.size()],conv1[(i+2)%conv1.size()]); // cout &lt;&lt; x[i*3]&lt;&lt;\" \"&lt;&lt;x[i*3+1]&lt;&lt;\" \"&lt;&lt;x[i*3+2]&lt;&lt;\" \"; &#125; for(LL i = 0; i &lt; conv1.size(); i++) &#123; x[i*3+na/2] = x[i*3]; x[i*3+1+na/2] = x[i*3+1]; x[i*3+2+na/2] = x[i*3+2]; // cout &lt;&lt; x[i*3+na/2]&lt;&lt;\" \"&lt;&lt;x[i*3+1+na/2]&lt;&lt;\" \"&lt;&lt;x[i*3+2+na/2]&lt;&lt;\" \"; &#125; // cout&lt;&lt;endl; for(LL i = 0; i &lt; conv2.size(); i++) &#123; y[i*3] = dis(conv2[i],conv2[(i+1)%conv2.size()]); y[i*3+1] = cross(conv2[(i+1)%conv2.size()],conv2[i],conv2[(i+2)%conv2.size()]); y[i*3+2] = dis(conv2[(i+1)%conv2.size()],conv2[(i+2)%conv2.size()]); // cout &lt;&lt; y[i*3]&lt;&lt;\" \"&lt;&lt;y[i*3+1]&lt;&lt;\" \"&lt;&lt;y[i*3+2]&lt;&lt;\" \"; &#125; // cout&lt;&lt;endl; LL ret = kmp(); if(ret) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://vincentxwd.github.io/blog/tags/计算几何/"},{"name":"凸包","slug":"凸包","permalink":"https://vincentxwd.github.io/blog/tags/凸包/"},{"name":"KMP","slug":"KMP","permalink":"https://vincentxwd.github.io/blog/tags/KMP/"}]},{"title":"[Codeforces1017A-D] Codeforces Round 502 (Div.1+Div.2)","slug":"Codeforces1017A-D-Codeforces-Round-502-Div-1-Div-2","date":"2018-08-08T17:31:42.000Z","updated":"2018-08-08T17:43:26.486Z","comments":true,"path":"2018/08/09/Codeforces1017A-D-Codeforces-Round-502-Div-1-Div-2/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/09/Codeforces1017A-D-Codeforces-Round-502-Div-1-Div-2/","excerpt":"链接：http://codeforces.com/contest/1017 这把肯定要上分的，结果因为服务器爆炸，unrated了好气。。","text":"链接：http://codeforces.com/contest/1017 这把肯定要上分的，结果因为服务器爆炸，unrated了好气。。 A：太水了不多说。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;using P = struct &#123; int a, b, c, d; int s, id;&#125;;const int maxn = 1010;int n;P p[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(cin &gt;&gt; n) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].a&gt;&gt;p[i].b&gt;&gt;p[i].c&gt;&gt;p[i].d; p[i].s = p[i].a+p[i].b+p[i].c+p[i].d; p[i].id = i; &#125; sort(p+1, p+n+1, [](P a, P b) &#123; return a.s == b.s ? a.id &lt; b.id : a.s &gt; b.s; &#125;); for(int i = 1; i &lt;= n; i++) &#123; if(p[i].id == 1) &#123; printf(\"%d\\n\", i); break; &#125; &#125; &#125; return 0;&#125; B：给你两个01串，要求你交换第一个串中的任意两个数，使得这两个串“或”操作后的结果和原始的不一样，问多少种换法。 手写一下会发现导致变化的a、b串某一位置的组合是“10”（用0换掉第一个1）和“00”（用1换掉第一个0），我们统计这样的位置，以及0、1的出现次数，把这两种结果加起来，再减掉一次10和00出现的组合乘积就行了（因为10中的1和00中的0会多进行一次）。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 100100;int n;char a[maxn], b[maxn];LL tot;int vis[2];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(cin &gt;&gt; n) &#123; memset(vis, 0, sizeof(vis)); cin &gt;&gt; a &gt;&gt; b; LL o = 0, z = 0, cnt = 0; for(int i = 0; i &lt; n; i++) &#123; vis[a[i]-'0']++; if(a[i] == '1') o++; if(a[i] == '0') z++; &#125; if(vis[0] == n || vis[1] == n) &#123; printf(\"0\\n\"); continue; &#125; LL x = 0, y = 0; tot = 0; for(int i = 0; i &lt; n; i++) &#123; if(a[i] == '0' &amp;&amp; b[i] == '0') x++; if(a[i] == '1' &amp;&amp; b[i] == '0') y++; &#125; cout &lt;&lt; o*x+z*y-x*y &lt;&lt; endl; &#125; return 0;&#125; C：构造一个长度为n排列，使得这个排列的LIS和LDS长度之和最小。 遇事不决打个表： 我们发现一个规律：当要构造长度为n的排列时，我们可以找到第一个比n大的平方数$k^2$，然后我们依次放入$k^2-k+1,…k^2-1,k^2,…,1,2,…,k$，当要放的数比n大的时候不输出就ok了。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 100100;LL n, nn;vector&lt;int&gt; tmp, gen;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(cin &gt;&gt; n) &#123; gen.clear(); LL nn = 1; while(nn * nn &lt; n) nn++; LL circle = nn; nn = nn * nn; LL del = nn - n; while(nn) &#123; tmp.clear(); for(int i = 0; i &lt; circle; i++, nn--) tmp.emplace_back(nn); reverse(tmp.begin(), tmp.end()); for(auto x : tmp) gen.emplace_back(x); &#125; for(auto x : gen) if(x &lt;= n) cout &lt;&lt; x &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; return 0;&#125; 打表代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const int maxm = 1100;int n;int a[maxn], b[maxn];int f[maxn];int lis() &#123; memset(f, 0, sizeof(f)); for(int i = 1; i &lt;= n; i++) &#123; f[i] = 1; for(int j = 1; j &lt;= n; j++) &#123; if(a[i] &gt; a[j]) f[i] = max(f[i], f[j]+1); &#125; &#125; int ret = 0; for(int i = 1; i &lt;= n; i++) ret = max(ret, f[i]); return ret;&#125;int lds() &#123; memset(f, 0, sizeof(f)); for(int i = 1; i &lt;= n; i++) &#123; f[i] = 1; for(int j = 1; j &lt;= n; j++) &#123; if(a[i] &lt; a[j]) f[i] = max(f[i], f[j]+1); &#125; &#125; int ret = 0; for(int i = 1; i &lt;= n; i++) ret = max(ret, f[i]); return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; for(int i = 1; i &lt;= n; i++) a[i] = i, b[i] = i; int ret = 1000000; do &#123; int tmp = lis() + lds(); if(tmp &lt;= ret) &#123; ret = tmp; printf(\"%d: \", ret); for(int i = 1; i &lt;= n; i++) &#123; b[i] = a[i]; printf(\"%d \", b[i]); &#125; printf(\"\\n\"); &#125; &#125;while(next_permutation(a+1, a+n+1)); printf(\"%d: \", ret); for(int i = 1; i &lt;= n; i++) &#123; printf(\"%d \", b[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; D：两个01串有个匹配的价值，对应位相同的话就要加上那位的价值。给你一些询问串，问有多少串和它的匹配价值不超过k。 这题n给的很小，考虑预处理出任意串和所给串的价值，然后统计当前串这个价值下的字符串数，维护一个前缀和，然后查询就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#pragma optimize(2)const int maxn = 15;int n, m, q;int w[maxn];int wu[4096][4096];int ret[4096][101];int vis[500500];char tmp[maxn];inline int conv(char *x) &#123; int ret = 0; return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q); memset(vis, 0, sizeof(vis)); memset(ret, 0, sizeof(ret)); for(int i = 0; i &lt; n; i++) scanf(\"%d\",&amp;w[i]); int nn = 1 &lt;&lt; n; for(int i = 0; i &lt; m; i++) &#123; scanf(\"%s\", tmp); int x = 0; for(int i = 0; i &lt; n; i++) &#123; x &lt;&lt;= 1; x += tmp[i] - '0'; &#125; vis[x]++; &#125; for(int i = 0; i &lt; nn; i++) &#123; for(int j = 0; j &lt; nn; j++) &#123; if(!vis[j]) continue; int tmp = 0; for(int k = 0; k &lt; n; k++) &#123; if(((1&lt;&lt;k)&amp;i) == ((1&lt;&lt;k)&amp;j)) &#123; tmp += w[n-1-k]; if(tmp &gt; 100) &#123; break; &#125; &#125; &#125; if(tmp &lt;= 100) ret[i][tmp] += vis[j]; &#125; &#125; for(int i = 0; i &lt; nn; i++) &#123; for(int k = 1; k &lt;= 100; k++) &#123; ret[i][k] += ret[i][k-1]; &#125; &#125; while(q--) &#123; int k; scanf(\"%s%d\",tmp,&amp;k); int x = 0; for(int i = 0; i &lt; n; i++) &#123; x &lt;&lt;= 1; x += tmp[i] - '0'; &#125; printf(\"%d\\n\", ret[x][k]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"},{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"},{"name":"预处理","slug":"预处理","permalink":"https://vincentxwd.github.io/blog/tags/预处理/"}]},{"title":"[AtCoderARC100D] Equal Cut (枚举, 二分)","slug":"AtCoderARC100D-Equal-Cut-枚举-二分","date":"2018-08-07T17:00:12.000Z","updated":"2018-08-07T17:03:45.746Z","comments":true,"path":"2018/08/08/AtCoderARC100D-Equal-Cut-枚举-二分/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/08/AtCoderARC100D-Equal-Cut-枚举-二分/","excerpt":"链接：https://arc100.contest.atcoder.jp/tasks/arc100_b 给你n个数，要求你不改变顺序将这n个数字切分成4段，问四段中各段求和后最大和与最小和之间的差","text":"链接：https://arc100.contest.atcoder.jp/tasks/arc100_b 给你n个数，要求你不改变顺序将这n个数字切分成4段，问四段中各段求和后最大和与最小和之间的差 切三刀，可以首先枚举中间拿刀，然后再在两边分别二分各自的那一刀，让各自拆分成的两个集合的和的差值最小，这样才能保证整体的差值最小。这题对我来说挺难写的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;int n;vector&lt;LL&gt; a, s;LL gao(int id) &#123; LL ret = 1E18, tmp = 1E18; int lo = 1, hi = id, s1 = 1, s2 = 1; while(lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt; 1; if(tmp == 1E18 || tmp &gt; (LL)abs(s[id]-s[mid]-s[mid])) &#123; tmp = (LL)abs(s[id]-s[mid]-s[mid]); s1 = mid; &#125; if(s[id]-s[mid]&lt;s[mid]) hi = mid - 1; else lo = mid + 1; &#125; lo = id + 1, hi = n, tmp = 1E18; while(lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt; 1; if(tmp == 1E18 || tmp &gt; (LL)abs(s[n]-s[mid]-(s[mid]-s[id]))) &#123; tmp = (LL)abs(s[n]-s[mid]-(s[mid]-s[id])); s2 = mid; &#125; if(s[n]-s[mid]&lt;s[mid]-s[id]) hi = mid - 1; else lo = mid + 1; &#125; LL L = min(&#123;s[s1], s[id]-s[s1], s[s2]-s[id], s[n]-s[s2]&#125;); LL R = max(&#123;s[s1], s[id]-s[s1], s[s2]-s[id], s[n]-s[s2]&#125;); ret = min(ret, R-L); return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(cin &gt;&gt; n) &#123; a.resize(n+1); s.resize(n+1); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; s[i] = s[i-1] + a[i]; &#125; LL ret = 1E18; for(int i = 1; i &lt;= n; i++) &#123; ret = min(ret, gao(i)); &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; return 0;&#125; https://arc100.contest.atcoder.jp/tasks/arc100_b","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://vincentxwd.github.io/blog/categories/题解/AtCoder/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"https://vincentxwd.github.io/blog/tags/枚举/"},{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"}]},{"title":"[POJ3744] Scout YYF I（概率, DP, 矩阵优化）","slug":"POJ3744-Scout-YYF-I（概率-DP-矩阵优化）","date":"2018-08-07T15:08:37.000Z","updated":"2018-08-07T15:17:10.568Z","comments":true,"path":"2018/08/07/POJ3744-Scout-YYF-I（概率-DP-矩阵优化）/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/07/POJ3744-Scout-YYF-I（概率-DP-矩阵优化）/","excerpt":"链接：https://cn.vjudge.net/problem/POJ-3744 一个人在一条线上走，线上有n个点有地雷，这个人每次有一定概率$p$走一步，也有$1-p$的概率跳两步。问这个人不踩地雷的概率是多少。","text":"链接：https://cn.vjudge.net/problem/POJ-3744 一个人在一条线上走，线上有n个点有地雷，这个人每次有一定概率$p$走一步，也有$1-p$的概率跳两步。问这个人不踩地雷的概率是多少。 我们根据题意能推出递推式：$f(i)$表示走到$i$处的概率为多少。$f(1)=1$，$f(i)=p×f(i-1)+(1-p)×f(i-2)$。 由于线很长，但是地雷很少。我们观察这个递推式是线性的，于是可以用矩阵快速幂优化，构造矩阵：$$\\begin{pmatrix}f(n)\\f(n-1)\\end{pmatrix}=\\begin{pmatrix}p&amp;1-p\\1&amp;0\\end{pmatrix}\\begin{pmatrix}f(n-1)\\f(n-2)\\end{pmatrix}$$对于每一个雷的位置进行分段，计算到那个地方不踩中的概率，递推所有段走到雷处不中的概率，用乘法原理就能求出来结果了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typedef struct Matrix &#123; double m[2][2];&#125;Matrix;Matrix mul(Matrix a, Matrix b) &#123; Matrix ret; memset(ret.m, 0, sizeof(ret.m)); for(int i = 0; i &lt; 2; i++) &#123; for(int j = 0; j &lt; 2; j++) &#123; for(int k = 0; k &lt; 2; k++) &#123; if(b.m[j][k] == 0) continue; ret.m[i][k] += a.m[i][j] * b.m[j][k]; &#125; &#125; &#125; return ret;&#125;Matrix M(Matrix a, int n) &#123; Matrix ret; memset(ret.m, 0, sizeof(ret.m)); ret.m[0][0] = ret.m[1][1] = 1; Matrix tmp = a; while(n) &#123; if(n &amp; 1) &#123; ret = mul(ret, tmp); &#125; n &gt;&gt;= 1; tmp = mul(tmp, tmp); &#125; return ret;&#125;const int maxn = 11;int x[maxn];int n;double q;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(cin &gt;&gt; n &gt;&gt; q) &#123; for(int i = 0; i &lt; n; i++) cin &gt;&gt; x[i]; sort(x, x+n); Matrix ret; double tot = 1.0; Matrix p; p.m[0][0] = q, p.m[0][1] = 1-q; p.m[1][0] = 1, p.m[1][1] = 0; ret = M(p, x[0]-1); tot *= (1 - ret.m[0][0]); for(int i = 1; i &lt; n; i++) &#123; if(x[i] == x[i-1]) continue; ret = M(p, x[i]-x[i-1]-1); tot *= (1 - ret.m[0][0]); &#125; printf(\"%.7f\\n\", tot); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"POJ","slug":"题解/POJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/POJ/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"},{"name":"概率","slug":"概率","permalink":"https://vincentxwd.github.io/blog/tags/概率/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://vincentxwd.github.io/blog/tags/矩阵快速幂/"}]},{"title":"[AtCoderSoundHound18D] Saving Snuuk （最短路）","slug":"AtCoderSoundHound18D-Saving-Snuuk-（最短路）","date":"2018-08-07T12:04:40.000Z","updated":"2018-08-07T15:08:55.971Z","comments":true,"path":"2018/08/07/AtCoderSoundHound18D-Saving-Snuuk-（最短路）/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/07/AtCoderSoundHound18D-Saving-Snuuk-（最短路）/","excerpt":"链接：https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_d 有n个城市，一个人从s出发到t。手里一开始有1E15日元，现在有两种货币，这个人只能将日元兑换成另一种货币，并且是全部兑换。每到一个城市，这人就会在该城市呆一年。城市之间有火车，火车票价格是$a_i$yen或$b_i$snuuk，在每一个城市$i$，第$i$年的时候可以在该城市将yen兑换成snuuk。现在希望让这人剩的snuuk最多，问这人在1~n年内剩最多为多少snuuk。","text":"链接：https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_d 有n个城市，一个人从s出发到t。手里一开始有1E15日元，现在有两种货币，这个人只能将日元兑换成另一种货币，并且是全部兑换。每到一个城市，这人就会在该城市呆一年。城市之间有火车，火车票价格是$a_i$yen或$b_i$snuuk，在每一个城市$i$，第$i$年的时候可以在该城市将yen兑换成snuuk。现在希望让这人剩的snuuk最多，问这人在1~n年内剩最多为多少snuuk。 我们首先关注火车票的花费，希望snuuk剩的最多，只有在买火车票时才会花费，因此直接将火车票花费最小化就可以。 我们做两次最短路：$s$到各点，使用yen做货币，价格为$d1_i$；$t$到各点，使用snuuk做货币，价格为$d2_i$。这样我们可以获得每一个点的总计花费就是$d1_i+d2_i$。 然后再考虑每一年，这人要在每一个城市呆最少一年，最长无限。那么按照城市的兑换开始时间倒着扫一遍，用年份多的剩的多的更新前几年的就可以了。 （流下了不会写C++的眼泪） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;using pli = pair&lt;LL, int&gt;;using Edge = tuple&lt;int, LL, LL&gt;;int n, m, s, t;vector&lt;LL&gt; d1, d2;vector&lt;LL&gt; ret;vector&lt;vector&lt;Edge&gt;&gt; G;priority_queue&lt;pli, vector&lt;pli&gt;, greater&lt;pli&gt;&gt; pq;void gao1() &#123; while(!pq.empty()) pq.pop(); d1[s] = 0; pq.emplace(0, s); int u, v; LL w, tw; while(!pq.empty()) &#123; tie(tw, u) = pq.top(); pq.pop(); if(d1[u] &lt; tw) continue; for(auto edge : G[u]) &#123; tie(v, w, ignore) = edge; if(d1[v] &gt; d1[u] + w) &#123; d1[v] = d1[u] + w; pq.emplace(d1[v], v); &#125; &#125; &#125;&#125;void gao2() &#123; while(!pq.empty()) pq.pop(); d2[t] = 0; pq.emplace(0, t); int u, v; LL w, tw; while(!pq.empty()) &#123; tie(tw, u) = pq.top(); pq.pop(); if(d2[u] &lt; tw) continue; for(auto edge : G[u]) &#123; tie(v, ignore, w) = edge; if(d2[v] &gt; d2[u] + w) &#123; d2[v] = d2[u] + w; pq.emplace(d2[v], v); &#125; &#125; &#125;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int u, v; LL a, b; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t) &#123; G.resize(n+1); ret.resize(n+1); d1.resize(n+1); d1.assign(d1.size(), numeric_limits&lt;LL&gt;::max()); d2.resize(n+1); d2.assign(d2.size(), numeric_limits&lt;LL&gt;::max()); for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; a &gt;&gt; b; G[u].emplace_back(v, a, b); G[v].emplace_back(u, a, b); &#125; gao1(); gao2(); for(int i = 1; i &lt;= n; i++) ret[i] = d1[i] + d2[i]; for(int i = n-1; i &gt;= 1; i--) ret[i] = min(ret[i], ret[i+1]); for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; (LL)1E15 - ret[i] &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://vincentxwd.github.io/blog/categories/题解/AtCoder/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://vincentxwd.github.io/blog/tags/最短路/"}]},{"title":"[AtCoderSoundHound18C] Ordinary Beauty（概率, 期望）","slug":"AtCoderSoundHound18C-Ordinary-Beauty（概率-期望）","date":"2018-08-07T08:52:12.000Z","updated":"2018-08-07T09:00:37.953Z","comments":true,"path":"2018/08/07/AtCoderSoundHound18C-Ordinary-Beauty（概率-期望）/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/07/AtCoderSoundHound18C-Ordinary-Beauty（概率-期望）/","excerpt":"链接：https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_c 给你1~n这n个数，现在允许你随机在m个位置上方这n个数，问你放好后的数组中，相邻两个数字的差为d的数对的概率。","text":"链接：https://soundhound2018-summer-qual.contest.atcoder.jp/tasks/soundhound2018_summer_qual_c 给你1~n这n个数，现在允许你随机在m个位置上方这n个数，问你放好后的数组中，相邻两个数字的差为d的数对的概率。 m个位置存在m-1对数，由于期望的线性可加性，我们知道答案为$(m-1) ×在m个数字中挑选出一对差为d的概率$。 当$d=0$时，相邻两个数字相同的时候才会有贡献，则有一对数字相同的概率为$\\frac{n}{n^2}$。 当$d≠0$时，我们有$(1,d+1),…,(n-d,n)$和$(d+1,1),…,(n,n-d)$这些可能，共有$2×(n-d-d-1+1)=2(n-d)$种，因此一对数字相同的概率是$\\frac{2(n-d)}{n^2}$。 求期望的话，乘上$m-1$就行了。 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;double n, m, d;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; d) &#123; if(d == 0) printf(\"%.15f\\n\", (m-1)/n); else printf(\"%.15f\\n\", 2.0*(n-d)*(m-1)/n/n); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://vincentxwd.github.io/blog/categories/题解/AtCoder/"}],"tags":[{"name":"概率","slug":"概率","permalink":"https://vincentxwd.github.io/blog/tags/概率/"}]},{"title":"[POJ2096] Collecting Bugs （期望, DP）","slug":"POJ2096-Collecting-Bugs-（期望-DP）","date":"2018-08-07T07:32:54.000Z","updated":"2018-08-07T08:04:54.581Z","comments":true,"path":"2018/08/07/POJ2096-Collecting-Bugs-（期望-DP）/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/07/POJ2096-Collecting-Bugs-（期望-DP）/","excerpt":"链接：https://cn.vjudge.net/problem/POJ-2096 有一个程序员要在$s$个子系统里找$n$个不同的BUG，问在$s$种子系统里找到$n$个BUG的天数期望。","text":"链接：https://cn.vjudge.net/problem/POJ-2096 有一个程序员要在$s$个子系统里找$n$个不同的BUG，问在$s$种子系统里找到$n$个BUG的天数期望。 这题是求期望的入门经典，我想拿这道题来做一个总结。 首先是最重要的、也就是期望的一些性质： 1：当$X$和$Y$两个并不一定相互独立随机变量时，我们有如下性质：$$E(aX+bY)=aE(X)+bE(Y)$$上述性质称为期望的线性性（可加性），证明很容易，略。 2：全期望公式：$$E(Y)=E(E(Y|X))=\\sum_{i}P(X=x_i)E(Y|X=x_i)$$当期望存在条件时，可以类比全概率公式获得全期望公式。 以及解决期望问题的常用方法： 解决期望问题有两种方法：高斯消元或者DP。 1：高斯消元不必多说，我们根据题意枚举出所有状态，并根据状态列出期望方程组，使用高斯消元求得各个状态的期望解。 2：当所求状态的期望之间存在一定关系的时候，可以使用动态规划解决期望问题：首先做的事自然是找准递推状态，这是肯定的。找到状态后，接下来要枚举出所有的状态转移，同时计算出转移的条件和代价。我们描述一下上述步骤执行后应该得到的结果：状态$i$、状态$i$下的期望$E(i)$、状态$i$下的递推状态$(j|j由i转移得到)$，每一种状态转移所需的代价$w_i$。 我们可以由状态i下递推出来的状态j获得i状态的期望：$\\sum w_jE(j)$。我们利用期望的可加性，就可以得到$i$的期望了。 对于本题，我们可以设$f(i,j)$表示在$j$个系统中找到$i$个BUG后期望天数。很明显，当$n$天$s$个系统中找到BUG后，该天的期望$E(n,s)=0$。 接下来我们以找到一个BUG为转移条件，由$(i,j)$可以转移出四个不同的状态： $(i,j)$表示在$j$个系统中没有再找到新BUG，转移代价为$p_1=\\frac{i}{n} × \\frac{j}{s}$。 $(i+1,j)$表示在$j$个系统中找到了一个新BUG，转移代价为$p_2=\\frac{n-i}{n} × \\frac{j}{s}$。 $(i,j+1)$表示在一个新系统中找到了一个已有BUG，转移代价为$p_3=\\frac{i}{n} × \\frac{s-j}{s}$。 $(i+1,j+1)$表示在一个新系统中找到了一个新BUG，转移代价为$p_4=\\frac{n-i}{n} × \\frac{s-j}{s}$。 我们可以列出状态$(i,j)$的期望等式：$$E(i,j)=p_1E(i,j)+p_2E(i+1,j)+p_3E(i,j+1)+p_4E(i+1,j+1)$$移项得：$$E(i,j)=\\frac{p_2E(i+1,j)+p_3E(i,j+1)+p_4E(i+1,j+1)}{1-p_1}$$我们由$(n,s)$倒着递推，递推到$(0,0)$时即为要在s个系统中找到n个BUG的期望了。 1234567891011121314151617181920212223const int maxn = 1010;double f[maxn][maxn];int n, s;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;s)) &#123; f[n][s] = 0; double q = n * s; for(int i = n; i &gt;= 0; i--) &#123; for(int j = s; j &gt;= 0; j--) &#123; if(i == n &amp;&amp; j == s) continue; double p1 = double(i * j) / q; double p2 = double((n - i) * j) / q; double p3 = double(i * (s - j)) / q; double p4 = double((n - i) * (s - j)) / q; f[i][j] = (p2*f[i+1][j]+p3*f[i][j+1]+p4*f[i+1][j+1]+1.)/(1.0-p1); &#125; &#125; printf(\"%.4f\\n\", f[0][0]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"POJ","slug":"题解/POJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/POJ/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"},{"name":"概率","slug":"概率","permalink":"https://vincentxwd.github.io/blog/tags/概率/"},{"name":"算法总结","slug":"算法总结","permalink":"https://vincentxwd.github.io/blog/tags/算法总结/"}]},{"title":"[HDOJ6351] 18多校05 Beautiful Now (暴力，全排列，置换群)","slug":"HDOJ6351-18多校05-Beautiful-Now-暴力，全排列，置换群","date":"2018-08-06T14:55:40.000Z","updated":"2018-08-06T16:26:11.902Z","comments":true,"path":"2018/08/06/HDOJ6351-18多校05-Beautiful-Now-暴力，全排列，置换群/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/06/HDOJ6351-18多校05-Beautiful-Now-暴力，全排列，置换群/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6351 给你一个数字$n$和交换次数$k$，问你最多交换$k$次，这个数最大能变为多大，最小能变为多小。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6351 给你一个数字$n$和交换次数$k$，问你最多交换$k$次，这个数最大能变为多大，最小能变为多小。 暴力枚举这个数字的全排列，然后计算和之前数字之间的交换次数。用置换的方法，总计的最少交换次数为所有环的长度-1的和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; perm[10][10];int a[10];int vis[10];void init()&#123; for(int t = 1; t &lt;= 9; t++) &#123; for(int i = 1; i &lt;= t; i++) a[i] = i; memset(vis, 0, sizeof(vis)); do &#123; int now = 0; for(int i = 1; i &lt;= t; i++) now = now * 10 + a[i]; int tmp = 0; for(int i = 1; i &lt;= t; i++) if(vis[i] != now) &#123; vis[i] = now; for(int j = a[i]; j != i; j = a[j]) &#123; vis[j] = now; tmp++; &#125; &#125; perm[t][tmp].push_back(now); &#125; while(next_permutation(a + 1, a + t + 1)); &#125;&#125;inline int apply(int mask)&#123; int ret = 0; int tmp = 1; while(mask) &#123; ret += a[mask % 10] * tmp; mask /= 10; tmp *= 10; &#125; return ret;&#125;char n[12];int t, k, mn, mx;void solve()&#123; scanf(\"%s%d\", n, &amp;k); t = strlen(n); if(t == 10) &#123; printf(\"1000000000 1000000000\\n\"); return; &#125; if(k &gt;= t) k = t - 1; for(int i = 1; i &lt;= t; i++) a[i] = n[i - 1] - '0'; mn = 1000000000; mx = 0; int lj = 1; for(int i = 1; i &lt; t; i++) lj *= 10; for(int i = 0; i &lt;= k; i++) for(vector&lt;int&gt;::iterator it = perm[t][i].begin(); it != perm[t][i].end(); it++) &#123; int now = apply(*it); if(now &lt; lj) continue; now &lt; mn ? mn = now : 0; now &gt; mx ? mx = now : 0; &#125; printf(\"%d %d\\n\", mn, mx);&#125;int main()&#123; // freopen(\"in\", \"r\", stdin); init(); int T; scanf(\"%d\", &amp;T); for(int t1 = 1; t1 &lt;= T; t1++) solve(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"置换群","slug":"置换群","permalink":"https://vincentxwd.github.io/blog/tags/置换群/"}]},{"title":"[HDOJ6354] 18多校05 Everything Has Changed (计算几何)","slug":"HDOJ6354-18多校05-Everything-Has-Changed-计算几何","date":"2018-08-06T14:51:21.000Z","updated":"2018-08-06T16:26:08.512Z","comments":true,"path":"2018/08/06/HDOJ6354-18多校05-Everything-Has-Changed-计算几何/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/06/HDOJ6354-18多校05-Everything-Has-Changed-计算几何/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6354 给你一个圆和互不相交的n个小圆，让你计算这个大圆被n个小圆切割后的周长，大圆内部的不计算。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6354 给你一个圆和互不相交的n个小圆，让你计算这个大圆被n个小圆切割后的周长，大圆内部的不计算。 很容易发现小圆和大圆相交以后，周长增加了小圆的弧长-大圆的弧长。用余弦定理计算一下大小圆关于交处的角度，然后用弧长公式算一下即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct Node &#123; double x, y, r;&#125;Node;const double pi = acos(-1.0);const int maxn = 111;int n;double r;Node p[maxn];double dis(Node a, Node b) &#123; return (double)sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;double gao(Node a, Node b) &#123; if(b.x &lt; 0) b.x = -b.x; if(b.y &lt; 0) b.y = -b.y; double d = dis(a, b); double theta1 = 2.0 * acos((d*d+a.r*a.r-b.r*b.r)/(2*d*a.r)); double theta2 = 2.0 * acos((d*d+b.r*b.r-a.r*a.r)/(2*d*b.r)); double L1 = theta1 * a.r; double L2 = theta2 * b.r; return L2 - L1;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T, _ = 1; scanf(\"%d\", &amp;T); while(T--) &#123; cin &gt;&gt; n &gt;&gt; r; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].r; &#125; double ret = 2 * pi * r; Node o = &#123;0, 0, r&#125;; for(int i = 1; i &lt;= n; i++) &#123; double d = dis(o, p[i]); double R = o.r, r = p[i].r; if(d &gt;= R + r) continue; if(d == R - r) &#123; ret += p[i].r * pi * 2.0; &#125; if(R - r &lt; d &amp;&amp; d &lt; R + r) &#123; ret += gao(o, p[i]); &#125; &#125; printf(\"%.15f\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://vincentxwd.github.io/blog/tags/计算几何/"}]},{"title":"[AtCoderABC103D] Islands War (贪心，思维)","slug":"AtCoderABC103D-Islands-War-贪心，思维","date":"2018-08-06T09:55:41.000Z","updated":"2018-08-06T16:27:18.272Z","comments":true,"path":"2018/08/06/AtCoderABC103D-Islands-War-贪心，思维/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/06/AtCoderABC103D-Islands-War-贪心，思维/","excerpt":"链接：https://abc103.contest.atcoder.jp/tasks/abc103_d 有n个岛练成一条线，每两个岛之间有一个桥。现在有m个岛之间发生了冲突，发生冲突的岛就不能连通了，问最少要切断几座桥？","text":"链接：https://abc103.contest.atcoder.jp/tasks/abc103_d 有n个岛练成一条线，每两个岛之间有一个桥。现在有m个岛之间发生了冲突，发生冲突的岛就不能连通了，问最少要切断几座桥？ 这题很有意思，贪心地去考虑，希望切到的边影响尽可能地大，可以考虑贪心地将发生冲突的右端点从小到大排，然后从左到右开始切。 可以反证一下：假如选中的某次冲突的右端点不是最优的解，那么可能存在一个在此点左侧的点待切，显然存在的左侧点不是最优点，因为左侧已经统计完将此点之前发生冲突的点对分割开的桥数，再添加一条是冗余的。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;using pii = pair&lt;int, int&gt;;const int maxn = 100100;int n, m;pii p[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\",&amp;p[i].first,&amp;p[i].second); if(p[i].first &gt; p[i].second) swap(p[i].first, p[i].second); &#125; sort(p+1, p+m+1, [](pii x, pii y)&#123; if(x.second != y.second) return x.second &lt; y.second; return x.first &lt; y.first; &#125;); int tot = 1; int pre = p[1].second; for(int i = 2; i &lt;= m; i++) &#123; if(pre &gt; p[i].first) continue; else &#123; tot++; pre = p[i].second; &#125; &#125; printf(\"%d\\n\", tot); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://vincentxwd.github.io/blog/categories/题解/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"},{"name":"思维","slug":"思维","permalink":"https://vincentxwd.github.io/blog/tags/思维/"}]},{"title":"[AtCoderABC104D] We Love ABC (DP, 计数)","slug":"AtCoderABC104D-We-Love-ABC-DP-计数","date":"2018-08-06T03:16:29.000Z","updated":"2018-08-06T16:27:13.789Z","comments":true,"path":"2018/08/06/AtCoderABC104D-We-Love-ABC-DP-计数/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/06/AtCoderABC104D-We-Love-ABC-DP-计数/","excerpt":"链接：https://abc104.contest.atcoder.jp/tasks/abc104_d 给一个只含有ABC?四种字符的字符串，?可以替换成ABC中的任意一个字符，现在要你统计所有的ABC的组合个数。","text":"链接：https://abc104.contest.atcoder.jp/tasks/abc104_d 给一个只含有ABC?四种字符的字符串，?可以替换成ABC中的任意一个字符，现在要你统计所有的ABC的组合个数。 这题比赛时间内写搓了，因为误读了题目的统计结果，比如?ABC，答案应该是4（AABC BABC CABC）。 我们可以考虑枚举B的位置，并以这个B为链接，那么问题就变成了统计左侧A的个数和右侧C的个数。这里也不能是简单地将左右两侧的A?和C?的个数乘起来，因为固定了某一对A、C后其他字符的变化也是要算作不同组合的。我们将每一个B的位置的计数结果拆成四项来统计，即： 1234A、B、C?、B、CA、B、??、B、? 第一项很好统计，由于不存在?所以可以直接计数。第二、三项的本质是相同的，我们在B的某一侧存在?时，要枚举任意一个?（让这个?作为A或C出现），那么其他位置的?则是任意的，那么每一个位置对答案的贡献是$3^{k-1}$，其中$k$为?的左侧或右侧总数。第四项和第二、三项也是一样的，但是要在左右两边各取一个?，假设左侧有$x_1$个?，右侧有$x_2$个?，那么计数结果为$3^{x_1-1}×3^{x_2-1}$，整理为$3^{x_1+x_2-2}$。这样我们就推出了每一个B对总体答案的分步贡献，我们维护A、C、?出现次数的前缀和，之后就可以分类讨论了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)using LL = long long;const int maxn = 100100;LL mod = 1e9 + 7;char s[maxn];LL f[maxn][3];int n;LL mul(LL x, LL n) &#123; LL ret = 1; while(n) &#123; if(n &amp; 1) &#123; ret *= x; ret %= mod; &#125; n &gt;&gt;= 1; x *= x; x %= mod; &#125; return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%s\", s+1)) &#123; memset(f, 0, sizeof(f)); n = strlen(s+1); for(int i = 1; i &lt;= n; i++) &#123; f[i][0] = f[i-1][0] + (s[i] == 'A'); f[i][1] = f[i-1][1] + (s[i] == 'C'); f[i][2] = f[i-1][2] + (s[i] == '?'); &#125; LL ret = 0; for(int i = 1; i &lt;= n; i++) &#123; if(s[i] == 'B' || s[i] == '?') &#123; LL q = f[n][2] - (s[i] == '?'); ret += mul(3LL, q) * (f[i-1][0] * (f[n][1] - f[i][1]) % mod); ret %= mod; if(q &gt;= 1) &#123; ret += mul(3LL, q-1) * (f[i-1][0] * (f[n][2] - f[i][2]) % mod); ret %= mod; ret += mul(3LL, q-1) * (f[i-1][2] * (f[n][1] - f[i][1]) % mod); ret %= mod; &#125; if(q &gt;= 2) &#123; ret += mul(3LL, q-2) * (f[i-1][2] * (f[n][2] - f[i][2]) % mod); ret %= mod; &#125; &#125; &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://vincentxwd.github.io/blog/categories/题解/AtCoder/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[2018百度之星] 资格赛1003 整数规划 (最大匹配)","slug":"2018百度之星-资格赛1003-整数规划-最大匹配","date":"2018-08-05T14:09:51.000Z","updated":"2018-08-06T16:27:53.142Z","comments":true,"path":"2018/08/05/2018百度之星-资格赛1003-整数规划-最大匹配/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1003-整数规划-最大匹配/","excerpt":"题目链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1003","text":"题目链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1003 希望最大化目标函数，事实上满足 Kuhn–Munkres algorithm 求解最小权匹配过程中的顶标的定义，现在就是要计算最大顶标和，而这正好就是最小权匹配 ，按照$x_i$和$y_i$给定的约束条件连边，同时边权置为负值。然后跑最大匹配，输出结果的相反数。 这题一般的KM算法是过不了的，因为网上流传的KM代码都到不了$O(n^3)$。于是去UOJ上扒了一份KM模版…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int N = 405;int w[N][N];int lx[N], ly[N];int lmatch[N], rmatch[N];bool lvis[N], rvis[N];int slack[N];int pre[N];int n;int update(int n) &#123; int dt = INF, ru; for (int j = 1; j &lt;= n; j++) if (!rvis[j] &amp;&amp; slack[j] &lt; dt) &#123; dt = slack[j]; ru = j; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (lvis[i]) lx[i] -= dt; if (rvis[i]) ly[i] += dt; else slack[i] -= dt; &#125; return ru;&#125;void match(int&amp; u) &#123; for (; u; swap(u, lmatch[pre[u]])) rmatch[u] = pre[u];&#125;void bfs(int u, int n) &#123; queue&lt;int&gt; q; q.push(u); lvis[u] = true; while (true) &#123; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v = 1; v &lt;= n; ++v) &#123; int tmp; if (rvis[v] || (tmp = lx[u] + ly[v] - w[u][v]) &gt; slack[v]) continue; pre[v] = u; if (!tmp) &#123; if (!rmatch[v]) return match(v); rvis[v] = lvis[rmatch[v]] = true; q.push(rmatch[v]); &#125; else slack[v] = tmp; &#125; &#125; u = update(n); if (!rmatch[u]) return match(u); rvis[u] = lvis[rmatch[u]] = true; q.push(rmatch[u]); &#125;&#125;LL KM(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; lmatch[i] = rmatch[i] = lx[i] = ly[i] = 0; for (int j = 1; j &lt;= n; j++) &#123; lx[i] = max(lx[i], w[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; slack[j] = INF; lvis[j] = rvis[j] = false; &#125; bfs(i, n); &#125; LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; res += lx[i] + ly[i]; &#125; return res;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T_T, _ = 0; scanf(\"%d\", &amp;T_T); while(T_T--) &#123; scanf(\"%d\",&amp;n); memset(w, 0, sizeof(w)); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; scanf(\"%d\", &amp;w[i][j]); w[i][j] = -w[i][j]; &#125; &#125; printf(\"Case #%d: %I64d\\n\", ++_, -KM(n)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"匹配问题","slug":"匹配问题","permalink":"https://vincentxwd.github.io/blog/tags/匹配问题/"}]},{"title":"[2018百度之星] 资格赛1005 序列计数 (DP, 树状数组, 随机)","slug":"2018百度之星-资格赛1005-序列计数-DP-树状数组-随机","date":"2018-08-05T03:34:48.000Z","updated":"2018-08-06T16:27:24.645Z","comments":true,"path":"2018/08/05/2018百度之星-资格赛1005-序列计数-DP-树状数组-随机/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1005-序列计数-DP-树状数组-随机/","excerpt":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1005 这题随机给你一个1~n的排列，要你统计这1~n的排列中长度为1~n的上升子序列的个数分别是多少。","text":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1005 这题随机给你一个1~n的排列，要你统计这1~n的排列中长度为1~n的上升子序列的个数分别是多少。 由于数据是随机的，因此这个序列中的LIS满足下面这个工作： LIS的长度大概是$2\\sqrt{N}$，当$N=10000$时，LIS的最长长度大约为$200$。 我们很容易就推出LIS的计数公式：$$f(i,k) += (p_i &gt; p_j)? f(j,k-1) : 0$$可以考虑枚举LIS的长度$l$，用bit维护到第$i$个位置的数字$p[i]$、长度为$l-1$的上升子序列的总数，这样每次扫一个位置的时候，就可以直接查前缀和了。 由于要更新bit，所以维护一个滚动的dp数组，在查询长度为$l-1$的计数结果的同时，更新答案以及$l$的计数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)using LL = long long;const LL maxn = 10100;const LL mod = 1e9+7;LL n;LL p[maxn];LL bit[maxn];LL f[2][maxn];LL lowbit(LL x) &#123; return x &amp; -x;&#125;void add(LL x, LL val) &#123; for(LL i = x; i &lt;= n; i+=lowbit(i)) &#123; bit[i] += val; bit[i] %= mod; &#125;&#125;LL sum(LL x) &#123; LL ret = 0; for(LL i = x; i; i-=lowbit(i)) &#123; ret += bit[i]; ret %= mod; &#125; return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); LL T, _ = 0; scanf(\"%I64d\", &amp;T); while(T--) &#123; scanf(\"%I64d\", &amp;n); for(LL i = 1; i &lt;= n; i++) &#123; scanf(\"%I64d\",&amp;p[i]); &#125; memset(bit, 0, sizeof(bit)); memset(f, 0, sizeof(f)); LL x = 0, flag = 1; for(LL i = 1; i &lt;= n; i++) f[0][i] = 1; printf(\"Case #%I64d:\", ++_); printf(\" %I64d\", n); for(LL l = 2; l &lt;= n; l++) &#123; x = !x; LL ret = 0; if(flag) &#123; memset(bit, 0, sizeof(bit)); for(LL i = 1; i &lt;= n; i++) &#123; f[x][i] = sum(p[i] - 1); ret += f[x][i]; ret %= mod; add(p[i], f[!x][i]); &#125; &#125; if(ret == 0) flag = 0; printf(\" %I64d\", ret); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://vincentxwd.github.io/blog/tags/树状数组/"},{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[2018百度之星] 资格赛1006 三原色图 (最小生成树)","slug":"2018百度之星-资格赛1006-三原色图-最小生成树","date":"2018-08-04T16:37:14.000Z","updated":"2018-08-06T16:27:21.757Z","comments":true,"path":"2018/08/05/2018百度之星-资格赛1006-三原色图-最小生成树/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1006-三原色图-最小生成树/","excerpt":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1006","text":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1006 这题很简单，按照RG、BG的组合分别跑最小生成树，假如某一种情况无法构造出则抛弃那一种情况。同时给边打标记，最后再取k-(n+1)条最短的未添加到生成树里的边就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct Node &#123; int id, u, v, w; char c; friend bool operator&lt;(Node a, Node b) &#123; return a.w &gt; b.w; &#125;&#125;Node;const int maxn = 110;int n, m, eid;int pre[maxn];int vis[maxn&lt;&lt;2];vector&lt;Node&gt; G[maxn];priority_queue&lt;Node&gt; pq;int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;bool unite(int x, int y) &#123; x = find(x); y = find(y); if (x != y) &#123; pre[y] = x; return 1; &#125; return 0;&#125;pair&lt;int, bool&gt; gao1(int k) &#123; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt; maxn; i++) pre[i] = i; while (!pq.empty()) pq.pop(); int tot = 0, ret = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; if(G[i][j].c == 'R' || G[i][j].c == 'G') &#123; pq.push(G[i][j]); &#125; &#125; &#125; while(!pq.empty()) &#123; Node p = pq.top(); pq.pop(); if(unite(p.u, p.v)) &#123; tot++; ret += p.w; vis[p.id] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; if(!vis[G[i][j].id]) pq.push(G[i][j]); &#125; &#125; for(int i = 0; i &lt; k - n + 1; i++) &#123; ret += pq.top().w; pq.pop(); pq.pop(); &#125; return make_pair(ret, tot == n - 1);&#125;pair&lt;int, bool&gt; gao2(int k) &#123; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt; maxn; i++) pre[i] = i; while (!pq.empty()) pq.pop(); int tot = 0, ret = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; if(G[i][j].c == 'B' || G[i][j].c == 'G') &#123; pq.push(G[i][j]); &#125; &#125; &#125; while(!pq.empty()) &#123; Node p = pq.top(); pq.pop(); if(unite(p.u, p.v)) &#123; tot++; ret += p.w; vis[p.id] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; if(!vis[G[i][j].id]) pq.push(G[i][j]); &#125; &#125; for(int i = 0; i &lt; k - n + 1; i++) &#123; ret += pq.top().w; pq.pop(); pq.pop(); &#125; return make_pair(ret, tot == n - 1);&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T, _ = 0; int u, v, w; char c[5]; scanf(\"%d\", &amp;T); while(T--) &#123; eid = 1; scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) G[i].clear(); for(int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d%d%s\",&amp;u,&amp;v,&amp;w,c); G[u].push_back(&#123;eid, u, v, w, c[0]&#125;); G[v].push_back(&#123;eid++, v, u, w, c[0]&#125;); &#125; pair&lt;int, bool&gt; tmp; printf(\"Case #%d:\\n\", ++_); for(int k = 1; k &lt;= m; k++) &#123; if(k &lt; n - 1) &#123; printf(\"-1\\n\"); continue; &#125; int ret = 0x7f7f7f7f; tmp = gao1(k); if(tmp.second) &#123; ret = min(ret, tmp.first); &#125; tmp = gao2(k); if(tmp.second) &#123; ret = min(ret, tmp.first); &#125; if(ret == 0x7f7f7f7f) printf(\"-1\\n\"); else printf(\"%d\\n\", ret); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"https://vincentxwd.github.io/blog/tags/最小生成树/"}]},{"title":"[2018百度之星] 资格赛1001 调查问卷 (状压枚举, 计数)","slug":"2018百度之星-资格赛1001-调查问卷-状压枚举-计数","date":"2018-08-04T16:36:08.000Z","updated":"2018-08-06T16:25:42.265Z","comments":true,"path":"2018/08/05/2018百度之星-资格赛1001-调查问卷-状压枚举-计数/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1001-调查问卷-状压枚举-计数/","excerpt":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1001","text":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1001 没啥好解释的，中文题意。 因为题目最多10道，因此枚举所有题目的组合，然后把每一份问卷的对应答案存出来，对每一类单独统计数目。之后每一类中的问卷答案数$k$与其他问卷答案成的对数为$p×(n-p)$，累加所有问卷答案对数再除以2，跟目标k比较一下就ok。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;int n, m, k;char s[maxn][11];int cur[maxn][11];int f[maxn];unordered_map&lt;int, int&gt; vis;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T, _ = 0; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", s[i]); &#125; int ret = 0; int mm = 1 &lt;&lt; m; for(int i = 1; i &lt; mm; i++) &#123; int qq = 0; for(int j = 0; j &lt; m; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; for(int l = 0; l &lt; n; l++) &#123; cur[l][qq] = s[l][j] - 'A' + 1; &#125; qq++; &#125; &#125; for(int j = 0; j &lt; n; j++) f[j] = 0; for(int j = 0; j &lt; n; j++) &#123; for(int l = 0; l &lt; qq; l++) &#123; f[j] &lt;&lt;= 1; f[j] |= (cur[j][l] == 1 ? 1 : 0); &#125; &#125; vis.clear(); for(int j = 0; j &lt; n; j++) vis[f[j]]++; int tot = n, tmp = 0; for(auto p : vis) &#123; tmp += (n - p.second) * p.second; &#125; if(tmp / 2 &gt;= k) ret++; &#125; printf(\"Case #%d: %d\\n\", ++_, ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"枚举","slug":"枚举","permalink":"https://vincentxwd.github.io/blog/tags/枚举/"}]},{"title":"[Codeforces1016C] Vasya And The Mushrooms (DP)","slug":"Codeforces1016C-Vasya-And-The-Mushrooms-DP","date":"2018-08-04T13:58:14.000Z","updated":"2018-08-06T16:26:36.220Z","comments":true,"path":"2018/08/04/Codeforces1016C-Vasya-And-The-Mushrooms-DP/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/04/Codeforces1016C-Vasya-And-The-Mushrooms-DP/","excerpt":"链接：http://codeforces.com/contest/1016/problem/C 给出一个$2×n$的矩阵，一个人从$(1,1)$出发，每一个格子只能走一次，走完这$2n$个格子后使得带权和最大，问最大的带权和是多少。","text":"链接：http://codeforces.com/contest/1016/problem/C 给出一个$2×n$的矩阵，一个人从$(1,1)$出发，每一个格子只能走一次，走完这$2n$个格子后使得带权和最大，问最大的带权和是多少。 容易发现走到最后一个格子之前路径可以分为两个部分：前半部分蛇皮走位，后半部分一个大回环。 但是决定走大回环的位置也是分奇偶的，于是我们预处理出每一行的前缀和$sa_i$和$sb_i$，以及两组后缀和，分别为拐弯前（$da_i、db_i$）和拐弯后（$ia_i、ib_i$）。 然后我们可以枚举拐弯的结点，并同时记录前面走蛇皮位的结果，同时讨论目前在下还是在上，决定大回环值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 300003;int dx[5] = &#123;0, 0, 1, -1&#125;;int dy[5] = &#123;1, -1, 0, 0&#125;;int n;LL a[maxn], b[maxn];LL sa[maxn], sb[maxn], ia[maxn], ib[maxn], da[maxn], db[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\", &amp;n)) &#123; for(int i = 0; i &lt; n; i++) scanf(\"%lld\",&amp;a[i]); for(int i = 0; i &lt; n; i++) scanf(\"%lld\",&amp;b[i]); memset(sa, 0, sizeof(sa)); memset(sb, 0, sizeof(sb)); memset(ia, 0, sizeof(ia)); memset(ib, 0, sizeof(ib)); memset(da, 0, sizeof(da)); memset(db, 0, sizeof(db)); for(int i = n - 1; i &gt;= 0; i--) &#123; sa[i] = sa[i+1] + a[i]; sb[i] = sb[i+1] + b[i]; ia[i] = ia[i+1] + a[i] * (LL)(n-i-1LL); ib[i] = ib[i+1] + b[i] * (LL)(n-i-1LL); da[i] = da[i+1] + a[i] * (LL)i; db[i] = db[i+1] + b[i] * (LL)i; &#125; LL ret = 0, tmp = 0; for(int i = 0; i &lt; n; i++) &#123; if(i &amp; 1) &#123; LL tr = db[i] + sb[i] * (2LL*i - i); tr += ia[i] + sa[i] * (2LL*i + n - i); ret = max(ret, tmp+tr); tmp += (2LL*i*b[i]); tmp += (2LL*i+1LL)*a[i]; &#125; else &#123; LL tr = da[i] + sa[i] * (2LL*i - i); tr += ib[i] + sb[i] * (2LL*i + n - i); ret = max(ret, tmp+tr); tmp += (2LL*i*a[i]); tmp += (2LL*i+1LL)*b[i]; &#125; &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[Codeforces1016D] Vasya And The Matrix (构造)","slug":"Codeforces1016D-Vasya-And-The-Matrix-构造","date":"2018-08-04T12:59:16.000Z","updated":"2018-08-06T16:26:31.682Z","comments":true,"path":"2018/08/04/Codeforces1016D-Vasya-And-The-Matrix-构造/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/04/Codeforces1016D-Vasya-And-The-Matrix-构造/","excerpt":"链接：http://codeforces.com/contest/1016/problem/D 给出一个矩阵的行和列的大小$n，m$以及每一行和每一列的异或和$a_i$和$b_i$，让你构造这样一个矩阵。","text":"链接：http://codeforces.com/contest/1016/problem/D 给出一个矩阵的行和列的大小$n，m$以及每一行和每一列的异或和$a_i$和$b_i$，让你构造这样一个矩阵。 考虑将每一行的异或和放到第一列上，每一列的异或和放到第一行上。问题在$(1,1)$处，这里可以用$a_2、a_3、…、a_n$。接下来判断这个数和第一行的异或和是否为$b_1$即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;int a[maxn], b[maxn], ret;int n, m;int G[maxn][maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; ret = 0; memset(G, 0, sizeof(G)); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); ret ^= a[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;b[i]); ret ^= b[i]; &#125; if(ret != 0) &#123; printf(\"NO\\n\"); continue; &#125; G[1][1] = b[1]; for(int i = 2; i &lt;= n; i++) &#123; G[1][1] ^= a[i]; &#125; for(int i = 2; i &lt;= m; i++) &#123; G[1][i] = b[i]; &#125; for(int i = 2; i &lt;= n; i++) &#123; G[i][1] = a[i]; &#125; int p = 0; for(int i = 1; i &lt;= m; i++) &#123; p ^= G[1][i]; &#125; if(p != a[1]) &#123; printf(\"NO\\n\"); continue; &#125; printf(\"YES\\n\"); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; printf(\"%d%c\", G[i][j], \" \\n\"[j==m]); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"}]},{"title":"2018牛客多校05 E room (费用流)","slug":"2018牛客多校05-E-room-费用流","date":"2018-08-03T05:47:19.000Z","updated":"2018-08-06T16:27:41.011Z","comments":true,"path":"2018/08/03/2018牛客多校05-E-room-费用流/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/2018牛客多校05-E-room-费用流/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/E n个宿舍，每个宿舍住4个人，给两年的住宿情况，问最少调换多少人，能从前一年的住宿状态调换到后一年的住宿状态（宿舍顺序不影响）。","text":"链接：https://www.nowcoder.com/acm/contest/143/E n个宿舍，每个宿舍住4个人，给两年的住宿情况，问最少调换多少人，能从前一年的住宿状态调换到后一年的住宿状态（宿舍顺序不影响）。 比赛的时候没时间看，补题的时候发现是一道挺好想的费用流问题。 考虑宿舍整体，当一个宿舍变为另一个宿舍的时候，我们的代价是这两个宿舍中不同人的个数，按照这条规律，我们可以建图： 单独建超级源和超级汇，之后按照不同年份和不同宿舍建点，不同年的每个宿舍之间连接一条边，容量为1，费用为不同人的个数。源点连接前一年的点，容量为1费用为0，后一年的点连汇点，容量为1费用为0。这样跑一下最小费用最大流就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef struct Node &#123; int u, v, next; LL c, w;&#125;Node;const int maxn = 210;const int maxm = 40100;const LL mod = 0x3f3f3f3fLL;const LL inf = (1LL&lt;&lt;55);int tot, head[maxn];LL dist[maxn];LL cost, flow;Node e[maxm];int pre[maxn];bool visit[maxn];queue&lt;int&gt; Q;int S, T, N;void init() &#123; S = T = N = 0; memset(head, -1, sizeof(head)); tot = 0;&#125;void adde(int u, int v, LL c, LL w) &#123; e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++; e[tot].u = v; e[tot].v = u; e[tot].c = 0; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;&#125;bool spfa(int s, int t, int n) &#123; int i; for(i = 0; i &lt;= n; i++) &#123; dist[i] = inf; visit[i] = 0; pre[i] = -1; &#125; while(!Q.empty()) Q.pop(); Q.push(s); visit[s] = true; dist[s] = 0; pre[s] = -1; while(!Q.empty()) &#123; int u = Q.front(); visit[u] = false; Q.pop(); for(int j = head[u]; j != -1; j = e[j].next) &#123; if(e[j].c &gt; 0 &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123; dist[e[j].v] = dist[u] + e[j].w; pre[e[j].v] = j; if(!visit[e[j].v]) &#123; Q.push(e[j].v); visit[e[j].v] = true; &#125; &#125; &#125; &#125; // return dist[t] &lt; 0; // 求可行流 if(dist[t] == inf) return false; // 求最小费用流 else return true;&#125;LL ChangeFlow(int t) &#123; LL det = mod; int u = t; while(~pre[u]) &#123; u = pre[u]; det = min(det, e[u].c); u = e[u].u; &#125; u = t; while(~pre[u]) &#123; u = pre[u]; e[u].c -= det; e[u ^ 1].c += det; u = e[u].u; &#125; return det;&#125;LL MinCostFlow(int s, int t, int n) &#123; LL mincost, maxflow; mincost = maxflow = 0; while(spfa(s, t, n)) &#123; LL det = ChangeFlow(t); mincost += det * dist[t]; maxflow += det; &#125; cost = mincost; flow = maxflow; return mincost;&#125;int n;int vis[maxn][maxn][2];signed main() &#123; // freopen(\"in\", \"r\", stdin); int x; while(~scanf(\"%d\", &amp;n)) &#123; init();T = 2 * n + 1; N = T + 1; memset(vis, 0, sizeof(vis)); int tot = n * 4; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= 4; j++) &#123; scanf(\"%d\", &amp;x); vis[i][x][0] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= 4; j++) &#123; scanf(\"%d\", &amp;x); vis[i][x][1] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; adde(S, i, 1, 0); adde(i+n, T, 1, 0); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; int diff = 0; for(int k = 1; k &lt;= tot; k++) &#123; if(vis[i][k][0] == vis[j][k][1] &amp;&amp; vis[i][k][0] == 1) &#123; diff++; &#125; &#125; adde(i, j+n, 1, 4-diff); &#125; &#125; cout &lt;&lt; MinCostFlow(S, T, N) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://vincentxwd.github.io/blog/tags/费用流/"}]},{"title":"[HDOJ6301] 18多校01 Distinct Values (莫队算法, 构造)","slug":"HDOJ6301-Distinct-Values-莫队算法","date":"2018-08-03T04:22:10.000Z","updated":"2018-08-06T16:26:15.412Z","comments":true,"path":"2018/08/03/HDOJ6301-Distinct-Values-莫队算法/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/HDOJ6301-Distinct-Values-莫队算法/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6301 给出m个区间，要求构造一个指定区间内的数字不能相等，并且数字在$[1,n]$之间，求构造的字典序最小的方案。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6301 给出m个区间，要求构造一个指定区间内的数字不能相等，并且数字在$[1,n]$之间，求构造的字典序最小的方案。 首先给区间排个序，按照左端点小、右端点小的规则排。接下来维护两个指针L、R，从左到右往里塞，然后用类似莫队的更新方法去维护数列，同时维护目前可用的数字。 整体复杂度为$O(n+m)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using Node = struct &#123; int l, r;&#125;;const int maxn = 100100;int n, m, a[maxn];Node p[maxn];set&lt;int&gt; st;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while(T--) &#123; st.clear(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\",&amp;p[i].l,&amp;p[i].r); &#125; sort(p+1, p+m+1, [](Node a, Node b) &#123; return a.l == b.l ? a.r &lt; b.r : a.l &lt; b.l; &#125;); for(int i = 1; i &lt;= n; i++) &#123; st.insert(i); a[i] = 1; &#125; int L = p[1].l, R = p[1].r; for(int i = L; i &lt;= R; i++) &#123; a[i] = *st.begin(); st.erase(a[i]); &#125; for(int i = 2; i &lt;= m; i++) &#123; while(L &lt; p[i].l) &#123; st.insert(a[L++]); &#125; while(R &lt; p[i].r) &#123; if(R + 1 &lt; p[i].l) R++; else &#123; a[++R] = *st.begin(); st.erase(a[R]); &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; printf(\"%d%c\", a[i], \" \\n\"[i==n]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"莫队算法","slug":"莫队算法","permalink":"https://vincentxwd.github.io/blog/tags/莫队算法/"},{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"}]},{"title":"[HDOJ6299] 18多校01 Balanced Sequence (贪心)","slug":"HDOJ6299-Balanced-Sequence-贪心","date":"2018-08-03T04:18:41.000Z","updated":"2018-08-06T16:26:19.873Z","comments":true,"path":"2018/08/03/HDOJ6299-Balanced-Sequence-贪心/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/HDOJ6299-Balanced-Sequence-贪心/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6299 n个括号串，问如何排列这n个串，使得连起来后()匹配的对数最多（不用连续）。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6299 n个括号串，问如何排列这n个串，使得连起来后()匹配的对数最多（不用连续）。 首先串内匹配并记录答案。之后尽可能让左括号多的在左边，右括号多的在右边排序，再贪心扫一遍，只维护左括号的个数，同时根据下一个串右括号的个数统计答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using Node = struct &#123; int l, r, v;&#125;;const int maxn = 100100;int n;vector&lt;Node&gt; p;char s[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d\", &amp;n); p.resize(n); for(int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", s); int tot = 0; int l = 0, r = 0; for(int j = 0; s[j]; j++) &#123; if(s[j] == '(') &#123; l++; &#125; else &#123; if(l != 0) l--, tot++; else r++; &#125; &#125; p[i].l = l, p[i].r = r, p[i].v = tot; &#125; sort(p.begin(), p.end(), [](Node a, Node b) &#123; if(a.l &gt; a.r) &#123; return b.l &gt; b.r ? a.r &lt; b.r : true; &#125; return b.l &lt;= b.r ? a.l &gt; b.l : false; &#125;); int l = 0, r = 0, ret = 0; for(int i = 0; i &lt; n - 1; i++) &#123; ret += p[i].v; l += p[i].l; r += p[i+1].r; ret += min(l, r); l -= min(l, r); r = 0; &#125; ret += p[n-1].v; printf(\"%d\\n\", ret * 2); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"}]},{"title":"[Hackerrank] Array Partition (并查集, 数学)","slug":"Hackerrank-Array-Partition-并查集-数学","date":"2018-08-02T16:52:18.000Z","updated":"2018-08-06T16:26:24.246Z","comments":true,"path":"2018/08/03/Hackerrank-Array-Partition-并查集-数学/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/Hackerrank-Array-Partition-并查集-数学/","excerpt":"链接：https://www.hackerrank.com/contests/hourrank-29/challenges/array-partition 给n个数，让你将这n个数拆分成两个集合，使得两个集合分别乘积互质，求拆分方案数。","text":"链接：https://www.hackerrank.com/contests/hourrank-29/challenges/array-partition 给n个数，让你将这n个数拆分成两个集合，使得两个集合分别乘积互质，求拆分方案数。 第一次打Hackerrank，一个小时三道题还是很刺激的。这道题比赛的时候没调出来，只拿了部分分，有点遗憾啊~）ps：衣服还是很难拿的，top10 才有，这场出现了tourist等众神牛，这种场拿衣服还是不想了。 根据题目的要求，显然拥有相同因数的数字必须呆在同一个集合（1除外，这是个trick，后面会说），考虑用一个方法，将所有拥有至少一个公共因数的数字划为同一个集合，然后再对所有不连通的集合进行计数，会发现：当有$n$个集合的时候，我们的划分方案数为$2^{n}-2$。 很显然可以用并查集维护每一个数的因数的连通情况，因此我们在枚举每一个数的因数的同时，将因数和这个数并到一起就可以了。这里需要特别注意的是，每一个1都可以分到一个单独的集合里，因此计数的时候需要单独考虑~ 整体复杂度为$O(n\\sqrt{n})$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758typedef long long LL;const int maxn = 1000010;const LL mod = 1e9+7;int pre[maxn];set&lt;int&gt; vis;int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if(x != y) &#123; pre[x] = y; &#125;&#125;int solve(vector&lt;int&gt; a) &#123; int cnt = 0; int nn = 1 &lt;&lt; a.size(); vis.clear(); for(int i = 0; i &lt; maxn; i++) pre[i] = i; for(int i = 0; i &lt; a.size(); i++) &#123; if(a[i] == 1) cnt++; vis.insert(a[i]); int tmp = a[i]; int aa = (int)sqrt(a[i]) + 1; for(int j = 2; j &lt;= aa; j++) &#123; if(tmp % j == 0) &#123; unite(a[i], j); vis.insert(j); while(tmp % j == 0) tmp /= j; &#125; &#125; if(tmp != 1) unite(a[i], tmp); &#125; map&lt;int, int&gt; block; for(int i = 0; i &lt; maxn; i++) &#123; if(vis.find(i) != vis.end()) &#123; block[find(i)]++; &#125; &#125; if(block.size() &lt; 2) &#123; return 0; &#125; LL ret = 1; for(int i = 0; i &lt; block.size(); i++) &#123; ret *= 2; ret %= mod; &#125; for(int i = 0; i &lt; cnt - 1; i++) &#123; ret *= 2; ret %= mod; &#125; ret -= 2; ret += mod; ret %= mod; return ret;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Hackerrank","slug":"题解/Hackerrank","permalink":"https://vincentxwd.github.io/blog/categories/题解/Hackerrank/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"并查集","slug":"并查集","permalink":"https://vincentxwd.github.io/blog/tags/并查集/"}]},{"title":"2018牛客多校05 J plan(数学，规律)","slug":"2018牛客多校05-J-plan-数学，规律","date":"2018-08-02T14:13:21.000Z","updated":"2018-08-06T16:27:30.873Z","comments":true,"path":"2018/08/02/2018牛客多校05-J-plan-数学，规律/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/02/2018牛客多校05-J-plan-数学，规律/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/J n个人住宾馆，双人间价格为p2，三人间价格为p3，如何安排，使总花费最少。","text":"链接：https://www.nowcoder.com/acm/contest/143/J n个人住宾馆，双人间价格为p2，三人间价格为p3，如何安排，使总花费最少。 列方程，枚举最近的6个结果即可。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;LL n, a, b; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;a,&amp;b)) &#123; LL ret = 1e18; for(LL i = 0; i &lt;= 6; i++) &#123; ret = min(ret, (n+1-i)/2*a+(i+2)/3*b); ret = min(ret, (n+2-i)/3*b+(i+1)/2*a); &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"2018牛客多校05 G max(数学，规律)","slug":"2018牛客多校05-G-max-数学，规律","date":"2018-08-02T14:12:51.000Z","updated":"2018-08-06T16:27:37.303Z","comments":true,"path":"2018/08/02/2018牛客多校05-G-max-数学，规律/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/02/2018牛客多校05-G-max-数学，规律/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/G 给定c、n，求两个整数a、b，使得$gcd(a,b)=c, 1≤a,b≤n$","text":"链接：https://www.nowcoder.com/acm/contest/143/G 给定c、n，求两个整数a、b，使得$gcd(a,b)=c, 1≤a,b≤n$ 很容易发现只需要选择最接近n的c的倍数数、以及次接近n的c的倍数乘积就是最大的。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;LL c, n; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld\",&amp;c,&amp;n)) &#123; if(c &gt; n) &#123; printf(\"-1\\n\"); continue; &#125; if(c == 1) &#123; if(n == 1) printf(\"1\\n\"); else printf(\"%lld\\n\", n*(n-1)); continue; &#125; bool flag = 1; if(n == c) &#123; printf(\"%lld\\n\", c * c); continue; &#125; if(n % c == 0) printf(\"%lld\\n\", n*(n-c)); else &#123; LL t = n / c * c; if(t == c) printf(\"%lld\\n\", t*t); else printf(\"%lld\\n\", t*(t-c)); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"2018牛客多校05 A gpa (01分数规划)","slug":"2018牛客多校05-A-gpa-01分数规划","date":"2018-08-02T13:43:55.000Z","updated":"2018-08-06T16:27:44.968Z","comments":true,"path":"2018/08/02/2018牛客多校05-A-gpa-01分数规划/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/02/2018牛客多校05-A-gpa-01分数规划/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/A 一个人有n个成绩，然后现在他可以删掉其中至多k个，使得目标方程$\\frac{\\sum[s[i]c[i]}{\\sum s[i]}$的值最大，问这个值可以是多少。","text":"链接：https://www.nowcoder.com/acm/contest/143/A 一个人有n个成绩，然后现在他可以删掉其中至多k个，使得目标方程$\\frac{\\sum[s[i]c[i]}{\\sum s[i]}$的值最大，问这个值可以是多少。 这题和POJ2976是很类似的，是用01分数规划可以解决的问题。01分数规划可以看做是一种思想，可以用二分查找实现。针对这一道题，我们希望让目标方程尽可能大，于是可以假设：$$\\frac{\\sum[s[i]c[i]}{\\sum s[i]} \\geq L$$移项后得：$$\\sum{s_ic_i-L×s_i}\\geq0$$于是我们可以二分$L$，对该式中的$s_ic_i-L×s_i$进行计算并排序，删掉最小的k个后，查看是否满足题意。当收敛时，即$L$近似为式子的最大值。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std; const double eps = 1e-9;const int maxn = 101000;int n, k, m;int s[maxn], c[maxn];double d[maxn]; bool ok(double L) &#123; for(int i = 1; i &lt;= n; i++) d[i] = (double)(s[i] * c[i]) - L * (double)s[i]; sort(d+1, d+n+1); double tot = .0; for(int i = k+1; i &lt;= n; i++) &#123; tot += d[i]; &#125; return tot &gt; 0;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;s[i]); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;c[i]); double lo = .0, hi = 1e3; double ret = .0; while(hi - lo &gt; eps) &#123; double mid = (lo + hi) / 2.0; if(ok(mid)) lo = mid; else hi = mid; &#125; printf(\"%.11f\\n\", lo); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"},{"name":"01分数规划","slug":"01分数规划","permalink":"https://vincentxwd.github.io/blog/tags/01分数规划/"}]},{"title":"[Codeforces1006E] Military Problem(DFS)","slug":"Codeforces1006E-Military-Problem-DFS","date":"2018-08-01T15:40:55.000Z","updated":"2018-08-06T16:26:53.162Z","comments":true,"path":"2018/08/01/Codeforces1006E-Military-Problem-DFS/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1006E-Military-Problem-DFS/","excerpt":"链接：http://codeforces.com/contest/1006/problem/E 给一棵$n$个节点的树和$q$次询问，每次询问两个数$u、k$，表示第u个节点的第k个前序遍历的结果是谁。","text":"链接：http://codeforces.com/contest/1006/problem/E 给一棵$n$个节点的树和$q$次询问，每次询问两个数$u、k$，表示第u个节点的第k个前序遍历的结果是谁。 这么水的题竟然放在了E，可能这就是div 3吧… dfs一遍，维护出每个节点$i$的前序遍历的次序$ret_i$，以及该节点的子树中共计多少个节点$sz_i$，可以利用$ret_i$维护出第$j$号遍历的节点是$id_i$。当我们要求的某节点开始往后数$k$个数不存在时，输出-1；否则我们的答案就是$ret[id[u]+k-1]$。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200100;int n, q, tot;vector&lt;int&gt; G[maxn];int ret[maxn], sz[maxn], id[maxn];int dfs(int u, int p) &#123; ret[++tot] = u; int son = 1; for(int i = 0; i &lt; G[u].size(); i++) &#123; int &amp;v = G[u][i]; if(v == p) continue; son += dfs(v, u); &#125; return sz[u] = son;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int u, k; while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; tot = 0; memset(ret, -1, sizeof(ret)); memset(sz, 0, sizeof(sz)); for(int i = 1; i &lt;= n; i++) G[i].clear(); for(int i = 2; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;u); G[i].push_back(u); G[u].push_back(i); &#125; sz[1] = dfs(1, -1); for(int i = 1; i &lt;= n; i++) id[ret[i]] = i; while(q--) &#123; scanf(\"%d%d\",&amp;u,&amp;k); if(k - 1 &gt;= sz[u]) printf(\"-1\\n\"); else printf(\"%d\\n\", ret[id[u]+k-1]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://vincentxwd.github.io/blog/tags/DFS/"}]},{"title":"[Codeforces1006D] Two Strings Swaps(规律)","slug":"Codeforces1006D-Two-Strings-Swaps-规律","date":"2018-08-01T15:06:48.000Z","updated":"2018-08-06T16:26:49.073Z","comments":true,"path":"2018/08/01/Codeforces1006D-Two-Strings-Swaps-规律/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1006D-Two-Strings-Swaps-规律/","excerpt":"链接：http://codeforces.com/contest/1006/problem/D 给你两个字符串，定义三种操作。要求你事先给其中一个字符串替换某几个字符，然后再经过任一种上述操作变成两个一样的字符串，问预处理替换的字符最少要几个","text":"链接：http://codeforces.com/contest/1006/problem/D 给你两个字符串，定义三种操作。要求你事先给其中一个字符串替换某几个字符，然后再经过任一种上述操作变成两个一样的字符串，问预处理替换的字符最少要几个 一个很容易发现的规律就是每次处理的时候仅需要关心操作涉及的四个字符，然后再分类讨论一下就行了。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;char s[maxn], t[maxn];int n;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; scanf(\"%s%s\",s,t); int ret = 0; for(int i = 0; i &lt; n / 2; i++) &#123; map&lt;int, int&gt; a; a[s[i]]++; a[s[n-i-1]]++; a[t[i]]++; a[t[n-i-1]]++; if(a.size() == 4) ret += 2; else if(a.size() == 3) &#123; if(s[i] == s[n-i-1]) ret += 2; else ret++; &#125; else if(a.size() == 2) &#123; if(a[s[i]] != 2) ret++; &#125; &#125; if(n &amp; 1) &#123; if(s[n/2] != t[n/2]) ret++; &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"[Codeforces1015E(1,2)] Stars Drawing (贪心,暴力)","slug":"Codeforces1015E-1-2-Stars-Drawing-贪心-暴力","date":"2018-08-01T07:15:25.000Z","updated":"2018-08-06T16:27:05.517Z","comments":true,"path":"2018/08/01/Codeforces1015E-1-2-Stars-Drawing-贪心-暴力/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1015E-1-2-Stars-Drawing-贪心-暴力/","excerpt":"链接： http://codeforces.com/contest/1015/problem/E1 http://codeforces.com/contest/1015/problem/E2 给你一个$n×m$的矩阵，里面的*组成十字（至少要5个构成十字，比如5个的十字大小为1，一次类推），问这里面的*是否能都组成十字。并输出一个方案。","text":"链接： http://codeforces.com/contest/1015/problem/E1 http://codeforces.com/contest/1015/problem/E2 给你一个$n×m$的矩阵，里面的*组成十字（至少要5个构成十字，比如5个的十字大小为1，一次类推），问这里面的*是否能都组成十字。并输出一个方案。 这题暴力，贪心地让每一个*向四个方向延拓尽可能长的范围，并打好标记，存下所有可能的十字，看看这些标记里有没有是*但是为标记的就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1010;constexpr int dx[5] = &#123;0, 0, 1, -1&#125;;constexpr int dy[5] = &#123;1, -1, 0, 0&#125;;using Node = struct &#123; int x, y, v; &#125;;char G[maxn][maxn];bool vis[maxn][maxn];int n, m;vector&lt;Node&gt; p, ret;inline bool ok(int x, int y) &#123; return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;&#125;void gao(int x, int y) &#123; int tot = 1; bool flag = true; bool yes = false; while(flag) &#123; flag = false; int cnt = 0; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i] * tot; int ty = y + dy[i] * tot; if(ok(tx, ty) &amp;&amp; G[tx][ty] == '*') cnt++; &#125; if(cnt != 4) break; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i] * tot; int ty = y + dy[i] * tot; vis[tx][ty] = 1; &#125; flag = true; yes = true; tot++; &#125; if(yes) &#123; vis[x][y] = 1; ret.push_back(&#123;x+1, y+1, tot-1&#125;); &#125;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; p.clear(); ret.clear(); memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; i++) scanf(\"%s\", G[i]); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(G[i][j] == '*') p.push_back(&#123;i, j, 0&#125;); &#125; &#125; if(p.size() == 0) &#123; printf(\"0\\n\"); continue; &#125; for(auto t : p) gao(t.x, t.y); if(ret.size() == 0) &#123; printf(\"-1\\n\"); continue; &#125; bool flag = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(!vis[i][j] &amp;&amp; G[i][j] == '*') &#123; flag = 1; &#125; &#125; &#125; if(flag) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", ret.size()); for(auto t : ret) &#123; printf(\"%d %d %d\\n\", t.x, t.y, t.v); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"}]},{"title":"[Codeforces1015D] Walking Between Houses (构造)","slug":"Codeforces1015D-Walking-Between-Houses-构造","date":"2018-08-01T03:50:49.000Z","updated":"2018-08-06T16:27:02.676Z","comments":true,"path":"2018/08/01/Codeforces1015D-Walking-Between-Houses-构造/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1015D-Walking-Between-Houses-构造/","excerpt":"链接：http://codeforces.com/contest/1015/problem/D 有$1~n$个房子，一个人从$1$出发，每次可以走任意步，现在希望走$k$次，求一个方案，这$k$次能走够$s$步（走到一个房子的地方，下一次再走的时候要以那个地方为起点）。","text":"链接：http://codeforces.com/contest/1015/problem/D 有$1~n$个房子，一个人从$1$出发，每次可以走任意步，现在希望走$k$次，求一个方案，这$k$次能走够$s$步（走到一个房子的地方，下一次再走的时候要以那个地方为起点）。 提供两种构造方法： 1：首先尽可能多地走$n-1$步，然后再走$s-(k-1)$步，最后剩下的都走$1$步。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const LL maxn = 100100;LL n, k, s;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;k,&amp;s)) &#123; LL tot = (n - 1) * k; if(tot &lt; s) &#123; printf(\"NO\\n\"); continue; &#125; if(k &gt; s) &#123; printf(\"NO\\n\"); continue; &#125; LL cur = 1; vector&lt;LL&gt; ret; while(k) &#123; LL t = min(n - 1, s - (k - 1)); cur = cur - t &gt; 0 ? cur - t : cur + t; s -= t; k--; ret.push_back(cur); &#125; printf(\"YES\\n\"); for(int i = 0; i &lt; ret.size(); i++) &#123; printf(\"%lld%c\", ret[i], \" \\n\"[i==ret.size()-1]); &#125; &#125; return 0;&#125; 2：$p=\\frac{s}{k}$，$q=s%k$，走$q$个$p+1$步，$k-q$个$p$步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;LL n, k, s;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;k,&amp;s)) &#123; LL tot = (n - 1) * k; if(tot &lt; s) &#123; printf(\"NO\\n\"); continue; &#125; if(k &gt; s) &#123; printf(\"NO\\n\"); continue; &#125; LL p = s / k; LL q = s % k; vector&lt;LL&gt; ret; LL cur = 1; for(int i = 0; i &lt; q; i++) &#123; ret.push_back((i % 2 == 0) ? p+2 : 1); cur = (i % 2 == 0) ? p+2 : 1; &#125; if(cur == 1) &#123; for(int i = 0; i &lt; k - q; i++) &#123; cur += (i % 2 == 0) ? p : -p; ret.push_back(cur); &#125; &#125; else &#123; for(int i = 0; i &lt; k - q; i++) &#123; cur += (i % 2 == 0) ? -p : p; ret.push_back(cur); &#125; &#125; printf(\"YES\\n\"); for(int i = 0; i &lt; ret.size(); i++) &#123; printf(\"%lld%c\", ret[i], \" \\n\"[i==ret.size()-1]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"}]},{"title":"[Codeforces1013E] Hills(DP)","slug":"Codeforces1013E-Hills-DP","date":"2018-07-31T13:40:19.000Z","updated":"2018-08-06T16:26:57.075Z","comments":true,"path":"2018/07/31/Codeforces1013E-Hills-DP/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/31/Codeforces1013E-Hills-DP/","excerpt":"链接：http://codeforces.com/contest/1013/problem/E 给n个数，允许让每个数删减，现想要求k个严格的局部最大值，k取值为$[1,\\lceil\\frac{n}{2}\\rceil]$。","text":"链接：http://codeforces.com/contest/1013/problem/E 给n个数，允许让每个数删减，现想要求k个严格的局部最大值，k取值为$[1,\\lceil\\frac{n}{2}\\rceil]$。 这dp考的时候没想出来，可以这么做：$f(i,j,k)$表示前$i$个数里有$j$个最大值，此时还讨论第$i$个数是($k=1$)否($k=0$)是局部最大值。 状态转移如下： $k=0$时，$f(i,j,0)$可以更新到$f(i+1,j,0)$上，因为此时$i$和$i+1$都不是局部最大值，因此$j$不会变；或者更新到$f(i+1,j+1,1)$上，此时在$i+1$处为一个局部最大值。 $k=1$时，$f(i,k,1)$更新到$f(i+1,j,0)$上，但是相应地要有删减的代价；也可以更新到$f(i+2,j+1,1)$上，显然$i+1$处必然是一个极小值。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5050;const int inf = 0x7f7f7f7f;int n;int a[maxn];int f[maxn][maxn][2];int update(int x, int y) &#123; return x &gt; y ? 0 : y - x + 1;&#125;int main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; int K = (int)ceil(n / 2.0); memset(f, 0x7f, sizeof(f)); f[1][0][0] = 0; f[1][1][1] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= K; j++) &#123; for(int k = 0; k &lt;= 1; k++) &#123; if(f[i][j][k] == inf) continue; if(k == 0) &#123; f[i+1][j+1][1] = min(f[i+1][j+1][1], f[i][j][k] + update(a[i+1], a[i])); f[i+1][j][0] = min(f[i+1][j][0], f[i][j][k]); &#125; else &#123; f[i+2][j+1][1] = min(f[i+2][j+1][1], f[i][j][k] + update(min(a[i], a[i+2]), a[i+1])); f[i+1][j][0] = min(f[i+1][j][0], f[i][j][k] + update(a[i], a[i+1])); &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= K; i++) &#123; printf(\"%d%c\", min(f[n][i][0], f[n][i][1]), \" \\n\"[i==K]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[Codeforces1013] Round #500 (Div. 2) [based on EJOI]","slug":"CF1013-Codeforces-Round-500-Div-2-based-on-EJOI","date":"2018-07-30T12:54:12.000Z","updated":"2018-08-06T16:26:43.754Z","comments":true,"path":"2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","excerpt":"链接：http://codeforces.com/contest/1013","text":"链接：http://codeforces.com/contest/1013 A：n堆贝壳，第一天每一堆有ai个，现在可以拿走也可以移动任意个，然后给出第二天每一堆的贝壳的数量，问有没有可能。 两天的贝壳求和，如果不等就不可能。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 1111;int a, b;int n;signed main() &#123; // freopen(\"in\", \"r\", stdin); int t; while(~scanf(\"%d\", &amp;n)) &#123; a = 0, b = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;t); a += t; &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\" , &amp;t); b += t; &#125; if(a &gt;= b) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; B：给n个数ai，以及一个数x，现在允许x和ai进行与（&amp;）操作后替换ai，问最少操作多少次，n个数中出现两个相同的数字。 由于和x进行与操作后的结果再和x进行操作的结果不会变，因此每一个数至多和x与1次。考虑到结果只可能是-1 0 1 2，因此存下与操作后的数字结果，讨论一下就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 100100;int n, x;int a[maxn];int vis[maxn], vis1[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;x)) &#123; memset(vis, 0, sizeof(vis)); memset(vis1, 0, sizeof(vis1)); int maxx = -1; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); maxx = max(maxx, a[i]); vis[a[i]]++; vis1[a[i]&amp;x]++; maxx = max(maxx, a[i] &amp; x); &#125; int flag = 0; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis[i] &gt;= 2) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; puts(\"0\"); continue; &#125; flag = 0x7f7f7f7f; for(int i = 1; i &lt;= n; i++) &#123; if((a[i] &amp; x) == a[i]) &#123; if(vis1[a[i]] &gt;= 2) flag = min(flag, 1); &#125; else &#123; if(vis1[a[i]]) flag = min(flag, 1); &#125; &#125; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis1[i] &gt;= 2 &amp;&amp; !vis[i]) &#123; flag = min(flag, 2); &#125; &#125; if(flag == 0x7f7f7f7f) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", flag); &#125; return 0;&#125; C：给2n个数字，让你用这2n个数字构成n个二维平面上的点，要求是构造一个平行于坐标轴的、包括所有点的矩形，并且矩形面积最小（面积可以为0）。 很容易想到的是对a进行排序，之后将2n个数分为x坐标和y坐标两个集合，然后依次结合构成点。画图后发现答案就是两个集合的极差乘积，我们希望让这两个集合的极差尽可能小，因此每次从两个集合中拿出最小的放到对方的集合里，这里滑动窗口模拟一下就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;using LL = unsigned long long;const int maxn = 200100;int n;LL a[maxn];pair&lt;LL, LL&gt; p[maxn];map&lt;LL, int&gt; vis;deque&lt;LL&gt; r, q;multiset&lt;LL&gt; rr, qq;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; vis.clear(); for(int i = 1; i &lt;= 2 * n; i++) &#123; cin &gt;&gt; a[i]; vis[a[i]]++; &#125; sort(a+1, a+2*n+1); bool flag = 0; for(auto p : vis) &#123; if(p.second &gt;= n) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; printf(\"0\\n\"); continue; &#125; r.clear(); q.clear(); rr.clear(); qq.clear(); LL x, y; for(int i = 1; i &lt;= n; i++) &#123; r.push_back(a[i]); rr.insert(a[i]); &#125; for(int i = n+1; i &lt;= 2*n; i++) &#123; q.push_back(a[i]); qq.insert(a[i]); &#125; LL ret = 9223372036854775800LL; for(int i = 1; i &lt;= n; i++) &#123; ret = min(ret, ((*rr.rbegin())-(*rr.begin()))*((*qq.rbegin())-(*qq.begin()))); x = r.front(); y = q.front(); r.push_back(y); q.push_back(x); r.pop_front(); q.pop_front(); rr.erase(rr.lower_bound(x)), qq.erase(qq.lower_bound(y)); rr.insert(y); qq.insert(x); &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; return 0;&#125; D：要向一个n×m的矩阵里画叉，并且当三个叉构成如下图所示的操作： 当到左图的情况时，会如右图：①的位置会补上（也就是构成了一个矩形）。 现在给你一个n×m的矩阵，以及一些画了叉的位置，问你最少需要手动画多少个叉，能够利用上述操作将整个矩阵填满。 考虑一个叉都不画的情况，最少需要画n+m-1（就是画一个十字）就能利用上述操作将矩阵填满。 再来考虑这个操作的实质：比方说现在有了(x1,y1)、(x1,y2)、(x2,y1)三个点，那么第四个点(x2,y2)实际上是没有贡献的，如下图： 转换成森林上，希望把坐标这个森林连成一片，问最少要加多少条边。这样我们读入数据的时候，x和y连起来（为了区别x和y，y+n来做分层），当他们的父亲不一样的时候，说明这个连接是必须有的，记一次数。之后用n+m-1减掉这个必要的计数就行了。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;LL, LL&gt; pll;const int maxn = 4000100;int n, m, q;int pre[maxn];int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;int unite(int x, int y) &#123; x = find(x); y = find(y); if(x != y) &#123; pre[x] = y; return 1; &#125; return 0;&#125;int main() &#123; // freopen(\"in\", \"r\", stdin); int x, y; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q)) &#123; for(int i = 1; i &lt;= n + m; i++) &#123; pre[i] = i; &#125; int cnt = 0; for(int i = 0; i &lt; q; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); if(unite(x, y+n)) cnt++; &#125; printf(\"%d\\n\", n+m-1-cnt); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"并查集","slug":"并查集","permalink":"https://vincentxwd.github.io/blog/tags/并查集/"},{"name":"STL","slug":"STL","permalink":"https://vincentxwd.github.io/blog/tags/STL/"}]},{"title":"[Codeforces1011] Round #499 (Div. 2)","slug":"CF1011-Codeforces-Round-499-Div-2","date":"2018-07-29T13:01:44.000Z","updated":"2018-08-06T16:29:05.035Z","comments":true,"path":"2018/07/29/CF1011-Codeforces-Round-499-Div-2/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/29/CF1011-Codeforces-Round-499-Div-2/","excerpt":"用hexo搭了博客，以后就在这里写题解和随笔了。","text":"用hexo搭了博客，以后就在这里写题解和随笔了。 $$mathjax测试：C_i=\\sum_{j×k=i}A_j*B_k$$复健开了一场CF div2，感觉非常不好啊。。 比赛链接是http://codeforces.com/contest/1011 A：n个字符取k个，不能取字典序相邻的，也不能取相同的。就这样取，问最小的ascii-‘a’+1的和是多少。 贪心，给字符排个序，取第一个，然后后面的取最小的。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;char s[maxn];int n, k;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; scanf(\"%s\", s); sort(s, s+n); int pre = 0, ret = s[0] - 'a' + 1, tot = 1; for(int i = 1; i &lt; n; i++) &#123; if(tot &gt;= k) break; if(s[i] - s[pre] &gt; 1) &#123; ret += s[i] - 'a' + 1; pre = i; tot++; &#125; &#125; if(tot &lt; k) &#123; printf(\"-1\\n\"); &#125; else printf(\"%d\\n\", ret); &#125; return 0;&#125; B：n个人吃东西，一共m个东西，每个东西都有一类。每个人每天只能吃一个同一类东西，问怎么分配这m个东西，让这n个人吃得时间最久。 m很小，直接遍历天数day，然后贪心地check就ok了（数据量大了套个二分就行）。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;int n, m;int a[maxn], vis[maxn];int ok(int day) &#123; int tot = 0; for(int i = 0; i &lt; 101; i++) &#123; if(vis[i] &gt;= day) tot += (int)(vis[i] / (double)day); &#125; return tot &gt;= n;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; int lo = 0, hi = 100000; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;a[i]); vis[a[i]]++; &#125; if(n &gt; m) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0; for(int mid = 0; mid &lt; 101; mid++) &#123; if(ok(mid)) ret = mid; &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125; C：n个星球，一个人坐重量为m的飞船从1出发到n，需要走1-&gt;2-&gt;..-&gt;n-&gt;1这样的路径，从每个点起飞要消耗ai的燃油，在每个点降落要消耗bi的燃油，燃油只能从1上带，问这人要带多少燃油才能完成这个路径。 二分燃油的量，判断是否满足，或从1-&gt;n-&gt;n-1-&gt;…1逆推，上一次的燃油量是x*m/(x-1)，x为起飞or降落的消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const double eps = 1e-9;int n, m;double a[maxn], b[maxn];int ok(double fuel) &#123; double tot = fuel + m; for(int i = 1; i &lt;= n - 1; i++) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i+1]; &#125; for(int i = n; i &gt;= 2; i--) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i-1]; &#125; return tot - m &gt;= eps;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; &#125; double ret = m; for(int i = 1; i &lt; n; i++) &#123; ret = b[i] * ret / (b[i] - 1.0); ret = a[i+1] * ret / (a[i+1] - 1.0); &#125; ret = b[n] * ret / (b[n] - 1.0); ret = a[1] * ret / (a[1] - 1.0); ret -= m; if(ret &gt; 1e9) &#123; printf(\"-1\\n\"); &#125; else printf(\"%.10f\\n\", ret); &#125; return 0;&#125; D：猜一个1到m的数字x，可以询问最多60次。每次回答有可能是假的，假的情况那么会输出真答案判别的相反数（大于的时候返回1，如果假的情况就返回-1，小于同理），回答的真假情况序列p的长为n，回答按照这个序列循环返回结果。求这个数字x。 可以用数字1去试探n次（当然答案是1的时候可以直接结束程序了），把n次询问的真假情况预处理出来记下，之后就可以愉快地二分x，根据上面预处理出来的真假情况修改返回结果了。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;int p[maxn];int n, m;int query(int y) &#123; printf(\"%d\\n\", y); fflush(stdout); int t; scanf(\"%d\", &amp;t); if(t == 0 || t == 2) exit(0); return t;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;m,&amp;n)) &#123; memset(p, 0, sizeof(p)); for(int i = 0; i &lt; n; i++) &#123; int t = query(1); p[i] = (t == 1); &#125; int lo = 2, hi = m; for(int q = 0; ; q++) &#123; int mid = (lo + hi) &gt;&gt; 1; int t = query(mid); if(!p[q%n]) t = -t; if(t == 1) lo = mid + 1; else hi = mid - 1; &#125; &#125; return 0;&#125; E：n个数，每个数可以取任意次，相加后对k取模。求模的结果的个数。 统计k和每个数的gcd，答案就是k/gcd，依次取0,k/gcd,2k/gcd…就行了。过阵子尝试证明一下，相关概念有：有限域，生成元，生成多项式，循环群，裴蜀定理。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 100100;int n;LL k;LL a[maxn];bool vis[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%lld\",&amp;n,&amp;k)) &#123; memset(vis, 0, sizeof(vis)); LL x = k; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); x = __gcd(x, a[i]); &#125; printf(\"%lld\\n\", k / x); for(LL i = 0; i &lt; k; i+=x) &#123; printf(\"%lld \", i); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"},{"name":"交互题","slug":"交互题","permalink":"https://vincentxwd.github.io/blog/tags/交互题/"}]},{"title":"2018牛客多校01 J Different Integers","slug":"2018牛客多校01-J-Different-Integers","date":"2018-07-20T04:17:33.000Z","updated":"2018-08-06T16:26:01.847Z","comments":true,"path":"2018/07/20/2018牛客多校01-J-Different-Integers/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-J-Different-Integers/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/J n个数，q次查询l,r。求[1,l]和[r,n]中不同数的个数。","text":"链接：https://www.nowcoder.com/acm/contest/139/J n个数，q次查询l,r。求[1,l]和[r,n]中不同数的个数。 这题首先开二倍数组，然后在后n个位置重新存一遍这n个数，这样就相当于查询[r, n+l]内不同数的个数，用莫队或者bit离线计数都能做（代码是莫队）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std; inline bool scan_d(int &amp;num) &#123; char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!='-'&amp;&amp;(in&lt;'0'||in&gt;'9')) in=getchar(); if(in=='-')&#123; IsN=true;num=0;&#125; else num=in-'0'; while(in=getchar(),in&gt;='0'&amp;&amp;in&lt;='9')&#123; num*=10,num+=in-'0'; &#125; if(IsN) num=-num; return true;&#125; const int maxn = 100100;using Query = struct &#123; int l, r, ret, id; &#125;;int n, m;int a[maxn&lt;&lt;1], be[maxn&lt;&lt;1], L, R;Query q[maxn];int vis[maxn], sz; inline void add(int x, int &amp;ret) &#123; vis[x]++; if(vis[x] == 1) ret++;&#125; inline void remove(int x, int &amp;ret) &#123; vis[x]--; if(vis[x] == 0) ret--;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; sz = static_cast&lt;int&gt;(sqrt(n)); memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i++) &#123; scan_d(a[i]); a[n+i] = a[i]; be[i] = static_cast&lt;int&gt;(i / sz); be[i+n] = static_cast&lt;int&gt;((i + n) / sz); &#125; for(int i = 1; i &lt;= m; i++) &#123; scan_d(q[i].r); scan_d(q[i].l); q[i].r += n; q[i].id = i; &#125; sort(q+1, q+m+1, [](Query a, Query b) &#123; return be[a.l] == be[b.l] ? a.r &lt; b.r : a.l &lt; b.l; &#125;); int ret = 0; L = 1, R = 0; for(int i = 1; i &lt;= m; i++) &#123; while(L &lt; q[i].l) &#123; remove(a[L], ret); L++; &#125; while(L &gt; q[i].l) &#123; L--; add(a[L], ret); &#125; while(R &lt; q[i].r) &#123; R++; add(a[R], ret); &#125; while(R &gt; q[i].r) &#123; remove(a[R], ret); R--; &#125; q[i].ret = ret; &#125; sort(q+1, q+m+1, [](Query a, Query b)&#123; return a.id &lt; b.id; &#125;); for(int i = 1; i &lt;= m; i++) &#123; printf(\"%d\\n\", q[i].ret); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"莫队算法","slug":"莫队算法","permalink":"https://vincentxwd.github.io/blog/tags/莫队算法/"},{"name":"离线","slug":"离线","permalink":"https://vincentxwd.github.io/blog/tags/离线/"},{"name":"树状数组","slug":"树状数组","permalink":"https://vincentxwd.github.io/blog/tags/树状数组/"}]},{"title":"2018牛客多校01 D Two Graphs","slug":"2018牛客多校01-D-Two-Graphs","date":"2018-07-20T04:10:51.000Z","updated":"2018-08-06T16:25:57.318Z","comments":true,"path":"2018/07/20/2018牛客多校01-D-Two-Graphs/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-D-Two-Graphs/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/D 求G1的同构图，是G2的子图。","text":"链接：https://www.nowcoder.com/acm/contest/139/D 求G1的同构图，是G2的子图。 暴力枚举全排列，对于每一个排列，看看G2中是否每一条边都存在，然后再看看是否每一条边都在G1中存在（这里存在的话必然会重复计数），然后用上一个计数结果除以下一个即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn = 11;int n;int m1, m2;int id[maxn];int b[maxn][maxn], c[maxn][maxn];vector&lt;int&gt; a[maxn]; signed main() &#123; // freopen(\"in\", \"r\", stdin); int x, y; while(~scanf(\"%d%d%d\",&amp;n,&amp;m1,&amp;m2)) &#123; for(int i = 1; i &lt;= n; i++) &#123; a[i].clear(); &#125; memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); for(int i = 1; i &lt;= m1; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); a[x].push_back(y); a[y].push_back(x); c[x][y] = c[y][x] = 1; &#125; for(int i = 1; i &lt;= m2; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); b[x][y] = b[y][x] = 1; &#125; for(int i = 1; i &lt;= n; i++) &#123; id[i] = i; &#125; if(m1 &gt; m2) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0, tot = 0; do &#123; int flag = 1; for(x = 1; x &lt;= n; x++) &#123; for(int j = 0; j &lt; a[x].size(); j++) &#123; y = a[x][j]; if(!b[id[x]][id[y]]) &#123; flag = 0; break; &#125; &#125; &#125; if(flag) ret++; flag = 1; for(x = 1; x &lt;= n; x++) &#123; for(int j = 0; j &lt; a[x].size(); j++) &#123; y = a[x][j]; if(!c[id[x]][id[y]]) &#123; flag = 0; break; &#125; &#125; &#125; if(flag) tot++; &#125;while(next_permutation(id+1, id+n+1)); printf(\"%d\\n\", ret / tot); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"枚举","slug":"枚举","permalink":"https://vincentxwd.github.io/blog/tags/枚举/"}]},{"title":"2018牛客多校01 A Monotonic Matrix","slug":"2018牛客多校01-A-Monotonic-Matrix","date":"2018-07-20T03:54:47.000Z","updated":"2018-08-06T16:28:15.918Z","comments":true,"path":"2018/07/20/2018牛客多校01-A-Monotonic-Matrix/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-A-Monotonic-Matrix/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/A 求一个n*m的0、1、2矩阵（满足左上小于右下）的构造方案数。","text":"链接：https://www.nowcoder.com/acm/contest/139/A 求一个n*m的0、1、2矩阵（满足左上小于右下）的构造方案数。 方案数就等于这两条可以重合（不可相交）的分界线的种类数，如下图： 即：给定起点(n,0)、终点(0,m)，只能向上和向右走，问有多少种走法，其实就是向右走m步向上走n步的组合数：$$C_{n+m}^m或C_{n+m}^n$$这里给出Lindström–Gessel–Viennot引理的应用：给一张无权有向无环图，给定n个起点和对应的n个终点，求n条不相交路径的方案数，引理给出结果为： 其中$a_{i}$表示路径i的起点，$b_{i}$表示路径i的终点。答案就是M的行列式的值。 对于本两条线的起点和终点不能重叠而且得和原方案等价（方案数等价即可），这就需要变换一下。把起终点向左上平移一下，将其中的一对起终点平移到$(n-1,-1)$和$(-1,m-1)$去，就有$e(a_1,b_1)=e(a_2,b_2)=C_{n+m}^n$，$e(a_1,b_2)=C_{n+m}^{n+1}$，$e(a_2,b_1)=C_{n+m}^{m+1}$那么针对本题的答案就是：$${C_{n+m}^n}^2-C_{n+m}^{n+1}×C_{n+m}^{m+1}$$ 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;const LL mod = 1e9+7;const int maxn = 3010;int n, m;LL c[maxn][maxn]; void init() &#123; memset(c,0,sizeof(c)); c[0][0]=c[1][0]=c[1][1]=1; for(int i = 2; i &lt; maxn; i++) &#123; c[i][0] = c[i][i] = 1; for(int j = 1; j &lt; i; j++) &#123; c[i][j] = c[i-1][j] + c[i-1][j-1]; c[i][j] %= mod; &#125; &#125;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); init(); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; LL ret = c[n+m][n]*c[n+m][n]; ret %= mod; LL tmp = c[n+m][n+1]*c[n+m][m+1]; tmp %= mod; ret -= tmp; ret += mod; ret %= mod; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"}]}]}