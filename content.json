{"meta":{"title":"Kirai","subtitle":"我好菜啊 QAQ | I Good Vegetable A QAQ","description":null,"author":"Kirai","url":"https://vincentxwd.github.io/blog"},"pages":[{"title":"404","date":"2018-07-29T11:33:50.000Z","updated":"2018-07-29T11:33:50.336Z","comments":true,"path":"404/index.html","permalink":"https://vincentxwd.github.io/blog/404/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-29T12:57:51.000Z","updated":"2018-07-31T04:26:10.039Z","comments":true,"path":"categories/index.html","permalink":"https://vincentxwd.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-07-30T05:59:54.000Z","updated":"2018-07-31T04:32:18.100Z","comments":true,"path":"about/index.html","permalink":"https://vincentxwd.github.io/blog/about/index.html","excerpt":"","text":"kirai，在读渣硕，方向是ML和CV。竞赛败犬，科研萌新，喜欢打osu! mania。 如果您在招实习，点击这里可能会多了解一点QAQ。 有问题可以邮箱联系，也可以QQ：107850580。"},{"title":"标签","date":"2018-07-29T12:56:26.000Z","updated":"2018-07-30T07:02:56.361Z","comments":true,"path":"tags/index.html","permalink":"https://vincentxwd.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2018-07-29T11:33:36.000Z","updated":"2018-07-30T07:00:53.427Z","comments":true,"path":"search/index.html","permalink":"https://vincentxwd.github.io/blog/search/index.html","excerpt":"","text":""}],"posts":[{"title":"Codeforces1015E(1,2) Stars Drawing (贪心,暴力)","slug":"Codeforces1015E-1-2-Stars-Drawing-贪心-暴力","date":"2018-08-01T07:15:25.000Z","updated":"2018-08-01T07:43:33.592Z","comments":true,"path":"2018/08/01/Codeforces1015E-1-2-Stars-Drawing-贪心-暴力/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1015E-1-2-Stars-Drawing-贪心-暴力/","excerpt":"链接： http://codeforces.com/contest/1015/problem/E1 http://codeforces.com/contest/1015/problem/E2 给你一个$n×m$的矩阵，里面的*组成十字（至少要5个构成十字，比如5个的十字大小为1，一次类推），问这里面的*是否能都组成十字。并输出一个方案。","text":"链接： http://codeforces.com/contest/1015/problem/E1 http://codeforces.com/contest/1015/problem/E2 给你一个$n×m$的矩阵，里面的*组成十字（至少要5个构成十字，比如5个的十字大小为1，一次类推），问这里面的*是否能都组成十字。并输出一个方案。 这题暴力，贪心地让每一个*向四个方向延拓尽可能长的范围，并打好标记，存下所有可能的十字，看看这些标记里有没有是*但是为标记的就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1010;constexpr int dx[5] = &#123;0, 0, 1, -1&#125;;constexpr int dy[5] = &#123;1, -1, 0, 0&#125;;using Node = struct &#123; int x, y, v; &#125;;char G[maxn][maxn];bool vis[maxn][maxn];int n, m;vector&lt;Node&gt; p, ret;inline bool ok(int x, int y) &#123; return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;&#125;void gao(int x, int y) &#123; int tot = 1; bool flag = true; bool yes = false; while(flag) &#123; flag = false; int cnt = 0; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i] * tot; int ty = y + dy[i] * tot; if(ok(tx, ty) &amp;&amp; G[tx][ty] == '*') cnt++; &#125; if(cnt != 4) break; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i] * tot; int ty = y + dy[i] * tot; vis[tx][ty] = 1; &#125; flag = true; yes = true; tot++; &#125; if(yes) &#123; vis[x][y] = 1; ret.push_back(&#123;x+1, y+1, tot-1&#125;); &#125;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; p.clear(); ret.clear(); memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; i++) scanf(\"%s\", G[i]); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(G[i][j] == '*') p.push_back(&#123;i, j, 0&#125;); &#125; &#125; if(p.size() == 0) &#123; printf(\"0\\n\"); continue; &#125; for(auto t : p) gao(t.x, t.y); if(ret.size() == 0) &#123; printf(\"-1\\n\"); continue; &#125; bool flag = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(!vis[i][j] &amp;&amp; G[i][j] == '*') &#123; flag = 1; &#125; &#125; &#125; if(flag) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", ret.size()); for(auto t : ret) &#123; printf(\"%d %d %d\\n\", t.x, t.y, t.v); &#125; &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"}]},{"title":"[Codeforces1015D] Walking Between Houses (构造)","slug":"Codeforces1015D-Walking-Between-Houses-构造","date":"2018-08-01T03:50:49.000Z","updated":"2018-08-01T07:43:22.458Z","comments":true,"path":"2018/08/01/Codeforces1015D-Walking-Between-Houses-构造/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1015D-Walking-Between-Houses-构造/","excerpt":"链接：http://codeforces.com/contest/1015/problem/D 有$1~n$个房子，一个人从$1$出发，每次可以走任意步，现在希望走$k$次，求一个方案，这$k$次能走够$s$步（走到一个房子的地方，下一次再走的时候要以那个地方为起点）。","text":"链接：http://codeforces.com/contest/1015/problem/D 有$1~n$个房子，一个人从$1$出发，每次可以走任意步，现在希望走$k$次，求一个方案，这$k$次能走够$s$步（走到一个房子的地方，下一次再走的时候要以那个地方为起点）。 提供两种构造方法： 1：首先尽可能多地走$n-1$步，然后再走$s-(k-1)$步，最后剩下的都走$1$步。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const LL maxn = 100100;LL n, k, s;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;k,&amp;s)) &#123; LL tot = (n - 1) * k; if(tot &lt; s) &#123; printf(\"NO\\n\"); continue; &#125; if(k &gt; s) &#123; printf(\"NO\\n\"); continue; &#125; LL cur = 1; vector&lt;LL&gt; ret; while(k) &#123; LL t = min(n - 1, s - (k - 1)); cur = cur - t &gt; 0 ? cur - t : cur + t; s -= t; k--; ret.push_back(cur); &#125; printf(\"YES\\n\"); for(int i = 0; i &lt; ret.size(); i++) &#123; printf(\"%lld%c\", ret[i], \" \\n\"[i==ret.size()-1]); &#125; &#125; return 0;&#125; 2：$p=\\frac{s}{k}$，$q=s%k$，走$q$个$p+1$步，$k-q$个$p$步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;LL n, k, s;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;k,&amp;s)) &#123; LL tot = (n - 1) * k; if(tot &lt; s) &#123; printf(\"NO\\n\"); continue; &#125; if(k &gt; s) &#123; printf(\"NO\\n\"); continue; &#125; LL p = s / k; LL q = s % k; vector&lt;LL&gt; ret; LL cur = 1; for(int i = 0; i &lt; q; i++) &#123; ret.push_back((i % 2 == 0) ? p+2 : 1); cur = (i % 2 == 0) ? p+2 : 1; &#125; if(cur == 1) &#123; for(int i = 0; i &lt; k - q; i++) &#123; cur += (i % 2 == 0) ? p : -p; ret.push_back(cur); &#125; &#125; else &#123; for(int i = 0; i &lt; k - q; i++) &#123; cur += (i % 2 == 0) ? -p : p; ret.push_back(cur); &#125; &#125; printf(\"YES\\n\"); for(int i = 0; i &lt; ret.size(); i++) &#123; printf(\"%lld%c\", ret[i], \" \\n\"[i==ret.size()-1]); &#125; &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"}]},{"title":"[Codeforces1013E] Hills(DP)","slug":"Codeforces1013E-Hills-DP","date":"2018-07-31T13:40:19.000Z","updated":"2018-08-01T07:43:12.633Z","comments":true,"path":"2018/07/31/Codeforces1013E-Hills-DP/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/31/Codeforces1013E-Hills-DP/","excerpt":"链接：http://codeforces.com/contest/1013/problem/E 给n个数，允许让每个数删减，现想要求k个严格的局部最大值，k取值为$[1,\\lceil\\frac{n}{2}\\rceil]$。","text":"链接：http://codeforces.com/contest/1013/problem/E 给n个数，允许让每个数删减，现想要求k个严格的局部最大值，k取值为$[1,\\lceil\\frac{n}{2}\\rceil]$。 这dp考的时候没想出来，可以这么做：$f(i,j,k)$表示前$i$个数里有$j$个最大值，此时还讨论第$i$个数是($k=1$)否($k=0$)是局部最大值。 状态转移如下： $k=0$时，$f(i,j,0)$可以更新到$f(i+1,j,0)$上，因为此时$i$和$i+1$都不是局部最大值，因此$j$不会变；或者更新到$f(i+1,j+1,1)$上，此时在$i+1$处为一个局部最大值。 $k=1$时，$f(i,k,1)$更新到$f(i+1,j,0)$上，但是相应地要有删减的代价；也可以更新到$f(i+2,j+1,1)$上，显然$i+1$处必然是一个极小值。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5050;const int inf = 0x7f7f7f7f;int n;int a[maxn];int f[maxn][maxn][2];int update(int x, int y) &#123; return x &gt; y ? 0 : y - x + 1;&#125;int main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; int K = (int)ceil(n / 2.0); memset(f, 0x7f, sizeof(f)); f[1][0][0] = 0; f[1][1][1] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= K; j++) &#123; for(int k = 0; k &lt;= 1; k++) &#123; if(f[i][j][k] == inf) continue; if(k == 0) &#123; f[i+1][j+1][1] = min(f[i+1][j+1][1], f[i][j][k] + update(a[i+1], a[i])); f[i+1][j][0] = min(f[i+1][j][0], f[i][j][k]); &#125; else &#123; f[i+2][j+1][1] = min(f[i+2][j+1][1], f[i][j][k] + update(min(a[i], a[i+2]), a[i+1])); f[i+1][j][0] = min(f[i+1][j][0], f[i][j][k] + update(a[i], a[i+1])); &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= K; i++) &#123; printf(\"%d%c\", min(f[n][i][0], f[n][i][1]), \" \\n\"[i==K]); &#125; &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[CF1013] Codeforces Round #500 (Div. 2) [based on EJOI]","slug":"CF1013-Codeforces-Round-500-Div-2-based-on-EJOI","date":"2018-07-30T12:54:12.000Z","updated":"2018-08-01T07:43:04.128Z","comments":true,"path":"2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","excerpt":"链接：http://codeforces.com/contest/1013","text":"链接：http://codeforces.com/contest/1013 A：n堆贝壳，第一天每一堆有ai个，现在可以拿走也可以移动任意个，然后给出第二天每一堆的贝壳的数量，问有没有可能。 两天的贝壳求和，如果不等就不可能。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 1111;int a, b;int n;signed main() &#123; // freopen(\"in\", \"r\", stdin); int t; while(~scanf(\"%d\", &amp;n)) &#123; a = 0, b = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;t); a += t; &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\" , &amp;t); b += t; &#125; if(a &gt;= b) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; B：给n个数ai，以及一个数x，现在允许x和ai进行与（&amp;）操作后替换ai，问最少操作多少次，n个数中出现两个相同的数字。 由于和x进行与操作后的结果再和x进行操作的结果不会变，因此每一个数至多和x与1次。考虑到结果只可能是-1 0 1 2，因此存下与操作后的数字结果，讨论一下就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 100100;int n, x;int a[maxn];int vis[maxn], vis1[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;x)) &#123; memset(vis, 0, sizeof(vis)); memset(vis1, 0, sizeof(vis1)); int maxx = -1; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); maxx = max(maxx, a[i]); vis[a[i]]++; vis1[a[i]&amp;x]++; maxx = max(maxx, a[i] &amp; x); &#125; int flag = 0; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis[i] &gt;= 2) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; puts(\"0\"); continue; &#125; flag = 0x7f7f7f7f; for(int i = 1; i &lt;= n; i++) &#123; if((a[i] &amp; x) == a[i]) &#123; if(vis1[a[i]] &gt;= 2) flag = min(flag, 1); &#125; else &#123; if(vis1[a[i]]) flag = min(flag, 1); &#125; &#125; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis1[i] &gt;= 2 &amp;&amp; !vis[i]) &#123; flag = min(flag, 2); &#125; &#125; if(flag == 0x7f7f7f7f) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", flag); &#125; return 0;&#125; C：给2n个数字，让你用这2n个数字构成n个二维平面上的点，要求是构造一个平行于坐标轴的、包括所有点的矩形，并且矩形面积最小（面积可以为0）。 很容易想到的是对a进行排序，之后将2n个数分为x坐标和y坐标两个集合，然后依次结合构成点。画图后发现答案就是两个集合的极差乘积，我们希望让这两个集合的极差尽可能小，因此每次从两个集合中拿出最小的放到对方的集合里，这里滑动窗口模拟一下就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;using LL = unsigned long long;const int maxn = 200100;int n;LL a[maxn];pair&lt;LL, LL&gt; p[maxn];map&lt;LL, int&gt; vis;deque&lt;LL&gt; r, q;multiset&lt;LL&gt; rr, qq;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; vis.clear(); for(int i = 1; i &lt;= 2 * n; i++) &#123; cin &gt;&gt; a[i]; vis[a[i]]++; &#125; sort(a+1, a+2*n+1); bool flag = 0; for(auto p : vis) &#123; if(p.second &gt;= n) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; printf(\"0\\n\"); continue; &#125; r.clear(); q.clear(); rr.clear(); qq.clear(); LL x, y; for(int i = 1; i &lt;= n; i++) &#123; r.push_back(a[i]); rr.insert(a[i]); &#125; for(int i = n+1; i &lt;= 2*n; i++) &#123; q.push_back(a[i]); qq.insert(a[i]); &#125; LL ret = 9223372036854775800LL; for(int i = 1; i &lt;= n; i++) &#123; ret = min(ret, ((*rr.rbegin())-(*rr.begin()))*((*qq.rbegin())-(*qq.begin()))); x = r.front(); y = q.front(); r.push_back(y); q.push_back(x); r.pop_front(); q.pop_front(); rr.erase(rr.lower_bound(x)), qq.erase(qq.lower_bound(y)); rr.insert(y); qq.insert(x); &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; return 0;&#125; D：要向一个n×m的矩阵里画叉，并且当三个叉构成如下图所示的操作： 当到左图的情况时，会如右图：①的位置会补上（也就是构成了一个矩形）。 现在给你一个n×m的矩阵，以及一些画了叉的位置，问你最少需要手动画多少个叉，能够利用上述操作将整个矩阵填满。 考虑一个叉都不画的情况，最少需要画n+m-1（就是画一个十字）就能利用上述操作将矩阵填满。 再来考虑这个操作的实质：比方说现在有了(x1,y1)、(x1,y2)、(x2,y1)三个点，那么第四个点(x2,y2)实际上是没有贡献的，如下图： 转换成森林上，希望把坐标这个森林连成一片，问最少要加多少条边。这样我们读入数据的时候，x和y连起来（为了区别x和y，y+n来做分层），当他们的父亲不一样的时候，说明这个连接是必须有的，记一次数。之后用n+m-1减掉这个必要的计数就行了。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;LL, LL&gt; pll;const int maxn = 4000100;int n, m, q;int pre[maxn];int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;int unite(int x, int y) &#123; x = find(x); y = find(y); if(x != y) &#123; pre[x] = y; return 1; &#125; return 0;&#125;int main() &#123; // freopen(\"in\", \"r\", stdin); int x, y; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q)) &#123; for(int i = 1; i &lt;= n + m; i++) &#123; pre[i] = i; &#125; int cnt = 0; for(int i = 0; i &lt; q; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); if(unite(x, y+n)) cnt++; &#125; printf(\"%d\\n\", n+m-1-cnt); &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"并查集","slug":"并查集","permalink":"https://vincentxwd.github.io/blog/tags/并查集/"},{"name":"STL","slug":"STL","permalink":"https://vincentxwd.github.io/blog/tags/STL/"}]},{"title":"[CF1011] Codeforces Round #499 (Div. 2)","slug":"CF1011-Codeforces-Round-499-Div-2","date":"2018-07-29T13:01:44.000Z","updated":"2018-08-01T07:42:59.690Z","comments":true,"path":"2018/07/29/CF1011-Codeforces-Round-499-Div-2/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/29/CF1011-Codeforces-Round-499-Div-2/","excerpt":"用hexo搭了博客，以后就在这里写题解和随笔了。","text":"用hexo搭了博客，以后就在这里写题解和随笔了。 $$mathjax测试：C_i=\\sum_{j×k=i}A_j*B_k$$复健开了一场CF div2，感觉非常不好啊。。 比赛链接是http://codeforces.com/contest/1011 A：n个字符取k个，不能取字典序相邻的，也不能取相同的。就这样取，问最小的ascii-‘a’+1的和是多少。 贪心，给字符排个序，取第一个，然后后面的取最小的。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;char s[maxn];int n, k;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; scanf(\"%s\", s); sort(s, s+n); int pre = 0, ret = s[0] - 'a' + 1, tot = 1; for(int i = 1; i &lt; n; i++) &#123; if(tot &gt;= k) break; if(s[i] - s[pre] &gt; 1) &#123; ret += s[i] - 'a' + 1; pre = i; tot++; &#125; &#125; if(tot &lt; k) &#123; printf(\"-1\\n\"); &#125; else printf(\"%d\\n\", ret); &#125; return 0;&#125; B：n个人吃东西，一共m个东西，每个东西都有一类。每个人每天只能吃一个同一类东西，问怎么分配这m个东西，让这n个人吃得时间最久。 m很小，直接遍历天数day，然后贪心地check就ok了（数据量大了套个二分就行）。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;int n, m;int a[maxn], vis[maxn];int ok(int day) &#123; int tot = 0; for(int i = 0; i &lt; 101; i++) &#123; if(vis[i] &gt;= day) tot += (int)(vis[i] / (double)day); &#125; return tot &gt;= n;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; int lo = 0, hi = 100000; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;a[i]); vis[a[i]]++; &#125; if(n &gt; m) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0; for(int mid = 0; mid &lt; 101; mid++) &#123; if(ok(mid)) ret = mid; &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125; C：n个星球，一个人坐重量为m的飞船从1出发到n，需要走1-&gt;2-&gt;..-&gt;n-&gt;1这样的路径，从每个点起飞要消耗ai的燃油，在每个点降落要消耗bi的燃油，燃油只能从1上带，问这人要带多少燃油才能完成这个路径。 二分燃油的量，判断是否满足，或从1-&gt;n-&gt;n-1-&gt;…1逆推，上一次的燃油量是x*m/(x-1)，x为起飞or降落的消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const double eps = 1e-9;int n, m;double a[maxn], b[maxn];int ok(double fuel) &#123; double tot = fuel + m; for(int i = 1; i &lt;= n - 1; i++) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i+1]; &#125; for(int i = n; i &gt;= 2; i--) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i-1]; &#125; return tot - m &gt;= eps;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; &#125; double ret = m; for(int i = 1; i &lt; n; i++) &#123; ret = b[i] * ret / (b[i] - 1.0); ret = a[i+1] * ret / (a[i+1] - 1.0); &#125; ret = b[n] * ret / (b[n] - 1.0); ret = a[1] * ret / (a[1] - 1.0); ret -= m; if(ret &gt; 1e9) &#123; printf(\"-1\\n\"); &#125; else printf(\"%.10f\\n\", ret); &#125; return 0;&#125; D：猜一个1到m的数字x，可以询问最多60次。每次回答有可能是假的，假的情况那么会输出真答案判别的相反数（大于的时候返回1，如果假的情况就返回-1，小于同理），回答的真假情况序列p的长为n，回答按照这个序列循环返回结果。求这个数字x。 可以用数字1去试探n次（当然答案是1的时候可以直接结束程序了），把n次询问的真假情况预处理出来记下，之后就可以愉快地二分x，根据上面预处理出来的真假情况修改返回结果了。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;int p[maxn];int n, m;int query(int y) &#123; printf(\"%d\\n\", y); fflush(stdout); int t; scanf(\"%d\", &amp;t); if(t == 0 || t == 2) exit(0); return t;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;m,&amp;n)) &#123; memset(p, 0, sizeof(p)); for(int i = 0; i &lt; n; i++) &#123; int t = query(1); p[i] = (t == 1); &#125; int lo = 2, hi = m; for(int q = 0; ; q++) &#123; int mid = (lo + hi) &gt;&gt; 1; int t = query(mid); if(!p[q%n]) t = -t; if(t == 1) lo = mid + 1; else hi = mid - 1; &#125; &#125; return 0;&#125; E：n个数，每个数可以取任意次，相加后对k取模。求模的结果的个数。 统计k和每个数的gcd，答案就是k/gcd，依次取0,k/gcd,2k/gcd…就行了。过阵子尝试证明一下，相关概念有：有限域，生成元，生成多项式，循环群，裴蜀定理。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 100100;int n;LL k;LL a[maxn];bool vis[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%lld\",&amp;n,&amp;k)) &#123; memset(vis, 0, sizeof(vis)); LL x = k; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); x = __gcd(x, a[i]); &#125; printf(\"%lld\\n\", k / x); for(LL i = 0; i &lt; k; i+=x) &#123; printf(\"%lld \", i); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"},{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"},{"name":"交互题","slug":"交互题","permalink":"https://vincentxwd.github.io/blog/tags/交互题/"}]},{"title":"2018牛客多校01 J Different Integers","slug":"2018牛客多校01-J-Different-Integers","date":"2018-07-20T04:17:33.000Z","updated":"2018-08-01T07:42:55.755Z","comments":true,"path":"2018/07/20/2018牛客多校01-J-Different-Integers/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-J-Different-Integers/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/J n个数，q次查询l,r。求[1,l]和[r,n]中不同数的个数。","text":"链接：https://www.nowcoder.com/acm/contest/139/J n个数，q次查询l,r。求[1,l]和[r,n]中不同数的个数。 这题首先开二倍数组，然后在后n个位置重新存一遍这n个数，这样就相当于查询[r, n+l]内不同数的个数，用莫队或者bit离线计数都能做（代码是莫队）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std; inline bool scan_d(int &amp;num) &#123; char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!='-'&amp;&amp;(in&lt;'0'||in&gt;'9')) in=getchar(); if(in=='-')&#123; IsN=true;num=0;&#125; else num=in-'0'; while(in=getchar(),in&gt;='0'&amp;&amp;in&lt;='9')&#123; num*=10,num+=in-'0'; &#125; if(IsN) num=-num; return true;&#125; const int maxn = 100100;using Query = struct &#123; int l, r, ret, id; &#125;;int n, m;int a[maxn&lt;&lt;1], be[maxn&lt;&lt;1], L, R;Query q[maxn];int vis[maxn], sz; inline void add(int x, int &amp;ret) &#123; vis[x]++; if(vis[x] == 1) ret++;&#125; inline void remove(int x, int &amp;ret) &#123; vis[x]--; if(vis[x] == 0) ret--;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; sz = static_cast&lt;int&gt;(sqrt(n)); memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i++) &#123; scan_d(a[i]); a[n+i] = a[i]; be[i] = static_cast&lt;int&gt;(i / sz); be[i+n] = static_cast&lt;int&gt;((i + n) / sz); &#125; for(int i = 1; i &lt;= m; i++) &#123; scan_d(q[i].r); scan_d(q[i].l); q[i].r += n; q[i].id = i; &#125; sort(q+1, q+m+1, [](Query a, Query b) &#123; return be[a.l] == be[b.l] ? a.r &lt; b.r : a.l &lt; b.l; &#125;); int ret = 0; L = 1, R = 0; for(int i = 1; i &lt;= m; i++) &#123; while(L &lt; q[i].l) &#123; remove(a[L], ret); L++; &#125; while(L &gt; q[i].l) &#123; L--; add(a[L], ret); &#125; while(R &lt; q[i].r) &#123; R++; add(a[R], ret); &#125; while(R &gt; q[i].r) &#123; remove(a[R], ret); R--; &#125; q[i].ret = ret; &#125; sort(q+1, q+m+1, [](Query a, Query b)&#123; return a.id &lt; b.id; &#125;); for(int i = 1; i &lt;= m; i++) &#123; printf(\"%d\\n\", q[i].ret); &#125; &#125; return 0;&#125;","categories":[{"name":"2018牛客多校01","slug":"2018牛客多校01","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校01/"}],"tags":[{"name":"莫队算法","slug":"莫队算法","permalink":"https://vincentxwd.github.io/blog/tags/莫队算法/"},{"name":"离线","slug":"离线","permalink":"https://vincentxwd.github.io/blog/tags/离线/"},{"name":"树状数组","slug":"树状数组","permalink":"https://vincentxwd.github.io/blog/tags/树状数组/"}]},{"title":"2018牛客多校01 D Two Graphs","slug":"2018牛客多校01-D-Two-Graphs","date":"2018-07-20T04:10:51.000Z","updated":"2018-08-01T07:42:49.783Z","comments":true,"path":"2018/07/20/2018牛客多校01-D-Two-Graphs/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-D-Two-Graphs/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/D 求G1的同构图，是G2的子图。","text":"链接：https://www.nowcoder.com/acm/contest/139/D 求G1的同构图，是G2的子图。 暴力枚举全排列，对于每一个排列，看看G2中是否每一条边都存在，然后再看看是否每一条边都在G1中存在（这里存在的话必然会重复计数），然后用上一个计数结果除以下一个即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn = 11;int n;int m1, m2;int id[maxn];int b[maxn][maxn], c[maxn][maxn];vector&lt;int&gt; a[maxn]; signed main() &#123; // freopen(\"in\", \"r\", stdin); int x, y; while(~scanf(\"%d%d%d\",&amp;n,&amp;m1,&amp;m2)) &#123; for(int i = 1; i &lt;= n; i++) &#123; a[i].clear(); &#125; memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); for(int i = 1; i &lt;= m1; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); a[x].push_back(y); a[y].push_back(x); c[x][y] = c[y][x] = 1; &#125; for(int i = 1; i &lt;= m2; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); b[x][y] = b[y][x] = 1; &#125; for(int i = 1; i &lt;= n; i++) &#123; id[i] = i; &#125; if(m1 &gt; m2) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0, tot = 0; do &#123; int flag = 1; for(x = 1; x &lt;= n; x++) &#123; for(int j = 0; j &lt; a[x].size(); j++) &#123; y = a[x][j]; if(!b[id[x]][id[y]]) &#123; flag = 0; break; &#125; &#125; &#125; if(flag) ret++; flag = 1; for(x = 1; x &lt;= n; x++) &#123; for(int j = 0; j &lt; a[x].size(); j++) &#123; y = a[x][j]; if(!c[id[x]][id[y]]) &#123; flag = 0; break; &#125; &#125; &#125; if(flag) tot++; &#125;while(next_permutation(id+1, id+n+1)); printf(\"%d\\n\", ret / tot); &#125; return 0;&#125;","categories":[{"name":"2018牛客多校01","slug":"2018牛客多校01","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校01/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"枚举","slug":"枚举","permalink":"https://vincentxwd.github.io/blog/tags/枚举/"}]},{"title":"2018牛客多校01 A Monotonic Matrix","slug":"2018牛客多校01-A-Monotonic-Matrix","date":"2018-07-20T03:54:47.000Z","updated":"2018-08-01T07:43:41.276Z","comments":true,"path":"2018/07/20/2018牛客多校01-A-Monotonic-Matrix/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-A-Monotonic-Matrix/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/A 求一个n*m的0、1、2矩阵（满足左上小于右下）的构造方案数。","text":"链接：https://www.nowcoder.com/acm/contest/139/A 求一个n*m的0、1、2矩阵（满足左上小于右下）的构造方案数。 方案数就等于这两条可以重合（不可相交）的分界线的种类数，如下图： 即：给定起点(n,0)、终点(0,m)，只能向上和向右走，问有多少种走法，其实就是向右走m步向上走n步的组合数：$$C_{n+m}^m或C_{n+m}^n$$这里给出Lindström–Gessel–Viennot引理的应用：给一张无权有向无环图，给定n个起点和对应的n个终点，求n条不相交路径的方案数，引理给出结果为： 其中$a_{i}$表示路径i的起点，$b_{i}$表示路径i的终点。答案就是M的行列式的值。 对于本两条线的起点和终点不能重叠而且得和原方案等价（方案数等价即可），这就需要变换一下。把起终点向左上平移一下，将其中的一对起终点平移到$(n-1,-1)$和$(-1,m-1)$去，就有$e(a_1,b_1)=e(a_2,b_2)=C_{n+m}^n$，$e(a_1,b_2)=C_{n+m}^{n+1}$，$e(a_2,b_1)=C_{n+m}^{m+1}$那么针对本题的答案就是：$${C_{n+m}^n}^2-C_{n+m}^{n+1}×C_{n+m}^{m+1}$$ 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;const LL mod = 1e9+7;const int maxn = 3010;int n, m;LL c[maxn][maxn]; void init() &#123; memset(c,0,sizeof(c)); c[0][0]=c[1][0]=c[1][1]=1; for(int i = 2; i &lt; maxn; i++) &#123; c[i][0] = c[i][i] = 1; for(int j = 1; j &lt; i; j++) &#123; c[i][j] = c[i-1][j] + c[i-1][j-1]; c[i][j] %= mod; &#125; &#125;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); init(); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; LL ret = c[n+m][n]*c[n+m][n]; ret %= mod; LL tmp = c[n+m][n+1]*c[n+m][m+1]; tmp %= mod; ret -= tmp; ret += mod; ret %= mod; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"2018牛客多校01","slug":"2018牛客多校01","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校01/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"}]}]}