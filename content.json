{"meta":{"title":"Kirai","subtitle":"我好菜啊 QAQ | I Good Vegetable A QAQ","description":null,"author":"Kirai","url":"https://vincentxwd.github.io/blog"},"pages":[{"title":"404","date":"2018-07-29T11:33:50.000Z","updated":"2018-07-29T11:33:50.336Z","comments":true,"path":"404/index.html","permalink":"https://vincentxwd.github.io/blog/404/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-07-30T05:59:54.000Z","updated":"2018-08-04T13:54:26.899Z","comments":true,"path":"about/index.html","permalink":"https://vincentxwd.github.io/blog/about/index.html","excerpt":"","text":"kirai，在读渣硕，方向是ML和CV。竞赛败犬，科研萌新。魔兽玩家，喜欢打osu! mania。 如果您在招实习，点击这里可能会多了解一点QAQ。 有问题可以邮箱联系，也可以QQ：107850580。"},{"title":"search","date":"2018-07-29T11:33:36.000Z","updated":"2018-07-30T07:00:53.427Z","comments":true,"path":"search/index.html","permalink":"https://vincentxwd.github.io/blog/search/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-29T12:57:51.000Z","updated":"2018-07-31T04:26:10.039Z","comments":true,"path":"categories/index.html","permalink":"https://vincentxwd.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-29T12:56:26.000Z","updated":"2018-07-30T07:02:56.361Z","comments":true,"path":"tags/index.html","permalink":"https://vincentxwd.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[HDOJ6351] 18多校05 Beautiful Now (暴力，全排列，置换群)","slug":"HDOJ6351-18多校05-Beautiful-Now-暴力，全排列，置换群","date":"2018-08-06T14:55:40.000Z","updated":"2018-08-06T16:26:11.902Z","comments":true,"path":"2018/08/06/HDOJ6351-18多校05-Beautiful-Now-暴力，全排列，置换群/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/06/HDOJ6351-18多校05-Beautiful-Now-暴力，全排列，置换群/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6351 给你一个数字$n$和交换次数$k$，问你最多交换$k$次，这个数最大能变为多大，最小能变为多小。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6351 给你一个数字$n$和交换次数$k$，问你最多交换$k$次，这个数最大能变为多大，最小能变为多小。 暴力枚举这个数字的全排列，然后计算和之前数字之间的交换次数。用置换的方法，总计的最少交换次数为所有环的长度-1的和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; perm[10][10];int a[10];int vis[10];void init()&#123; for(int t = 1; t &lt;= 9; t++) &#123; for(int i = 1; i &lt;= t; i++) a[i] = i; memset(vis, 0, sizeof(vis)); do &#123; int now = 0; for(int i = 1; i &lt;= t; i++) now = now * 10 + a[i]; int tmp = 0; for(int i = 1; i &lt;= t; i++) if(vis[i] != now) &#123; vis[i] = now; for(int j = a[i]; j != i; j = a[j]) &#123; vis[j] = now; tmp++; &#125; &#125; perm[t][tmp].push_back(now); &#125; while(next_permutation(a + 1, a + t + 1)); &#125;&#125;inline int apply(int mask)&#123; int ret = 0; int tmp = 1; while(mask) &#123; ret += a[mask % 10] * tmp; mask /= 10; tmp *= 10; &#125; return ret;&#125;char n[12];int t, k, mn, mx;void solve()&#123; scanf(\"%s%d\", n, &amp;k); t = strlen(n); if(t == 10) &#123; printf(\"1000000000 1000000000\\n\"); return; &#125; if(k &gt;= t) k = t - 1; for(int i = 1; i &lt;= t; i++) a[i] = n[i - 1] - '0'; mn = 1000000000; mx = 0; int lj = 1; for(int i = 1; i &lt; t; i++) lj *= 10; for(int i = 0; i &lt;= k; i++) for(vector&lt;int&gt;::iterator it = perm[t][i].begin(); it != perm[t][i].end(); it++) &#123; int now = apply(*it); if(now &lt; lj) continue; now &lt; mn ? mn = now : 0; now &gt; mx ? mx = now : 0; &#125; printf(\"%d %d\\n\", mn, mx);&#125;int main()&#123; // freopen(\"in\", \"r\", stdin); init(); int T; scanf(\"%d\", &amp;T); for(int t1 = 1; t1 &lt;= T; t1++) solve(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"置换群","slug":"置换群","permalink":"https://vincentxwd.github.io/blog/tags/置换群/"}]},{"title":"[HDOJ6354] 18多校05 Everything Has Changed (计算几何)","slug":"HDOJ6354-18多校05-Everything-Has-Changed-计算几何","date":"2018-08-06T14:51:21.000Z","updated":"2018-08-06T16:26:08.512Z","comments":true,"path":"2018/08/06/HDOJ6354-18多校05-Everything-Has-Changed-计算几何/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/06/HDOJ6354-18多校05-Everything-Has-Changed-计算几何/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6354 给你一个圆和互不相交的n个小圆，让你计算这个大圆被n个小圆切割后的周长，大圆内部的不计算。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6354 给你一个圆和互不相交的n个小圆，让你计算这个大圆被n个小圆切割后的周长，大圆内部的不计算。 很容易发现小圆和大圆相交以后，周长增加了小圆的弧长-大圆的弧长。用余弦定理计算一下大小圆关于交处的角度，然后用弧长公式算一下即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct Node &#123; double x, y, r;&#125;Node;const double pi = acos(-1.0);const int maxn = 111;int n;double r;Node p[maxn];double dis(Node a, Node b) &#123; return (double)sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;double gao(Node a, Node b) &#123; if(b.x &lt; 0) b.x = -b.x; if(b.y &lt; 0) b.y = -b.y; double d = dis(a, b); double theta1 = 2.0 * acos((d*d+a.r*a.r-b.r*b.r)/(2*d*a.r)); double theta2 = 2.0 * acos((d*d+b.r*b.r-a.r*a.r)/(2*d*b.r)); double L1 = theta1 * a.r; double L2 = theta2 * b.r; return L2 - L1;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T, _ = 1; scanf(\"%d\", &amp;T); while(T--) &#123; cin &gt;&gt; n &gt;&gt; r; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].r; &#125; double ret = 2 * pi * r; Node o = &#123;0, 0, r&#125;; for(int i = 1; i &lt;= n; i++) &#123; double d = dis(o, p[i]); double R = o.r, r = p[i].r; if(d &gt;= R + r) continue; if(d == R - r) &#123; ret += p[i].r * pi * 2.0; &#125; if(R - r &lt; d &amp;&amp; d &lt; R + r) &#123; ret += gao(o, p[i]); &#125; &#125; printf(\"%.15f\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://vincentxwd.github.io/blog/tags/计算几何/"}]},{"title":"[AtCoderABC103D] Islands War (贪心，思维)","slug":"AtCoderABC103D-Islands-War-贪心，思维","date":"2018-08-06T09:55:41.000Z","updated":"2018-08-06T16:27:18.272Z","comments":true,"path":"2018/08/06/AtCoderABC103D-Islands-War-贪心，思维/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/06/AtCoderABC103D-Islands-War-贪心，思维/","excerpt":"链接：https://abc103.contest.atcoder.jp/tasks/abc103_d 有n个岛练成一条线，每两个岛之间有一个桥。现在有m个岛之间发生了冲突，发生冲突的岛就不能连通了，问最少要切断几座桥？","text":"链接：https://abc103.contest.atcoder.jp/tasks/abc103_d 有n个岛练成一条线，每两个岛之间有一个桥。现在有m个岛之间发生了冲突，发生冲突的岛就不能连通了，问最少要切断几座桥？ 这题很有意思，贪心地去考虑，希望切到的边影响尽可能地大，可以考虑贪心地将发生冲突的右端点从小到大排，然后从左到右开始切。 可以反证一下：假如选中的某次冲突的右端点不是最优的解，那么可能存在一个在此点左侧的点待切，显然存在的左侧点不是最优点，因为左侧已经统计完将此点之前发生冲突的点对分割开的桥数，再添加一条是冗余的。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;using pii = pair&lt;int, int&gt;;const int maxn = 100100;int n, m;pii p[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\",&amp;p[i].first,&amp;p[i].second); if(p[i].first &gt; p[i].second) swap(p[i].first, p[i].second); &#125; sort(p+1, p+m+1, [](pii x, pii y)&#123; if(x.second != y.second) return x.second &lt; y.second; return x.first &lt; y.first; &#125;); int tot = 1; int pre = p[1].second; for(int i = 2; i &lt;= m; i++) &#123; if(pre &gt; p[i].first) continue; else &#123; tot++; pre = p[i].second; &#125; &#125; printf(\"%d\\n\", tot); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://vincentxwd.github.io/blog/categories/题解/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"},{"name":"思维","slug":"思维","permalink":"https://vincentxwd.github.io/blog/tags/思维/"}]},{"title":"[AtCoderABC104D] We Love ABC (DP, 计数)","slug":"AtCoderABC104D-We-Love-ABC-DP-计数","date":"2018-08-06T03:16:29.000Z","updated":"2018-08-06T16:27:13.789Z","comments":true,"path":"2018/08/06/AtCoderABC104D-We-Love-ABC-DP-计数/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/06/AtCoderABC104D-We-Love-ABC-DP-计数/","excerpt":"链接：https://abc104.contest.atcoder.jp/tasks/abc104_d 给一个只含有ABC?四种字符的字符串，?可以替换成ABC中的任意一个字符，现在要你统计所有的ABC的组合个数。","text":"链接：https://abc104.contest.atcoder.jp/tasks/abc104_d 给一个只含有ABC?四种字符的字符串，?可以替换成ABC中的任意一个字符，现在要你统计所有的ABC的组合个数。 这题比赛时间内写搓了，因为误读了题目的统计结果，比如?ABC，答案应该是4（AABC BABC CABC）。 我们可以考虑枚举B的位置，并以这个B为链接，那么问题就变成了统计左侧A的个数和右侧C的个数。这里也不能是简单地将左右两侧的A?和C?的个数乘起来，因为固定了某一对A、C后其他字符的变化也是要算作不同组合的。我们将每一个B的位置的计数结果拆成四项来统计，即： 1234A、B、C?、B、CA、B、??、B、? 第一项很好统计，由于不存在?所以可以直接计数。第二、三项的本质是相同的，我们在B的某一侧存在?时，要枚举任意一个?（让这个?作为A或C出现），那么其他位置的?则是任意的，那么每一个位置对答案的贡献是$3^{k-1}$，其中$k$为?的左侧或右侧总数。第四项和第二、三项也是一样的，但是要在左右两边各取一个?，假设左侧有$x_1$个?，右侧有$x_2$个?，那么计数结果为$3^{x_1-1}×3^{x_2-1}$，整理为$3^{x_1+x_2-2}$。这样我们就推出了每一个B对总体答案的分步贡献，我们维护A、C、?出现次数的前缀和，之后就可以分类讨论了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)using LL = long long;const int maxn = 100100;LL mod = 1e9 + 7;char s[maxn];LL f[maxn][3];int n;LL mul(LL x, LL n) &#123; LL ret = 1; while(n) &#123; if(n &amp; 1) &#123; ret *= x; ret %= mod; &#125; n &gt;&gt;= 1; x *= x; x %= mod; &#125; return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%s\", s+1)) &#123; memset(f, 0, sizeof(f)); n = strlen(s+1); for(int i = 1; i &lt;= n; i++) &#123; f[i][0] = f[i-1][0] + (s[i] == 'A'); f[i][1] = f[i-1][1] + (s[i] == 'C'); f[i][2] = f[i-1][2] + (s[i] == '?'); &#125; LL ret = 0; for(int i = 1; i &lt;= n; i++) &#123; if(s[i] == 'B' || s[i] == '?') &#123; LL q = f[n][2] - (s[i] == '?'); ret += mul(3LL, q) * (f[i-1][0] * (f[n][1] - f[i][1]) % mod); ret %= mod; if(q &gt;= 1) &#123; ret += mul(3LL, q-1) * (f[i-1][0] * (f[n][2] - f[i][2]) % mod); ret %= mod; ret += mul(3LL, q-1) * (f[i-1][2] * (f[n][1] - f[i][1]) % mod); ret %= mod; &#125; if(q &gt;= 2) &#123; ret += mul(3LL, q-2) * (f[i-1][2] * (f[n][2] - f[i][2]) % mod); ret %= mod; &#125; &#125; &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://vincentxwd.github.io/blog/categories/题解/AtCoder/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[2018百度之星] 资格赛1003 整数规划 (最大匹配)","slug":"2018百度之星-资格赛1003-整数规划-最大匹配","date":"2018-08-05T14:09:51.000Z","updated":"2018-08-06T16:27:53.142Z","comments":true,"path":"2018/08/05/2018百度之星-资格赛1003-整数规划-最大匹配/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1003-整数规划-最大匹配/","excerpt":"题目链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1003","text":"题目链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1003 希望最大化目标函数，事实上满足 Kuhn–Munkres algorithm 求解最小权匹配过程中的顶标的定义，现在就是要计算最大顶标和，而这正好就是最小权匹配 ，按照$x_i$和$y_i$给定的约束条件连边，同时边权置为负值。然后跑最大匹配，输出结果的相反数。 这题一般的KM算法是过不了的，因为网上流传的KM代码都到不了$O(n^3)$。于是去UOJ上扒了一份KM模版…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int N = 405;int w[N][N];int lx[N], ly[N];int lmatch[N], rmatch[N];bool lvis[N], rvis[N];int slack[N];int pre[N];int n;int update(int n) &#123; int dt = INF, ru; for (int j = 1; j &lt;= n; j++) if (!rvis[j] &amp;&amp; slack[j] &lt; dt) &#123; dt = slack[j]; ru = j; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (lvis[i]) lx[i] -= dt; if (rvis[i]) ly[i] += dt; else slack[i] -= dt; &#125; return ru;&#125;void match(int&amp; u) &#123; for (; u; swap(u, lmatch[pre[u]])) rmatch[u] = pre[u];&#125;void bfs(int u, int n) &#123; queue&lt;int&gt; q; q.push(u); lvis[u] = true; while (true) &#123; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int v = 1; v &lt;= n; ++v) &#123; int tmp; if (rvis[v] || (tmp = lx[u] + ly[v] - w[u][v]) &gt; slack[v]) continue; pre[v] = u; if (!tmp) &#123; if (!rmatch[v]) return match(v); rvis[v] = lvis[rmatch[v]] = true; q.push(rmatch[v]); &#125; else slack[v] = tmp; &#125; &#125; u = update(n); if (!rmatch[u]) return match(u); rvis[u] = lvis[rmatch[u]] = true; q.push(rmatch[u]); &#125;&#125;LL KM(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; lmatch[i] = rmatch[i] = lx[i] = ly[i] = 0; for (int j = 1; j &lt;= n; j++) &#123; lx[i] = max(lx[i], w[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; slack[j] = INF; lvis[j] = rvis[j] = false; &#125; bfs(i, n); &#125; LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; res += lx[i] + ly[i]; &#125; return res;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T_T, _ = 0; scanf(\"%d\", &amp;T_T); while(T_T--) &#123; scanf(\"%d\",&amp;n); memset(w, 0, sizeof(w)); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; scanf(\"%d\", &amp;w[i][j]); w[i][j] = -w[i][j]; &#125; &#125; printf(\"Case #%d: %I64d\\n\", ++_, -KM(n)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"匹配问题","slug":"匹配问题","permalink":"https://vincentxwd.github.io/blog/tags/匹配问题/"}]},{"title":"[2018百度之星] 资格赛1005 序列计数 (DP, 树状数组, 随机)","slug":"2018百度之星-资格赛1005-序列计数-DP-树状数组-随机","date":"2018-08-05T03:34:48.000Z","updated":"2018-08-06T16:27:24.645Z","comments":true,"path":"2018/08/05/2018百度之星-资格赛1005-序列计数-DP-树状数组-随机/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1005-序列计数-DP-树状数组-随机/","excerpt":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1005 这题随机给你一个1~n的排列，要你统计这1~n的排列中长度为1~n的上升子序列的个数分别是多少。","text":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1005 这题随机给你一个1~n的排列，要你统计这1~n的排列中长度为1~n的上升子序列的个数分别是多少。 由于数据是随机的，因此这个序列中的LIS满足下面这个工作： LIS的长度大概是$2\\sqrt{N}$，当$N=10000$时，LIS的最长长度大约为$200$。 我们很容易就推出LIS的计数公式：$$f(i,k) += (p_i &gt; p_j)? f(j,k-1) : 0$$可以考虑枚举LIS的长度$l$，用bit维护到第$i$个位置的数字$p[i]$、长度为$l-1$的上升子序列的总数，这样每次扫一个位置的时候，就可以直接查前缀和了。 由于要更新bit，所以维护一个滚动的dp数组，在查询长度为$l-1$的计数结果的同时，更新答案以及$l$的计数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)using LL = long long;const LL maxn = 10100;const LL mod = 1e9+7;LL n;LL p[maxn];LL bit[maxn];LL f[2][maxn];LL lowbit(LL x) &#123; return x &amp; -x;&#125;void add(LL x, LL val) &#123; for(LL i = x; i &lt;= n; i+=lowbit(i)) &#123; bit[i] += val; bit[i] %= mod; &#125;&#125;LL sum(LL x) &#123; LL ret = 0; for(LL i = x; i; i-=lowbit(i)) &#123; ret += bit[i]; ret %= mod; &#125; return ret;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); LL T, _ = 0; scanf(\"%I64d\", &amp;T); while(T--) &#123; scanf(\"%I64d\", &amp;n); for(LL i = 1; i &lt;= n; i++) &#123; scanf(\"%I64d\",&amp;p[i]); &#125; memset(bit, 0, sizeof(bit)); memset(f, 0, sizeof(f)); LL x = 0, flag = 1; for(LL i = 1; i &lt;= n; i++) f[0][i] = 1; printf(\"Case #%I64d:\", ++_); printf(\" %I64d\", n); for(LL l = 2; l &lt;= n; l++) &#123; x = !x; LL ret = 0; if(flag) &#123; memset(bit, 0, sizeof(bit)); for(LL i = 1; i &lt;= n; i++) &#123; f[x][i] = sum(p[i] - 1); ret += f[x][i]; ret %= mod; add(p[i], f[!x][i]); &#125; &#125; if(ret == 0) flag = 0; printf(\" %I64d\", ret); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://vincentxwd.github.io/blog/tags/树状数组/"},{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[2018百度之星] 资格赛1006 三原色图 (最小生成树)","slug":"2018百度之星-资格赛1006-三原色图-最小生成树","date":"2018-08-04T16:37:14.000Z","updated":"2018-08-06T16:27:21.757Z","comments":true,"path":"2018/08/05/2018百度之星-资格赛1006-三原色图-最小生成树/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1006-三原色图-最小生成树/","excerpt":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1006","text":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1006 这题很简单，按照RG、BG的组合分别跑最小生成树，假如某一种情况无法构造出则抛弃那一种情况。同时给边打标记，最后再取k-(n+1)条最短的未添加到生成树里的边就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct Node &#123; int id, u, v, w; char c; friend bool operator&lt;(Node a, Node b) &#123; return a.w &gt; b.w; &#125;&#125;Node;const int maxn = 110;int n, m, eid;int pre[maxn];int vis[maxn&lt;&lt;2];vector&lt;Node&gt; G[maxn];priority_queue&lt;Node&gt; pq;int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;bool unite(int x, int y) &#123; x = find(x); y = find(y); if (x != y) &#123; pre[y] = x; return 1; &#125; return 0;&#125;pair&lt;int, bool&gt; gao1(int k) &#123; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt; maxn; i++) pre[i] = i; while (!pq.empty()) pq.pop(); int tot = 0, ret = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; if(G[i][j].c == 'R' || G[i][j].c == 'G') &#123; pq.push(G[i][j]); &#125; &#125; &#125; while(!pq.empty()) &#123; Node p = pq.top(); pq.pop(); if(unite(p.u, p.v)) &#123; tot++; ret += p.w; vis[p.id] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; if(!vis[G[i][j].id]) pq.push(G[i][j]); &#125; &#125; for(int i = 0; i &lt; k - n + 1; i++) &#123; ret += pq.top().w; pq.pop(); pq.pop(); &#125; return make_pair(ret, tot == n - 1);&#125;pair&lt;int, bool&gt; gao2(int k) &#123; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt; maxn; i++) pre[i] = i; while (!pq.empty()) pq.pop(); int tot = 0, ret = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; if(G[i][j].c == 'B' || G[i][j].c == 'G') &#123; pq.push(G[i][j]); &#125; &#125; &#125; while(!pq.empty()) &#123; Node p = pq.top(); pq.pop(); if(unite(p.u, p.v)) &#123; tot++; ret += p.w; vis[p.id] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; if(!vis[G[i][j].id]) pq.push(G[i][j]); &#125; &#125; for(int i = 0; i &lt; k - n + 1; i++) &#123; ret += pq.top().w; pq.pop(); pq.pop(); &#125; return make_pair(ret, tot == n - 1);&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T, _ = 0; int u, v, w; char c[5]; scanf(\"%d\", &amp;T); while(T--) &#123; eid = 1; scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) G[i].clear(); for(int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d%d%s\",&amp;u,&amp;v,&amp;w,c); G[u].push_back(&#123;eid, u, v, w, c[0]&#125;); G[v].push_back(&#123;eid++, v, u, w, c[0]&#125;); &#125; pair&lt;int, bool&gt; tmp; printf(\"Case #%d:\\n\", ++_); for(int k = 1; k &lt;= m; k++) &#123; if(k &lt; n - 1) &#123; printf(\"-1\\n\"); continue; &#125; int ret = 0x7f7f7f7f; tmp = gao1(k); if(tmp.second) &#123; ret = min(ret, tmp.first); &#125; tmp = gao2(k); if(tmp.second) &#123; ret = min(ret, tmp.first); &#125; if(ret == 0x7f7f7f7f) printf(\"-1\\n\"); else printf(\"%d\\n\", ret); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"https://vincentxwd.github.io/blog/tags/最小生成树/"}]},{"title":"[2018百度之星] 资格赛1001 调查问卷 (状压枚举, 计数)","slug":"2018百度之星-资格赛1001-调查问卷-状压枚举-计数","date":"2018-08-04T16:36:08.000Z","updated":"2018-08-06T16:25:42.265Z","comments":true,"path":"2018/08/05/2018百度之星-资格赛1001-调查问卷-状压枚举-计数/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/05/2018百度之星-资格赛1001-调查问卷-状压枚举-计数/","excerpt":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1001","text":"链接：http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=820&amp;pid=1001 没啥好解释的，中文题意。 因为题目最多10道，因此枚举所有题目的组合，然后把每一份问卷的对应答案存出来，对每一类单独统计数目。之后每一类中的问卷答案数$k$与其他问卷答案成的对数为$p×(n-p)$，累加所有问卷答案对数再除以2，跟目标k比较一下就ok。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;int n, m, k;char s[maxn][11];int cur[maxn][11];int f[maxn];unordered_map&lt;int, int&gt; vis;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T, _ = 0; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", s[i]); &#125; int ret = 0; int mm = 1 &lt;&lt; m; for(int i = 1; i &lt; mm; i++) &#123; int qq = 0; for(int j = 0; j &lt; m; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; for(int l = 0; l &lt; n; l++) &#123; cur[l][qq] = s[l][j] - 'A' + 1; &#125; qq++; &#125; &#125; for(int j = 0; j &lt; n; j++) f[j] = 0; for(int j = 0; j &lt; n; j++) &#123; for(int l = 0; l &lt; qq; l++) &#123; f[j] &lt;&lt;= 1; f[j] |= (cur[j][l] == 1 ? 1 : 0); &#125; &#125; vis.clear(); for(int j = 0; j &lt; n; j++) vis[f[j]]++; int tot = n, tmp = 0; for(auto p : vis) &#123; tmp += (n - p.second) * p.second; &#125; if(tmp / 2 &gt;= k) ret++; &#125; printf(\"Case #%d: %d\\n\", ++_, ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018百度之星","slug":"题解/HDOJ/2018百度之星","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018百度之星/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"https://vincentxwd.github.io/blog/tags/枚举/"},{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"}]},{"title":"[Codeforces1016C] Vasya And The Mushrooms (DP)","slug":"Codeforces1016C-Vasya-And-The-Mushrooms-DP","date":"2018-08-04T13:58:14.000Z","updated":"2018-08-06T16:26:36.220Z","comments":true,"path":"2018/08/04/Codeforces1016C-Vasya-And-The-Mushrooms-DP/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/04/Codeforces1016C-Vasya-And-The-Mushrooms-DP/","excerpt":"链接：http://codeforces.com/contest/1016/problem/C 给出一个$2×n$的矩阵，一个人从$(1,1)$出发，每一个格子只能走一次，走完这$2n$个格子后使得带权和最大，问最大的带权和是多少。","text":"链接：http://codeforces.com/contest/1016/problem/C 给出一个$2×n$的矩阵，一个人从$(1,1)$出发，每一个格子只能走一次，走完这$2n$个格子后使得带权和最大，问最大的带权和是多少。 容易发现走到最后一个格子之前路径可以分为两个部分：前半部分蛇皮走位，后半部分一个大回环。 但是决定走大回环的位置也是分奇偶的，于是我们预处理出每一行的前缀和$sa_i$和$sb_i$，以及两组后缀和，分别为拐弯前（$da_i、db_i$）和拐弯后（$ia_i、ib_i$）。 然后我们可以枚举拐弯的结点，并同时记录前面走蛇皮位的结果，同时讨论目前在下还是在上，决定大回环值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 300003;int dx[5] = &#123;0, 0, 1, -1&#125;;int dy[5] = &#123;1, -1, 0, 0&#125;;int n;LL a[maxn], b[maxn];LL sa[maxn], sb[maxn], ia[maxn], ib[maxn], da[maxn], db[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\", &amp;n)) &#123; for(int i = 0; i &lt; n; i++) scanf(\"%lld\",&amp;a[i]); for(int i = 0; i &lt; n; i++) scanf(\"%lld\",&amp;b[i]); memset(sa, 0, sizeof(sa)); memset(sb, 0, sizeof(sb)); memset(ia, 0, sizeof(ia)); memset(ib, 0, sizeof(ib)); memset(da, 0, sizeof(da)); memset(db, 0, sizeof(db)); for(int i = n - 1; i &gt;= 0; i--) &#123; sa[i] = sa[i+1] + a[i]; sb[i] = sb[i+1] + b[i]; ia[i] = ia[i+1] + a[i] * (LL)(n-i-1LL); ib[i] = ib[i+1] + b[i] * (LL)(n-i-1LL); da[i] = da[i+1] + a[i] * (LL)i; db[i] = db[i+1] + b[i] * (LL)i; &#125; LL ret = 0, tmp = 0; for(int i = 0; i &lt; n; i++) &#123; if(i &amp; 1) &#123; LL tr = db[i] + sb[i] * (2LL*i - i); tr += ia[i] + sa[i] * (2LL*i + n - i); ret = max(ret, tmp+tr); tmp += (2LL*i*b[i]); tmp += (2LL*i+1LL)*a[i]; &#125; else &#123; LL tr = da[i] + sa[i] * (2LL*i - i); tr += ib[i] + sb[i] * (2LL*i + n - i); ret = max(ret, tmp+tr); tmp += (2LL*i*a[i]); tmp += (2LL*i+1LL)*b[i]; &#125; &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[Codeforces1016D] Vasya And The Matrix (构造)","slug":"Codeforces1016D-Vasya-And-The-Matrix-构造","date":"2018-08-04T12:59:16.000Z","updated":"2018-08-06T16:26:31.682Z","comments":true,"path":"2018/08/04/Codeforces1016D-Vasya-And-The-Matrix-构造/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/04/Codeforces1016D-Vasya-And-The-Matrix-构造/","excerpt":"链接：http://codeforces.com/contest/1016/problem/D 给出一个矩阵的行和列的大小$n，m$以及每一行和每一列的异或和$a_i$和$b_i$，让你构造这样一个矩阵。","text":"链接：http://codeforces.com/contest/1016/problem/D 给出一个矩阵的行和列的大小$n，m$以及每一行和每一列的异或和$a_i$和$b_i$，让你构造这样一个矩阵。 考虑将每一行的异或和放到第一列上，每一列的异或和放到第一行上。问题在$(1,1)$处，这里可以用$a_2、a_3、…、a_n$。接下来判断这个数和第一行的异或和是否为$b_1$即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;int a[maxn], b[maxn], ret;int n, m;int G[maxn][maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; ret = 0; memset(G, 0, sizeof(G)); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); ret ^= a[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;b[i]); ret ^= b[i]; &#125; if(ret != 0) &#123; printf(\"NO\\n\"); continue; &#125; G[1][1] = b[1]; for(int i = 2; i &lt;= n; i++) &#123; G[1][1] ^= a[i]; &#125; for(int i = 2; i &lt;= m; i++) &#123; G[1][i] = b[i]; &#125; for(int i = 2; i &lt;= n; i++) &#123; G[i][1] = a[i]; &#125; int p = 0; for(int i = 1; i &lt;= m; i++) &#123; p ^= G[1][i]; &#125; if(p != a[1]) &#123; printf(\"NO\\n\"); continue; &#125; printf(\"YES\\n\"); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; printf(\"%d%c\", G[i][j], \" \\n\"[j==m]); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"}]},{"title":"2018牛客多校05 E room (费用流)","slug":"2018牛客多校05-E-room-费用流","date":"2018-08-03T05:47:19.000Z","updated":"2018-08-06T16:27:41.011Z","comments":true,"path":"2018/08/03/2018牛客多校05-E-room-费用流/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/2018牛客多校05-E-room-费用流/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/E n个宿舍，每个宿舍住4个人，给两年的住宿情况，问最少调换多少人，能从前一年的住宿状态调换到后一年的住宿状态（宿舍顺序不影响）。","text":"链接：https://www.nowcoder.com/acm/contest/143/E n个宿舍，每个宿舍住4个人，给两年的住宿情况，问最少调换多少人，能从前一年的住宿状态调换到后一年的住宿状态（宿舍顺序不影响）。 比赛的时候没时间看，补题的时候发现是一道挺好想的费用流问题。 考虑宿舍整体，当一个宿舍变为另一个宿舍的时候，我们的代价是这两个宿舍中不同人的个数，按照这条规律，我们可以建图： 单独建超级源和超级汇，之后按照不同年份和不同宿舍建点，不同年的每个宿舍之间连接一条边，容量为1，费用为不同人的个数。源点连接前一年的点，容量为1费用为0，后一年的点连汇点，容量为1费用为0。这样跑一下最小费用最大流就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef struct Node &#123; int u, v, next; LL c, w;&#125;Node;const int maxn = 210;const int maxm = 40100;const LL mod = 0x3f3f3f3fLL;const LL inf = (1LL&lt;&lt;55);int tot, head[maxn];LL dist[maxn];LL cost, flow;Node e[maxm];int pre[maxn];bool visit[maxn];queue&lt;int&gt; Q;int S, T, N;void init() &#123; S = T = N = 0; memset(head, -1, sizeof(head)); tot = 0;&#125;void adde(int u, int v, LL c, LL w) &#123; e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++; e[tot].u = v; e[tot].v = u; e[tot].c = 0; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;&#125;bool spfa(int s, int t, int n) &#123; int i; for(i = 0; i &lt;= n; i++) &#123; dist[i] = inf; visit[i] = 0; pre[i] = -1; &#125; while(!Q.empty()) Q.pop(); Q.push(s); visit[s] = true; dist[s] = 0; pre[s] = -1; while(!Q.empty()) &#123; int u = Q.front(); visit[u] = false; Q.pop(); for(int j = head[u]; j != -1; j = e[j].next) &#123; if(e[j].c &gt; 0 &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123; dist[e[j].v] = dist[u] + e[j].w; pre[e[j].v] = j; if(!visit[e[j].v]) &#123; Q.push(e[j].v); visit[e[j].v] = true; &#125; &#125; &#125; &#125; // return dist[t] &lt; 0; // 求可行流 if(dist[t] == inf) return false; // 求最小费用流 else return true;&#125;LL ChangeFlow(int t) &#123; LL det = mod; int u = t; while(~pre[u]) &#123; u = pre[u]; det = min(det, e[u].c); u = e[u].u; &#125; u = t; while(~pre[u]) &#123; u = pre[u]; e[u].c -= det; e[u ^ 1].c += det; u = e[u].u; &#125; return det;&#125;LL MinCostFlow(int s, int t, int n) &#123; LL mincost, maxflow; mincost = maxflow = 0; while(spfa(s, t, n)) &#123; LL det = ChangeFlow(t); mincost += det * dist[t]; maxflow += det; &#125; cost = mincost; flow = maxflow; return mincost;&#125;int n;int vis[maxn][maxn][2];signed main() &#123; // freopen(\"in\", \"r\", stdin); int x; while(~scanf(\"%d\", &amp;n)) &#123; init();T = 2 * n + 1; N = T + 1; memset(vis, 0, sizeof(vis)); int tot = n * 4; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= 4; j++) &#123; scanf(\"%d\", &amp;x); vis[i][x][0] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= 4; j++) &#123; scanf(\"%d\", &amp;x); vis[i][x][1] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; adde(S, i, 1, 0); adde(i+n, T, 1, 0); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; int diff = 0; for(int k = 1; k &lt;= tot; k++) &#123; if(vis[i][k][0] == vis[j][k][1] &amp;&amp; vis[i][k][0] == 1) &#123; diff++; &#125; &#125; adde(i, j+n, 1, 4-diff); &#125; &#125; cout &lt;&lt; MinCostFlow(S, T, N) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://vincentxwd.github.io/blog/tags/费用流/"}]},{"title":"[HDOJ6301] 18多校01 Distinct Values (莫队算法, 构造)","slug":"HDOJ6301-Distinct-Values-莫队算法","date":"2018-08-03T04:22:10.000Z","updated":"2018-08-06T16:26:15.412Z","comments":true,"path":"2018/08/03/HDOJ6301-Distinct-Values-莫队算法/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/HDOJ6301-Distinct-Values-莫队算法/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6301 给出m个区间，要求构造一个指定区间内的数字不能相等，并且数字在$[1,n]$之间，求构造的字典序最小的方案。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6301 给出m个区间，要求构造一个指定区间内的数字不能相等，并且数字在$[1,n]$之间，求构造的字典序最小的方案。 首先给区间排个序，按照左端点小、右端点小的规则排。接下来维护两个指针L、R，从左到右往里塞，然后用类似莫队的更新方法去维护数列，同时维护目前可用的数字。 整体复杂度为$O(n+m)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using Node = struct &#123; int l, r;&#125;;const int maxn = 100100;int n, m, a[maxn];Node p[maxn];set&lt;int&gt; st;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while(T--) &#123; st.clear(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\",&amp;p[i].l,&amp;p[i].r); &#125; sort(p+1, p+m+1, [](Node a, Node b) &#123; return a.l == b.l ? a.r &lt; b.r : a.l &lt; b.l; &#125;); for(int i = 1; i &lt;= n; i++) &#123; st.insert(i); a[i] = 1; &#125; int L = p[1].l, R = p[1].r; for(int i = L; i &lt;= R; i++) &#123; a[i] = *st.begin(); st.erase(a[i]); &#125; for(int i = 2; i &lt;= m; i++) &#123; while(L &lt; p[i].l) &#123; st.insert(a[L++]); &#125; while(R &lt; p[i].r) &#123; if(R + 1 &lt; p[i].l) R++; else &#123; a[++R] = *st.begin(); st.erase(a[R]); &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; printf(\"%d%c\", a[i], \" \\n\"[i==n]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"莫队算法","slug":"莫队算法","permalink":"https://vincentxwd.github.io/blog/tags/莫队算法/"},{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"}]},{"title":"[HDOJ6299] 18多校01 Balanced Sequence (贪心)","slug":"HDOJ6299-Balanced-Sequence-贪心","date":"2018-08-03T04:18:41.000Z","updated":"2018-08-06T16:26:19.873Z","comments":true,"path":"2018/08/03/HDOJ6299-Balanced-Sequence-贪心/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/HDOJ6299-Balanced-Sequence-贪心/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6299 n个括号串，问如何排列这n个串，使得连起来后()匹配的对数最多（不用连续）。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6299 n个括号串，问如何排列这n个串，使得连起来后()匹配的对数最多（不用连续）。 首先串内匹配并记录答案。之后尽可能让左括号多的在左边，右括号多的在右边排序，再贪心扫一遍，只维护左括号的个数，同时根据下一个串右括号的个数统计答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using Node = struct &#123; int l, r, v;&#125;;const int maxn = 100100;int n;vector&lt;Node&gt; p;char s[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d\", &amp;n); p.resize(n); for(int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", s); int tot = 0; int l = 0, r = 0; for(int j = 0; s[j]; j++) &#123; if(s[j] == '(') &#123; l++; &#125; else &#123; if(l != 0) l--, tot++; else r++; &#125; &#125; p[i].l = l, p[i].r = r, p[i].v = tot; &#125; sort(p.begin(), p.end(), [](Node a, Node b) &#123; if(a.l &gt; a.r) &#123; return b.l &gt; b.r ? a.r &lt; b.r : true; &#125; return b.l &lt;= b.r ? a.l &gt; b.l : false; &#125;); int l = 0, r = 0, ret = 0; for(int i = 0; i &lt; n - 1; i++) &#123; ret += p[i].v; l += p[i].l; r += p[i+1].r; ret += min(l, r); l -= min(l, r); r = 0; &#125; ret += p[n-1].v; printf(\"%d\\n\", ret * 2); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"HDOJ","slug":"题解/HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/"},{"name":"2018杭电多校","slug":"题解/HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/HDOJ/2018杭电多校/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"}]},{"title":"[Hackerrank] Array Partition (并查集, 数学)","slug":"Hackerrank-Array-Partition-并查集-数学","date":"2018-08-02T16:52:18.000Z","updated":"2018-08-06T16:26:24.246Z","comments":true,"path":"2018/08/03/Hackerrank-Array-Partition-并查集-数学/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/Hackerrank-Array-Partition-并查集-数学/","excerpt":"链接：https://www.hackerrank.com/contests/hourrank-29/challenges/array-partition 给n个数，让你将这n个数拆分成两个集合，使得两个集合分别乘积互质，求拆分方案数。","text":"链接：https://www.hackerrank.com/contests/hourrank-29/challenges/array-partition 给n个数，让你将这n个数拆分成两个集合，使得两个集合分别乘积互质，求拆分方案数。 第一次打Hackerrank，一个小时三道题还是很刺激的。这道题比赛的时候没调出来，只拿了部分分，有点遗憾啊~）ps：衣服还是很难拿的，top10 才有，这场出现了tourist等众神牛，这种场拿衣服还是不想了。 根据题目的要求，显然拥有相同因数的数字必须呆在同一个集合（1除外，这是个trick，后面会说），考虑用一个方法，将所有拥有至少一个公共因数的数字划为同一个集合，然后再对所有不连通的集合进行计数，会发现：当有$n$个集合的时候，我们的划分方案数为$2^{n}-2$。 很显然可以用并查集维护每一个数的因数的连通情况，因此我们在枚举每一个数的因数的同时，将因数和这个数并到一起就可以了。这里需要特别注意的是，每一个1都可以分到一个单独的集合里，因此计数的时候需要单独考虑~ 整体复杂度为$O(n\\sqrt{n})$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758typedef long long LL;const int maxn = 1000010;const LL mod = 1e9+7;int pre[maxn];set&lt;int&gt; vis;int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if(x != y) &#123; pre[x] = y; &#125;&#125;int solve(vector&lt;int&gt; a) &#123; int cnt = 0; int nn = 1 &lt;&lt; a.size(); vis.clear(); for(int i = 0; i &lt; maxn; i++) pre[i] = i; for(int i = 0; i &lt; a.size(); i++) &#123; if(a[i] == 1) cnt++; vis.insert(a[i]); int tmp = a[i]; int aa = (int)sqrt(a[i]) + 1; for(int j = 2; j &lt;= aa; j++) &#123; if(tmp % j == 0) &#123; unite(a[i], j); vis.insert(j); while(tmp % j == 0) tmp /= j; &#125; &#125; if(tmp != 1) unite(a[i], tmp); &#125; map&lt;int, int&gt; block; for(int i = 0; i &lt; maxn; i++) &#123; if(vis.find(i) != vis.end()) &#123; block[find(i)]++; &#125; &#125; if(block.size() &lt; 2) &#123; return 0; &#125; LL ret = 1; for(int i = 0; i &lt; block.size(); i++) &#123; ret *= 2; ret %= mod; &#125; for(int i = 0; i &lt; cnt - 1; i++) &#123; ret *= 2; ret %= mod; &#125; ret -= 2; ret += mod; ret %= mod; return ret;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Hackerrank","slug":"题解/Hackerrank","permalink":"https://vincentxwd.github.io/blog/categories/题解/Hackerrank/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"并查集","slug":"并查集","permalink":"https://vincentxwd.github.io/blog/tags/并查集/"}]},{"title":"2018牛客多校05 J plan(数学，规律)","slug":"2018牛客多校05-J-plan-数学，规律","date":"2018-08-02T14:13:21.000Z","updated":"2018-08-06T16:27:30.873Z","comments":true,"path":"2018/08/02/2018牛客多校05-J-plan-数学，规律/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/02/2018牛客多校05-J-plan-数学，规律/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/J n个人住宾馆，双人间价格为p2，三人间价格为p3，如何安排，使总花费最少。","text":"链接：https://www.nowcoder.com/acm/contest/143/J n个人住宾馆，双人间价格为p2，三人间价格为p3，如何安排，使总花费最少。 列方程，枚举最近的6个结果即可。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;LL n, a, b; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;a,&amp;b)) &#123; LL ret = 1e18; for(LL i = 0; i &lt;= 6; i++) &#123; ret = min(ret, (n+1-i)/2*a+(i+2)/3*b); ret = min(ret, (n+2-i)/3*b+(i+1)/2*a); &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"2018牛客多校05 G max(数学，规律)","slug":"2018牛客多校05-G-max-数学，规律","date":"2018-08-02T14:12:51.000Z","updated":"2018-08-06T16:27:37.303Z","comments":true,"path":"2018/08/02/2018牛客多校05-G-max-数学，规律/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/02/2018牛客多校05-G-max-数学，规律/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/G 给定c、n，求两个整数a、b，使得$gcd(a,b)=c, 1≤a,b≤n$","text":"链接：https://www.nowcoder.com/acm/contest/143/G 给定c、n，求两个整数a、b，使得$gcd(a,b)=c, 1≤a,b≤n$ 很容易发现只需要选择最接近n的c的倍数数、以及次接近n的c的倍数乘积就是最大的。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;LL c, n; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld\",&amp;c,&amp;n)) &#123; if(c &gt; n) &#123; printf(\"-1\\n\"); continue; &#125; if(c == 1) &#123; if(n == 1) printf(\"1\\n\"); else printf(\"%lld\\n\", n*(n-1)); continue; &#125; bool flag = 1; if(n == c) &#123; printf(\"%lld\\n\", c * c); continue; &#125; if(n % c == 0) printf(\"%lld\\n\", n*(n-c)); else &#123; LL t = n / c * c; if(t == c) printf(\"%lld\\n\", t*t); else printf(\"%lld\\n\", t*(t-c)); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"2018牛客多校05 A gpa (01分数规划)","slug":"2018牛客多校05-A-gpa-01分数规划","date":"2018-08-02T13:43:55.000Z","updated":"2018-08-06T16:27:44.968Z","comments":true,"path":"2018/08/02/2018牛客多校05-A-gpa-01分数规划/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/02/2018牛客多校05-A-gpa-01分数规划/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/A 一个人有n个成绩，然后现在他可以删掉其中至多k个，使得目标方程$\\frac{\\sum[s[i]c[i]}{\\sum s[i]}$的值最大，问这个值可以是多少。","text":"链接：https://www.nowcoder.com/acm/contest/143/A 一个人有n个成绩，然后现在他可以删掉其中至多k个，使得目标方程$\\frac{\\sum[s[i]c[i]}{\\sum s[i]}$的值最大，问这个值可以是多少。 这题和POJ2976是很类似的，是用01分数规划可以解决的问题。01分数规划可以看做是一种思想，可以用二分查找实现。针对这一道题，我们希望让目标方程尽可能大，于是可以假设：$$\\frac{\\sum[s[i]c[i]}{\\sum s[i]} \\geq L$$移项后得：$$\\sum{s_ic_i-L×s_i}\\geq0$$于是我们可以二分$L$，对该式中的$s_ic_i-L×s_i$进行计算并排序，删掉最小的k个后，查看是否满足题意。当收敛时，即$L$近似为式子的最大值。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std; const double eps = 1e-9;const int maxn = 101000;int n, k, m;int s[maxn], c[maxn];double d[maxn]; bool ok(double L) &#123; for(int i = 1; i &lt;= n; i++) d[i] = (double)(s[i] * c[i]) - L * (double)s[i]; sort(d+1, d+n+1); double tot = .0; for(int i = k+1; i &lt;= n; i++) &#123; tot += d[i]; &#125; return tot &gt; 0;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;s[i]); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;c[i]); double lo = .0, hi = 1e3; double ret = .0; while(hi - lo &gt; eps) &#123; double mid = (lo + hi) / 2.0; if(ok(mid)) lo = mid; else hi = mid; &#125; printf(\"%.11f\\n\", lo); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"},{"name":"01分数规划","slug":"01分数规划","permalink":"https://vincentxwd.github.io/blog/tags/01分数规划/"}]},{"title":"[Codeforces1006E] Military Problem(DFS)","slug":"Codeforces1006E-Military-Problem-DFS","date":"2018-08-01T15:40:55.000Z","updated":"2018-08-06T16:26:53.162Z","comments":true,"path":"2018/08/01/Codeforces1006E-Military-Problem-DFS/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1006E-Military-Problem-DFS/","excerpt":"链接：http://codeforces.com/contest/1006/problem/E 给一棵$n$个节点的树和$q$次询问，每次询问两个数$u、k$，表示第u个节点的第k个前序遍历的结果是谁。","text":"链接：http://codeforces.com/contest/1006/problem/E 给一棵$n$个节点的树和$q$次询问，每次询问两个数$u、k$，表示第u个节点的第k个前序遍历的结果是谁。 这么水的题竟然放在了E，可能这就是div 3吧… dfs一遍，维护出每个节点$i$的前序遍历的次序$ret_i$，以及该节点的子树中共计多少个节点$sz_i$，可以利用$ret_i$维护出第$j$号遍历的节点是$id_i$。当我们要求的某节点开始往后数$k$个数不存在时，输出-1；否则我们的答案就是$ret[id[u]+k-1]$。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200100;int n, q, tot;vector&lt;int&gt; G[maxn];int ret[maxn], sz[maxn], id[maxn];int dfs(int u, int p) &#123; ret[++tot] = u; int son = 1; for(int i = 0; i &lt; G[u].size(); i++) &#123; int &amp;v = G[u][i]; if(v == p) continue; son += dfs(v, u); &#125; return sz[u] = son;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int u, k; while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; tot = 0; memset(ret, -1, sizeof(ret)); memset(sz, 0, sizeof(sz)); for(int i = 1; i &lt;= n; i++) G[i].clear(); for(int i = 2; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;u); G[i].push_back(u); G[u].push_back(i); &#125; sz[1] = dfs(1, -1); for(int i = 1; i &lt;= n; i++) id[ret[i]] = i; while(q--) &#123; scanf(\"%d%d\",&amp;u,&amp;k); if(k - 1 &gt;= sz[u]) printf(\"-1\\n\"); else printf(\"%d\\n\", ret[id[u]+k-1]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://vincentxwd.github.io/blog/tags/DFS/"}]},{"title":"[Codeforces1006D] Two Strings Swaps(规律)","slug":"Codeforces1006D-Two-Strings-Swaps-规律","date":"2018-08-01T15:06:48.000Z","updated":"2018-08-06T16:26:49.073Z","comments":true,"path":"2018/08/01/Codeforces1006D-Two-Strings-Swaps-规律/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1006D-Two-Strings-Swaps-规律/","excerpt":"链接：http://codeforces.com/contest/1006/problem/D 给你两个字符串，定义三种操作。要求你事先给其中一个字符串替换某几个字符，然后再经过任一种上述操作变成两个一样的字符串，问预处理替换的字符最少要几个","text":"链接：http://codeforces.com/contest/1006/problem/D 给你两个字符串，定义三种操作。要求你事先给其中一个字符串替换某几个字符，然后再经过任一种上述操作变成两个一样的字符串，问预处理替换的字符最少要几个 一个很容易发现的规律就是每次处理的时候仅需要关心操作涉及的四个字符，然后再分类讨论一下就行了。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;char s[maxn], t[maxn];int n;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; scanf(\"%s%s\",s,t); int ret = 0; for(int i = 0; i &lt; n / 2; i++) &#123; map&lt;int, int&gt; a; a[s[i]]++; a[s[n-i-1]]++; a[t[i]]++; a[t[n-i-1]]++; if(a.size() == 4) ret += 2; else if(a.size() == 3) &#123; if(s[i] == s[n-i-1]) ret += 2; else ret++; &#125; else if(a.size() == 2) &#123; if(a[s[i]] != 2) ret++; &#125; &#125; if(n &amp; 1) &#123; if(s[n/2] != t[n/2]) ret++; &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"[Codeforces1015E(1,2)] Stars Drawing (贪心,暴力)","slug":"Codeforces1015E-1-2-Stars-Drawing-贪心-暴力","date":"2018-08-01T07:15:25.000Z","updated":"2018-08-06T16:27:05.517Z","comments":true,"path":"2018/08/01/Codeforces1015E-1-2-Stars-Drawing-贪心-暴力/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1015E-1-2-Stars-Drawing-贪心-暴力/","excerpt":"链接： http://codeforces.com/contest/1015/problem/E1 http://codeforces.com/contest/1015/problem/E2 给你一个$n×m$的矩阵，里面的*组成十字（至少要5个构成十字，比如5个的十字大小为1，一次类推），问这里面的*是否能都组成十字。并输出一个方案。","text":"链接： http://codeforces.com/contest/1015/problem/E1 http://codeforces.com/contest/1015/problem/E2 给你一个$n×m$的矩阵，里面的*组成十字（至少要5个构成十字，比如5个的十字大小为1，一次类推），问这里面的*是否能都组成十字。并输出一个方案。 这题暴力，贪心地让每一个*向四个方向延拓尽可能长的范围，并打好标记，存下所有可能的十字，看看这些标记里有没有是*但是为标记的就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1010;constexpr int dx[5] = &#123;0, 0, 1, -1&#125;;constexpr int dy[5] = &#123;1, -1, 0, 0&#125;;using Node = struct &#123; int x, y, v; &#125;;char G[maxn][maxn];bool vis[maxn][maxn];int n, m;vector&lt;Node&gt; p, ret;inline bool ok(int x, int y) &#123; return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;&#125;void gao(int x, int y) &#123; int tot = 1; bool flag = true; bool yes = false; while(flag) &#123; flag = false; int cnt = 0; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i] * tot; int ty = y + dy[i] * tot; if(ok(tx, ty) &amp;&amp; G[tx][ty] == '*') cnt++; &#125; if(cnt != 4) break; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i] * tot; int ty = y + dy[i] * tot; vis[tx][ty] = 1; &#125; flag = true; yes = true; tot++; &#125; if(yes) &#123; vis[x][y] = 1; ret.push_back(&#123;x+1, y+1, tot-1&#125;); &#125;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; p.clear(); ret.clear(); memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; i++) scanf(\"%s\", G[i]); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(G[i][j] == '*') p.push_back(&#123;i, j, 0&#125;); &#125; &#125; if(p.size() == 0) &#123; printf(\"0\\n\"); continue; &#125; for(auto t : p) gao(t.x, t.y); if(ret.size() == 0) &#123; printf(\"-1\\n\"); continue; &#125; bool flag = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(!vis[i][j] &amp;&amp; G[i][j] == '*') &#123; flag = 1; &#125; &#125; &#125; if(flag) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", ret.size()); for(auto t : ret) &#123; printf(\"%d %d %d\\n\", t.x, t.y, t.v); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"}]},{"title":"[Codeforces1015D] Walking Between Houses (构造)","slug":"Codeforces1015D-Walking-Between-Houses-构造","date":"2018-08-01T03:50:49.000Z","updated":"2018-08-06T16:27:02.676Z","comments":true,"path":"2018/08/01/Codeforces1015D-Walking-Between-Houses-构造/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1015D-Walking-Between-Houses-构造/","excerpt":"链接：http://codeforces.com/contest/1015/problem/D 有$1~n$个房子，一个人从$1$出发，每次可以走任意步，现在希望走$k$次，求一个方案，这$k$次能走够$s$步（走到一个房子的地方，下一次再走的时候要以那个地方为起点）。","text":"链接：http://codeforces.com/contest/1015/problem/D 有$1~n$个房子，一个人从$1$出发，每次可以走任意步，现在希望走$k$次，求一个方案，这$k$次能走够$s$步（走到一个房子的地方，下一次再走的时候要以那个地方为起点）。 提供两种构造方法： 1：首先尽可能多地走$n-1$步，然后再走$s-(k-1)$步，最后剩下的都走$1$步。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const LL maxn = 100100;LL n, k, s;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;k,&amp;s)) &#123; LL tot = (n - 1) * k; if(tot &lt; s) &#123; printf(\"NO\\n\"); continue; &#125; if(k &gt; s) &#123; printf(\"NO\\n\"); continue; &#125; LL cur = 1; vector&lt;LL&gt; ret; while(k) &#123; LL t = min(n - 1, s - (k - 1)); cur = cur - t &gt; 0 ? cur - t : cur + t; s -= t; k--; ret.push_back(cur); &#125; printf(\"YES\\n\"); for(int i = 0; i &lt; ret.size(); i++) &#123; printf(\"%lld%c\", ret[i], \" \\n\"[i==ret.size()-1]); &#125; &#125; return 0;&#125; 2：$p=\\frac{s}{k}$，$q=s%k$，走$q$个$p+1$步，$k-q$个$p$步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;LL n, k, s;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;k,&amp;s)) &#123; LL tot = (n - 1) * k; if(tot &lt; s) &#123; printf(\"NO\\n\"); continue; &#125; if(k &gt; s) &#123; printf(\"NO\\n\"); continue; &#125; LL p = s / k; LL q = s % k; vector&lt;LL&gt; ret; LL cur = 1; for(int i = 0; i &lt; q; i++) &#123; ret.push_back((i % 2 == 0) ? p+2 : 1); cur = (i % 2 == 0) ? p+2 : 1; &#125; if(cur == 1) &#123; for(int i = 0; i &lt; k - q; i++) &#123; cur += (i % 2 == 0) ? p : -p; ret.push_back(cur); &#125; &#125; else &#123; for(int i = 0; i &lt; k - q; i++) &#123; cur += (i % 2 == 0) ? -p : p; ret.push_back(cur); &#125; &#125; printf(\"YES\\n\"); for(int i = 0; i &lt; ret.size(); i++) &#123; printf(\"%lld%c\", ret[i], \" \\n\"[i==ret.size()-1]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"}]},{"title":"[Codeforces1013E] Hills(DP)","slug":"Codeforces1013E-Hills-DP","date":"2018-07-31T13:40:19.000Z","updated":"2018-08-06T16:26:57.075Z","comments":true,"path":"2018/07/31/Codeforces1013E-Hills-DP/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/31/Codeforces1013E-Hills-DP/","excerpt":"链接：http://codeforces.com/contest/1013/problem/E 给n个数，允许让每个数删减，现想要求k个严格的局部最大值，k取值为$[1,\\lceil\\frac{n}{2}\\rceil]$。","text":"链接：http://codeforces.com/contest/1013/problem/E 给n个数，允许让每个数删减，现想要求k个严格的局部最大值，k取值为$[1,\\lceil\\frac{n}{2}\\rceil]$。 这dp考的时候没想出来，可以这么做：$f(i,j,k)$表示前$i$个数里有$j$个最大值，此时还讨论第$i$个数是($k=1$)否($k=0$)是局部最大值。 状态转移如下： $k=0$时，$f(i,j,0)$可以更新到$f(i+1,j,0)$上，因为此时$i$和$i+1$都不是局部最大值，因此$j$不会变；或者更新到$f(i+1,j+1,1)$上，此时在$i+1$处为一个局部最大值。 $k=1$时，$f(i,k,1)$更新到$f(i+1,j,0)$上，但是相应地要有删减的代价；也可以更新到$f(i+2,j+1,1)$上，显然$i+1$处必然是一个极小值。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5050;const int inf = 0x7f7f7f7f;int n;int a[maxn];int f[maxn][maxn][2];int update(int x, int y) &#123; return x &gt; y ? 0 : y - x + 1;&#125;int main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; int K = (int)ceil(n / 2.0); memset(f, 0x7f, sizeof(f)); f[1][0][0] = 0; f[1][1][1] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= K; j++) &#123; for(int k = 0; k &lt;= 1; k++) &#123; if(f[i][j][k] == inf) continue; if(k == 0) &#123; f[i+1][j+1][1] = min(f[i+1][j+1][1], f[i][j][k] + update(a[i+1], a[i])); f[i+1][j][0] = min(f[i+1][j][0], f[i][j][k]); &#125; else &#123; f[i+2][j+1][1] = min(f[i+2][j+1][1], f[i][j][k] + update(min(a[i], a[i+2]), a[i+1])); f[i+1][j][0] = min(f[i+1][j][0], f[i][j][k] + update(a[i], a[i+1])); &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= K; i++) &#123; printf(\"%d%c\", min(f[n][i][0], f[n][i][1]), \" \\n\"[i==K]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[Codeforces1013] Round #500 (Div. 2) [based on EJOI]","slug":"CF1013-Codeforces-Round-500-Div-2-based-on-EJOI","date":"2018-07-30T12:54:12.000Z","updated":"2018-08-06T16:26:43.754Z","comments":true,"path":"2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","excerpt":"链接：http://codeforces.com/contest/1013","text":"链接：http://codeforces.com/contest/1013 A：n堆贝壳，第一天每一堆有ai个，现在可以拿走也可以移动任意个，然后给出第二天每一堆的贝壳的数量，问有没有可能。 两天的贝壳求和，如果不等就不可能。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 1111;int a, b;int n;signed main() &#123; // freopen(\"in\", \"r\", stdin); int t; while(~scanf(\"%d\", &amp;n)) &#123; a = 0, b = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;t); a += t; &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\" , &amp;t); b += t; &#125; if(a &gt;= b) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; B：给n个数ai，以及一个数x，现在允许x和ai进行与（&amp;）操作后替换ai，问最少操作多少次，n个数中出现两个相同的数字。 由于和x进行与操作后的结果再和x进行操作的结果不会变，因此每一个数至多和x与1次。考虑到结果只可能是-1 0 1 2，因此存下与操作后的数字结果，讨论一下就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 100100;int n, x;int a[maxn];int vis[maxn], vis1[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;x)) &#123; memset(vis, 0, sizeof(vis)); memset(vis1, 0, sizeof(vis1)); int maxx = -1; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); maxx = max(maxx, a[i]); vis[a[i]]++; vis1[a[i]&amp;x]++; maxx = max(maxx, a[i] &amp; x); &#125; int flag = 0; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis[i] &gt;= 2) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; puts(\"0\"); continue; &#125; flag = 0x7f7f7f7f; for(int i = 1; i &lt;= n; i++) &#123; if((a[i] &amp; x) == a[i]) &#123; if(vis1[a[i]] &gt;= 2) flag = min(flag, 1); &#125; else &#123; if(vis1[a[i]]) flag = min(flag, 1); &#125; &#125; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis1[i] &gt;= 2 &amp;&amp; !vis[i]) &#123; flag = min(flag, 2); &#125; &#125; if(flag == 0x7f7f7f7f) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", flag); &#125; return 0;&#125; C：给2n个数字，让你用这2n个数字构成n个二维平面上的点，要求是构造一个平行于坐标轴的、包括所有点的矩形，并且矩形面积最小（面积可以为0）。 很容易想到的是对a进行排序，之后将2n个数分为x坐标和y坐标两个集合，然后依次结合构成点。画图后发现答案就是两个集合的极差乘积，我们希望让这两个集合的极差尽可能小，因此每次从两个集合中拿出最小的放到对方的集合里，这里滑动窗口模拟一下就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;using LL = unsigned long long;const int maxn = 200100;int n;LL a[maxn];pair&lt;LL, LL&gt; p[maxn];map&lt;LL, int&gt; vis;deque&lt;LL&gt; r, q;multiset&lt;LL&gt; rr, qq;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; vis.clear(); for(int i = 1; i &lt;= 2 * n; i++) &#123; cin &gt;&gt; a[i]; vis[a[i]]++; &#125; sort(a+1, a+2*n+1); bool flag = 0; for(auto p : vis) &#123; if(p.second &gt;= n) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; printf(\"0\\n\"); continue; &#125; r.clear(); q.clear(); rr.clear(); qq.clear(); LL x, y; for(int i = 1; i &lt;= n; i++) &#123; r.push_back(a[i]); rr.insert(a[i]); &#125; for(int i = n+1; i &lt;= 2*n; i++) &#123; q.push_back(a[i]); qq.insert(a[i]); &#125; LL ret = 9223372036854775800LL; for(int i = 1; i &lt;= n; i++) &#123; ret = min(ret, ((*rr.rbegin())-(*rr.begin()))*((*qq.rbegin())-(*qq.begin()))); x = r.front(); y = q.front(); r.push_back(y); q.push_back(x); r.pop_front(); q.pop_front(); rr.erase(rr.lower_bound(x)), qq.erase(qq.lower_bound(y)); rr.insert(y); qq.insert(x); &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; return 0;&#125; D：要向一个n×m的矩阵里画叉，并且当三个叉构成如下图所示的操作： 当到左图的情况时，会如右图：①的位置会补上（也就是构成了一个矩形）。 现在给你一个n×m的矩阵，以及一些画了叉的位置，问你最少需要手动画多少个叉，能够利用上述操作将整个矩阵填满。 考虑一个叉都不画的情况，最少需要画n+m-1（就是画一个十字）就能利用上述操作将矩阵填满。 再来考虑这个操作的实质：比方说现在有了(x1,y1)、(x1,y2)、(x2,y1)三个点，那么第四个点(x2,y2)实际上是没有贡献的，如下图： 转换成森林上，希望把坐标这个森林连成一片，问最少要加多少条边。这样我们读入数据的时候，x和y连起来（为了区别x和y，y+n来做分层），当他们的父亲不一样的时候，说明这个连接是必须有的，记一次数。之后用n+m-1减掉这个必要的计数就行了。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;LL, LL&gt; pll;const int maxn = 4000100;int n, m, q;int pre[maxn];int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;int unite(int x, int y) &#123; x = find(x); y = find(y); if(x != y) &#123; pre[x] = y; return 1; &#125; return 0;&#125;int main() &#123; // freopen(\"in\", \"r\", stdin); int x, y; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q)) &#123; for(int i = 1; i &lt;= n + m; i++) &#123; pre[i] = i; &#125; int cnt = 0; for(int i = 0; i &lt; q; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); if(unite(x, y+n)) cnt++; &#125; printf(\"%d\\n\", n+m-1-cnt); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"并查集","slug":"并查集","permalink":"https://vincentxwd.github.io/blog/tags/并查集/"},{"name":"STL","slug":"STL","permalink":"https://vincentxwd.github.io/blog/tags/STL/"}]},{"title":"[Codeforces1011] Round #499 (Div. 2)","slug":"CF1011-Codeforces-Round-499-Div-2","date":"2018-07-29T13:01:44.000Z","updated":"2018-08-06T16:29:05.035Z","comments":true,"path":"2018/07/29/CF1011-Codeforces-Round-499-Div-2/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/29/CF1011-Codeforces-Round-499-Div-2/","excerpt":"用hexo搭了博客，以后就在这里写题解和随笔了。","text":"用hexo搭了博客，以后就在这里写题解和随笔了。 $$mathjax测试：C_i=\\sum_{j×k=i}A_j*B_k$$复健开了一场CF div2，感觉非常不好啊。。 比赛链接是http://codeforces.com/contest/1011 A：n个字符取k个，不能取字典序相邻的，也不能取相同的。就这样取，问最小的ascii-‘a’+1的和是多少。 贪心，给字符排个序，取第一个，然后后面的取最小的。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;char s[maxn];int n, k;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; scanf(\"%s\", s); sort(s, s+n); int pre = 0, ret = s[0] - 'a' + 1, tot = 1; for(int i = 1; i &lt; n; i++) &#123; if(tot &gt;= k) break; if(s[i] - s[pre] &gt; 1) &#123; ret += s[i] - 'a' + 1; pre = i; tot++; &#125; &#125; if(tot &lt; k) &#123; printf(\"-1\\n\"); &#125; else printf(\"%d\\n\", ret); &#125; return 0;&#125; B：n个人吃东西，一共m个东西，每个东西都有一类。每个人每天只能吃一个同一类东西，问怎么分配这m个东西，让这n个人吃得时间最久。 m很小，直接遍历天数day，然后贪心地check就ok了（数据量大了套个二分就行）。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;int n, m;int a[maxn], vis[maxn];int ok(int day) &#123; int tot = 0; for(int i = 0; i &lt; 101; i++) &#123; if(vis[i] &gt;= day) tot += (int)(vis[i] / (double)day); &#125; return tot &gt;= n;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; int lo = 0, hi = 100000; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;a[i]); vis[a[i]]++; &#125; if(n &gt; m) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0; for(int mid = 0; mid &lt; 101; mid++) &#123; if(ok(mid)) ret = mid; &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125; C：n个星球，一个人坐重量为m的飞船从1出发到n，需要走1-&gt;2-&gt;..-&gt;n-&gt;1这样的路径，从每个点起飞要消耗ai的燃油，在每个点降落要消耗bi的燃油，燃油只能从1上带，问这人要带多少燃油才能完成这个路径。 二分燃油的量，判断是否满足，或从1-&gt;n-&gt;n-1-&gt;…1逆推，上一次的燃油量是x*m/(x-1)，x为起飞or降落的消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const double eps = 1e-9;int n, m;double a[maxn], b[maxn];int ok(double fuel) &#123; double tot = fuel + m; for(int i = 1; i &lt;= n - 1; i++) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i+1]; &#125; for(int i = n; i &gt;= 2; i--) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i-1]; &#125; return tot - m &gt;= eps;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; &#125; double ret = m; for(int i = 1; i &lt; n; i++) &#123; ret = b[i] * ret / (b[i] - 1.0); ret = a[i+1] * ret / (a[i+1] - 1.0); &#125; ret = b[n] * ret / (b[n] - 1.0); ret = a[1] * ret / (a[1] - 1.0); ret -= m; if(ret &gt; 1e9) &#123; printf(\"-1\\n\"); &#125; else printf(\"%.10f\\n\", ret); &#125; return 0;&#125; D：猜一个1到m的数字x，可以询问最多60次。每次回答有可能是假的，假的情况那么会输出真答案判别的相反数（大于的时候返回1，如果假的情况就返回-1，小于同理），回答的真假情况序列p的长为n，回答按照这个序列循环返回结果。求这个数字x。 可以用数字1去试探n次（当然答案是1的时候可以直接结束程序了），把n次询问的真假情况预处理出来记下，之后就可以愉快地二分x，根据上面预处理出来的真假情况修改返回结果了。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;int p[maxn];int n, m;int query(int y) &#123; printf(\"%d\\n\", y); fflush(stdout); int t; scanf(\"%d\", &amp;t); if(t == 0 || t == 2) exit(0); return t;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;m,&amp;n)) &#123; memset(p, 0, sizeof(p)); for(int i = 0; i &lt; n; i++) &#123; int t = query(1); p[i] = (t == 1); &#125; int lo = 2, hi = m; for(int q = 0; ; q++) &#123; int mid = (lo + hi) &gt;&gt; 1; int t = query(mid); if(!p[q%n]) t = -t; if(t == 1) lo = mid + 1; else hi = mid - 1; &#125; &#125; return 0;&#125; E：n个数，每个数可以取任意次，相加后对k取模。求模的结果的个数。 统计k和每个数的gcd，答案就是k/gcd，依次取0,k/gcd,2k/gcd…就行了。过阵子尝试证明一下，相关概念有：有限域，生成元，生成多项式，循环群，裴蜀定理。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 100100;int n;LL k;LL a[maxn];bool vis[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%lld\",&amp;n,&amp;k)) &#123; memset(vis, 0, sizeof(vis)); LL x = k; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); x = __gcd(x, a[i]); &#125; printf(\"%lld\\n\", k / x); for(LL i = 0; i &lt; k; i+=x) &#123; printf(\"%lld \", i); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/题解/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"},{"name":"交互题","slug":"交互题","permalink":"https://vincentxwd.github.io/blog/tags/交互题/"}]},{"title":"2018牛客多校01 J Different Integers","slug":"2018牛客多校01-J-Different-Integers","date":"2018-07-20T04:17:33.000Z","updated":"2018-08-06T16:26:01.847Z","comments":true,"path":"2018/07/20/2018牛客多校01-J-Different-Integers/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-J-Different-Integers/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/J n个数，q次查询l,r。求[1,l]和[r,n]中不同数的个数。","text":"链接：https://www.nowcoder.com/acm/contest/139/J n个数，q次查询l,r。求[1,l]和[r,n]中不同数的个数。 这题首先开二倍数组，然后在后n个位置重新存一遍这n个数，这样就相当于查询[r, n+l]内不同数的个数，用莫队或者bit离线计数都能做（代码是莫队）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std; inline bool scan_d(int &amp;num) &#123; char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!='-'&amp;&amp;(in&lt;'0'||in&gt;'9')) in=getchar(); if(in=='-')&#123; IsN=true;num=0;&#125; else num=in-'0'; while(in=getchar(),in&gt;='0'&amp;&amp;in&lt;='9')&#123; num*=10,num+=in-'0'; &#125; if(IsN) num=-num; return true;&#125; const int maxn = 100100;using Query = struct &#123; int l, r, ret, id; &#125;;int n, m;int a[maxn&lt;&lt;1], be[maxn&lt;&lt;1], L, R;Query q[maxn];int vis[maxn], sz; inline void add(int x, int &amp;ret) &#123; vis[x]++; if(vis[x] == 1) ret++;&#125; inline void remove(int x, int &amp;ret) &#123; vis[x]--; if(vis[x] == 0) ret--;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; sz = static_cast&lt;int&gt;(sqrt(n)); memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i++) &#123; scan_d(a[i]); a[n+i] = a[i]; be[i] = static_cast&lt;int&gt;(i / sz); be[i+n] = static_cast&lt;int&gt;((i + n) / sz); &#125; for(int i = 1; i &lt;= m; i++) &#123; scan_d(q[i].r); scan_d(q[i].l); q[i].r += n; q[i].id = i; &#125; sort(q+1, q+m+1, [](Query a, Query b) &#123; return be[a.l] == be[b.l] ? a.r &lt; b.r : a.l &lt; b.l; &#125;); int ret = 0; L = 1, R = 0; for(int i = 1; i &lt;= m; i++) &#123; while(L &lt; q[i].l) &#123; remove(a[L], ret); L++; &#125; while(L &gt; q[i].l) &#123; L--; add(a[L], ret); &#125; while(R &lt; q[i].r) &#123; R++; add(a[R], ret); &#125; while(R &gt; q[i].r) &#123; remove(a[R], ret); R--; &#125; q[i].ret = ret; &#125; sort(q+1, q+m+1, [](Query a, Query b)&#123; return a.id &lt; b.id; &#125;); for(int i = 1; i &lt;= m; i++) &#123; printf(\"%d\\n\", q[i].ret); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"莫队算法","slug":"莫队算法","permalink":"https://vincentxwd.github.io/blog/tags/莫队算法/"},{"name":"离线","slug":"离线","permalink":"https://vincentxwd.github.io/blog/tags/离线/"},{"name":"树状数组","slug":"树状数组","permalink":"https://vincentxwd.github.io/blog/tags/树状数组/"}]},{"title":"2018牛客多校01 D Two Graphs","slug":"2018牛客多校01-D-Two-Graphs","date":"2018-07-20T04:10:51.000Z","updated":"2018-08-06T16:25:57.318Z","comments":true,"path":"2018/07/20/2018牛客多校01-D-Two-Graphs/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-D-Two-Graphs/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/D 求G1的同构图，是G2的子图。","text":"链接：https://www.nowcoder.com/acm/contest/139/D 求G1的同构图，是G2的子图。 暴力枚举全排列，对于每一个排列，看看G2中是否每一条边都存在，然后再看看是否每一条边都在G1中存在（这里存在的话必然会重复计数），然后用上一个计数结果除以下一个即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn = 11;int n;int m1, m2;int id[maxn];int b[maxn][maxn], c[maxn][maxn];vector&lt;int&gt; a[maxn]; signed main() &#123; // freopen(\"in\", \"r\", stdin); int x, y; while(~scanf(\"%d%d%d\",&amp;n,&amp;m1,&amp;m2)) &#123; for(int i = 1; i &lt;= n; i++) &#123; a[i].clear(); &#125; memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); for(int i = 1; i &lt;= m1; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); a[x].push_back(y); a[y].push_back(x); c[x][y] = c[y][x] = 1; &#125; for(int i = 1; i &lt;= m2; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); b[x][y] = b[y][x] = 1; &#125; for(int i = 1; i &lt;= n; i++) &#123; id[i] = i; &#125; if(m1 &gt; m2) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0, tot = 0; do &#123; int flag = 1; for(x = 1; x &lt;= n; x++) &#123; for(int j = 0; j &lt; a[x].size(); j++) &#123; y = a[x][j]; if(!b[id[x]][id[y]]) &#123; flag = 0; break; &#125; &#125; &#125; if(flag) ret++; flag = 1; for(x = 1; x &lt;= n; x++) &#123; for(int j = 0; j &lt; a[x].size(); j++) &#123; y = a[x][j]; if(!c[id[x]][id[y]]) &#123; flag = 0; break; &#125; &#125; &#125; if(flag) tot++; &#125;while(next_permutation(id+1, id+n+1)); printf(\"%d\\n\", ret / tot); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"枚举","slug":"枚举","permalink":"https://vincentxwd.github.io/blog/tags/枚举/"}]},{"title":"2018牛客多校01 A Monotonic Matrix","slug":"2018牛客多校01-A-Monotonic-Matrix","date":"2018-07-20T03:54:47.000Z","updated":"2018-08-06T16:28:15.918Z","comments":true,"path":"2018/07/20/2018牛客多校01-A-Monotonic-Matrix/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-A-Monotonic-Matrix/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/A 求一个n*m的0、1、2矩阵（满足左上小于右下）的构造方案数。","text":"链接：https://www.nowcoder.com/acm/contest/139/A 求一个n*m的0、1、2矩阵（满足左上小于右下）的构造方案数。 方案数就等于这两条可以重合（不可相交）的分界线的种类数，如下图： 即：给定起点(n,0)、终点(0,m)，只能向上和向右走，问有多少种走法，其实就是向右走m步向上走n步的组合数：$$C_{n+m}^m或C_{n+m}^n$$这里给出Lindström–Gessel–Viennot引理的应用：给一张无权有向无环图，给定n个起点和对应的n个终点，求n条不相交路径的方案数，引理给出结果为： 其中$a_{i}$表示路径i的起点，$b_{i}$表示路径i的终点。答案就是M的行列式的值。 对于本两条线的起点和终点不能重叠而且得和原方案等价（方案数等价即可），这就需要变换一下。把起终点向左上平移一下，将其中的一对起终点平移到$(n-1,-1)$和$(-1,m-1)$去，就有$e(a_1,b_1)=e(a_2,b_2)=C_{n+m}^n$，$e(a_1,b_2)=C_{n+m}^{n+1}$，$e(a_2,b_1)=C_{n+m}^{m+1}$那么针对本题的答案就是：$${C_{n+m}^n}^2-C_{n+m}^{n+1}×C_{n+m}^{m+1}$$ 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;const LL mod = 1e9+7;const int maxn = 3010;int n, m;LL c[maxn][maxn]; void init() &#123; memset(c,0,sizeof(c)); c[0][0]=c[1][0]=c[1][1]=1; for(int i = 2; i &lt; maxn; i++) &#123; c[i][0] = c[i][i] = 1; for(int j = 1; j &lt; i; j++) &#123; c[i][j] = c[i-1][j] + c[i-1][j-1]; c[i][j] %= mod; &#125; &#125;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); init(); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; LL ret = c[n+m][n]*c[n+m][n]; ret %= mod; LL tmp = c[n+m][n+1]*c[n+m][m+1]; tmp %= mod; ret -= tmp; ret += mod; ret %= mod; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://vincentxwd.github.io/blog/categories/题解/"},{"name":"2018牛客多校","slug":"题解/2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/题解/2018牛客多校/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"}]}]}