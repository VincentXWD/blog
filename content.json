{"meta":{"title":"Kirai","subtitle":"我好菜啊 QAQ | I Good Vegetable A QAQ","description":null,"author":"Kirai","url":"https://vincentxwd.github.io/blog"},"pages":[{"title":"404","date":"2018-07-29T11:33:50.000Z","updated":"2018-07-29T11:33:50.336Z","comments":true,"path":"404/index.html","permalink":"https://vincentxwd.github.io/blog/404/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-29T12:57:51.000Z","updated":"2018-07-31T04:26:10.039Z","comments":true,"path":"categories/index.html","permalink":"https://vincentxwd.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-07-30T05:59:54.000Z","updated":"2018-07-31T04:32:18.100Z","comments":true,"path":"about/index.html","permalink":"https://vincentxwd.github.io/blog/about/index.html","excerpt":"","text":"kirai，在读渣硕，方向是ML和CV。竞赛败犬，科研萌新，喜欢打osu! mania。 如果您在招实习，点击这里可能会多了解一点QAQ。 有问题可以邮箱联系，也可以QQ：107850580。"},{"title":"标签","date":"2018-07-29T12:56:26.000Z","updated":"2018-07-30T07:02:56.361Z","comments":true,"path":"tags/index.html","permalink":"https://vincentxwd.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2018-07-29T11:33:36.000Z","updated":"2018-07-30T07:00:53.427Z","comments":true,"path":"search/index.html","permalink":"https://vincentxwd.github.io/blog/search/index.html","excerpt":"","text":""}],"posts":[{"title":"2018牛客多校05 E room (费用流)","slug":"2018牛客多校05-E-room-费用流","date":"2018-08-03T05:47:19.000Z","updated":"2018-08-03T05:52:42.451Z","comments":true,"path":"2018/08/03/2018牛客多校05-E-room-费用流/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/2018牛客多校05-E-room-费用流/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/E n个宿舍，每个宿舍住4个人，给两年的住宿情况，问最少调换多少人，能从前一年的住宿状态调换到后一年的住宿状态（宿舍顺序不影响）。","text":"链接：https://www.nowcoder.com/acm/contest/143/E n个宿舍，每个宿舍住4个人，给两年的住宿情况，问最少调换多少人，能从前一年的住宿状态调换到后一年的住宿状态（宿舍顺序不影响）。 比赛的时候没时间看，补题的时候发现是一道挺好想的费用流问题。 考虑宿舍整体，当一个宿舍变为另一个宿舍的时候，我们的代价是这两个宿舍中不同人的个数，按照这条规律，我们可以建图： 单独建超级源和超级汇，之后按照不同年份和不同宿舍建点，不同年的每个宿舍之间连接一条边，容量为1，费用为不同人的个数。源点连接前一年的点，容量为1费用为0，后一年的点连汇点，容量为1费用为0。这样跑一下最小费用最大流就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef struct Node &#123; int u, v, next; LL c, w;&#125;Node;const int maxn = 210;const int maxm = 40100;const LL mod = 0x3f3f3f3fLL;const LL inf = (1LL&lt;&lt;55);int tot, head[maxn];LL dist[maxn];LL cost, flow;Node e[maxm];int pre[maxn];bool visit[maxn];queue&lt;int&gt; Q;int S, T, N;void init() &#123; S = T = N = 0; memset(head, -1, sizeof(head)); tot = 0;&#125;void adde(int u, int v, LL c, LL w) &#123; e[tot].u = u; e[tot].v = v; e[tot].c = c; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++; e[tot].u = v; e[tot].v = u; e[tot].c = 0; e[tot].w = -w; e[tot].next = head[v]; head[v] = tot++;&#125;bool spfa(int s, int t, int n) &#123; int i; for(i = 0; i &lt;= n; i++) &#123; dist[i] = inf; visit[i] = 0; pre[i] = -1; &#125; while(!Q.empty()) Q.pop(); Q.push(s); visit[s] = true; dist[s] = 0; pre[s] = -1; while(!Q.empty()) &#123; int u = Q.front(); visit[u] = false; Q.pop(); for(int j = head[u]; j != -1; j = e[j].next) &#123; if(e[j].c &gt; 0 &amp;&amp; dist[u] + e[j].w &lt; dist[e[j].v]) &#123; dist[e[j].v] = dist[u] + e[j].w; pre[e[j].v] = j; if(!visit[e[j].v]) &#123; Q.push(e[j].v); visit[e[j].v] = true; &#125; &#125; &#125; &#125; // return dist[t] &lt; 0; // 求可行流 if(dist[t] == inf) return false; // 求最小费用流 else return true;&#125;LL ChangeFlow(int t) &#123; LL det = mod; int u = t; while(~pre[u]) &#123; u = pre[u]; det = min(det, e[u].c); u = e[u].u; &#125; u = t; while(~pre[u]) &#123; u = pre[u]; e[u].c -= det; e[u ^ 1].c += det; u = e[u].u; &#125; return det;&#125;LL MinCostFlow(int s, int t, int n) &#123; LL mincost, maxflow; mincost = maxflow = 0; while(spfa(s, t, n)) &#123; LL det = ChangeFlow(t); mincost += det * dist[t]; maxflow += det; &#125; cost = mincost; flow = maxflow; return mincost;&#125;int n;int vis[maxn][maxn][2];signed main() &#123; // freopen(\"in\", \"r\", stdin); int x; while(~scanf(\"%d\", &amp;n)) &#123; init();T = 2 * n + 1; N = T + 1; memset(vis, 0, sizeof(vis)); int tot = n * 4; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= 4; j++) &#123; scanf(\"%d\", &amp;x); vis[i][x][0] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= 4; j++) &#123; scanf(\"%d\", &amp;x); vis[i][x][1] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; adde(S, i, 1, 0); adde(i+n, T, 1, 0); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; int diff = 0; for(int k = 1; k &lt;= tot; k++) &#123; if(vis[i][k][0] == vis[j][k][1] &amp;&amp; vis[i][k][0] == 1) &#123; diff++; &#125; &#125; adde(i, j+n, 1, 4-diff); &#125; &#125; cout &lt;&lt; MinCostFlow(S, T, N) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"2018牛客多校","slug":"2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://vincentxwd.github.io/blog/tags/费用流/"}]},{"title":"[HDOJ6301] 18多校01 Distinct Values (莫队算法, 构造)","slug":"HDOJ6301-Distinct-Values-莫队算法","date":"2018-08-03T04:22:10.000Z","updated":"2018-08-03T04:32:29.230Z","comments":true,"path":"2018/08/03/HDOJ6301-Distinct-Values-莫队算法/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/HDOJ6301-Distinct-Values-莫队算法/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6301 给出m个区间，要求构造一个指定区间内的数字不能相等，并且数字在$[1,n]$之间，求构造的字典序最小的方案。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6301 给出m个区间，要求构造一个指定区间内的数字不能相等，并且数字在$[1,n]$之间，求构造的字典序最小的方案。 首先给区间排个序，按照左端点小、右端点小的规则排。接下来维护两个指针L、R，从左到右往里塞，然后用类似莫队的更新方法去维护数列，同时维护目前可用的数字。 整体复杂度为$O(n+m)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using Node = struct &#123; int l, r;&#125;;const int maxn = 100100;int n, m, a[maxn];Node p[maxn];set&lt;int&gt; st;signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while(T--) &#123; st.clear(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\",&amp;p[i].l,&amp;p[i].r); &#125; sort(p+1, p+m+1, [](Node a, Node b) &#123; return a.l == b.l ? a.r &lt; b.r : a.l &lt; b.l; &#125;); for(int i = 1; i &lt;= n; i++) &#123; st.insert(i); a[i] = 1; &#125; int L = p[1].l, R = p[1].r; for(int i = L; i &lt;= R; i++) &#123; a[i] = *st.begin(); st.erase(a[i]); &#125; for(int i = 2; i &lt;= m; i++) &#123; while(L &lt; p[i].l) &#123; st.insert(a[L++]); &#125; while(R &lt; p[i].r) &#123; if(R + 1 &lt; p[i].l) R++; else &#123; a[++R] = *st.begin(); st.erase(a[R]); &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; printf(\"%d%c\", a[i], \" \\n\"[i==n]); &#125; &#125; return 0;&#125;","categories":[{"name":"HDOJ","slug":"HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/HDOJ/"},{"name":"2018杭电多校","slug":"HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/HDOJ/2018杭电多校/"}],"tags":[{"name":"莫队算法","slug":"莫队算法","permalink":"https://vincentxwd.github.io/blog/tags/莫队算法/"},{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"}]},{"title":"[HDOJ6299] 18多校01 Balanced Sequence (贪心)","slug":"HDOJ6299-Balanced-Sequence-贪心","date":"2018-08-03T04:18:41.000Z","updated":"2018-08-03T04:23:41.802Z","comments":true,"path":"2018/08/03/HDOJ6299-Balanced-Sequence-贪心/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/HDOJ6299-Balanced-Sequence-贪心/","excerpt":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6299 n个括号串，问如何排列这n个串，使得连起来后()匹配的对数最多（不用连续）。","text":"链接：http://acm.hdu.edu.cn/showproblem.php?pid=6299 n个括号串，问如何排列这n个串，使得连起来后()匹配的对数最多（不用连续）。 首先串内匹配并记录答案。之后尽可能让左括号多的在左边，右括号多的在右边排序，再贪心扫一遍，只维护左括号的个数，同时根据下一个串右括号的个数统计答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using Node = struct &#123; int l, r, v;&#125;;const int maxn = 100100;int n;vector&lt;Node&gt; p;char s[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d\", &amp;n); p.resize(n); for(int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", s); int tot = 0; int l = 0, r = 0; for(int j = 0; s[j]; j++) &#123; if(s[j] == '(') &#123; l++; &#125; else &#123; if(l != 0) l--, tot++; else r++; &#125; &#125; p[i].l = l, p[i].r = r, p[i].v = tot; &#125; sort(p.begin(), p.end(), [](Node a, Node b) &#123; if(a.l &gt; a.r) &#123; return b.l &gt; b.r ? a.r &lt; b.r : true; &#125; return b.l &lt;= b.r ? a.l &gt; b.l : false; &#125;); int l = 0, r = 0, ret = 0; for(int i = 0; i &lt; n - 1; i++) &#123; ret += p[i].v; l += p[i].l; r += p[i+1].r; ret += min(l, r); l -= min(l, r); r = 0; &#125; ret += p[n-1].v; printf(\"%d\\n\", ret * 2); &#125; return 0;&#125;","categories":[{"name":"HDOJ","slug":"HDOJ","permalink":"https://vincentxwd.github.io/blog/categories/HDOJ/"},{"name":"2018杭电多校","slug":"HDOJ/2018杭电多校","permalink":"https://vincentxwd.github.io/blog/categories/HDOJ/2018杭电多校/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"}]},{"title":"[Hackerrank] Array Partition (并查集, 数学)","slug":"Hackerrank-Array-Partition-并查集-数学","date":"2018-08-02T16:52:18.000Z","updated":"2018-08-02T17:01:59.160Z","comments":true,"path":"2018/08/03/Hackerrank-Array-Partition-并查集-数学/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/03/Hackerrank-Array-Partition-并查集-数学/","excerpt":"链接：https://www.hackerrank.com/contests/hourrank-29/challenges/array-partition 给n个数，让你将这n个数拆分成两个集合，使得两个集合分别乘积互质，求拆分方案数。","text":"链接：https://www.hackerrank.com/contests/hourrank-29/challenges/array-partition 给n个数，让你将这n个数拆分成两个集合，使得两个集合分别乘积互质，求拆分方案数。 第一次打Hackerrank，一个小时三道题还是很刺激的。这道题比赛的时候没调出来，只拿了部分分，有点遗憾啊~）ps：衣服还是很难拿的，top10 才有，这场出现了tourist等众神牛，这种场拿衣服还是不想了。 根据题目的要求，显然拥有相同因数的数字必须呆在同一个集合（1除外，这是个trick，后面会说），考虑用一个方法，将所有拥有至少一个公共因数的数字划为同一个集合，然后再对所有不连通的集合进行计数，会发现：当有$n$个集合的时候，我们的划分方案数为$2^{n}-2$。 很显然可以用并查集维护每一个数的因数的连通情况，因此我们在枚举每一个数的因数的同时，将因数和这个数并到一起就可以了。这里需要特别注意的是，每一个1都可以分到一个单独的集合里，因此计数的时候需要单独考虑~ 整体复杂度为$O(n\\sqrt{n})$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758typedef long long LL;const int maxn = 1000010;const LL mod = 1e9+7;int pre[maxn];set&lt;int&gt; vis;int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if(x != y) &#123; pre[x] = y; &#125;&#125;int solve(vector&lt;int&gt; a) &#123; int cnt = 0; int nn = 1 &lt;&lt; a.size(); vis.clear(); for(int i = 0; i &lt; maxn; i++) pre[i] = i; for(int i = 0; i &lt; a.size(); i++) &#123; if(a[i] == 1) cnt++; vis.insert(a[i]); int tmp = a[i]; int aa = (int)sqrt(a[i]) + 1; for(int j = 2; j &lt;= aa; j++) &#123; if(tmp % j == 0) &#123; unite(a[i], j); vis.insert(j); while(tmp % j == 0) tmp /= j; &#125; &#125; if(tmp != 1) unite(a[i], tmp); &#125; map&lt;int, int&gt; block; for(int i = 0; i &lt; maxn; i++) &#123; if(vis.find(i) != vis.end()) &#123; block[find(i)]++; &#125; &#125; if(block.size() &lt; 2) &#123; return 0; &#125; LL ret = 1; for(int i = 0; i &lt; block.size(); i++) &#123; ret *= 2; ret %= mod; &#125; for(int i = 0; i &lt; cnt - 1; i++) &#123; ret *= 2; ret %= mod; &#125; ret -= 2; ret += mod; ret %= mod; return ret;&#125;","categories":[{"name":"Hackerrank","slug":"Hackerrank","permalink":"https://vincentxwd.github.io/blog/categories/Hackerrank/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"并查集","slug":"并查集","permalink":"https://vincentxwd.github.io/blog/tags/并查集/"}]},{"title":"2018牛客多校05 J plan(数学，规律)","slug":"2018牛客多校05-J-plan-数学，规律","date":"2018-08-02T14:13:21.000Z","updated":"2018-08-02T14:21:24.374Z","comments":true,"path":"2018/08/02/2018牛客多校05-J-plan-数学，规律/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/02/2018牛客多校05-J-plan-数学，规律/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/J n个人住宾馆，双人间价格为p2，三人间价格为p3，如何安排，使总花费最少。","text":"链接：https://www.nowcoder.com/acm/contest/143/J n个人住宾馆，双人间价格为p2，三人间价格为p3，如何安排，使总花费最少。 列方程，枚举最近的6个结果即可。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;LL n, a, b; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;a,&amp;b)) &#123; LL ret = 1e18; for(LL i = 0; i &lt;= 6; i++) &#123; ret = min(ret, (n+1-i)/2*a+(i+2)/3*b); ret = min(ret, (n+2-i)/3*b+(i+1)/2*a); &#125; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"2018牛客多校","slug":"2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"2018牛客多校05 G max(数学，规律)","slug":"2018牛客多校05-G-max-数学，规律","date":"2018-08-02T14:12:51.000Z","updated":"2018-08-02T14:21:26.030Z","comments":true,"path":"2018/08/02/2018牛客多校05-G-max-数学，规律/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/02/2018牛客多校05-G-max-数学，规律/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/G 给定c、n，求两个整数a、b，使得$gcd(a,b)=c, 1≤a,b≤n$","text":"链接：https://www.nowcoder.com/acm/contest/143/G 给定c、n，求两个整数a、b，使得$gcd(a,b)=c, 1≤a,b≤n$ 很容易发现只需要选择最接近n的c的倍数数、以及次接近n的c的倍数乘积就是最大的。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;LL c, n; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld\",&amp;c,&amp;n)) &#123; if(c &gt; n) &#123; printf(\"-1\\n\"); continue; &#125; if(c == 1) &#123; if(n == 1) printf(\"1\\n\"); else printf(\"%lld\\n\", n*(n-1)); continue; &#125; bool flag = 1; if(n == c) &#123; printf(\"%lld\\n\", c * c); continue; &#125; if(n % c == 0) printf(\"%lld\\n\", n*(n-c)); else &#123; LL t = n / c * c; if(t == c) printf(\"%lld\\n\", t*t); else printf(\"%lld\\n\", t*(t-c)); &#125; &#125; return 0;&#125;","categories":[{"name":"2018牛客多校","slug":"2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"2018牛客多校05 A gpa (01分数规划)","slug":"2018牛客多校05-A-gpa-01分数规划","date":"2018-08-02T13:43:55.000Z","updated":"2018-08-02T14:25:09.901Z","comments":true,"path":"2018/08/02/2018牛客多校05-A-gpa-01分数规划/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/02/2018牛客多校05-A-gpa-01分数规划/","excerpt":"链接：https://www.nowcoder.com/acm/contest/143/A 一个人有n个成绩，然后现在他可以删掉其中至多k个，使得目标方程$\\frac{\\sum[s[i]c[i]}{\\sum s[i]}$的值最大，问这个值可以是多少。","text":"链接：https://www.nowcoder.com/acm/contest/143/A 一个人有n个成绩，然后现在他可以删掉其中至多k个，使得目标方程$\\frac{\\sum[s[i]c[i]}{\\sum s[i]}$的值最大，问这个值可以是多少。 这题和POJ2976是很类似的，是用01分数规划可以解决的问题。01分数规划可以看做是一种思想，可以用二分查找实现。针对这一道题，我们希望让目标方程尽可能大，于是可以假设：$$\\frac{\\sum[s[i]c[i]}{\\sum s[i]} \\geq L$$移项后得：$$\\sum{s_ic_i-L×s_i}\\geq0$$于是我们可以二分$L$，对该式中的$s_ic_i-L×s_i$进行计算并排序，删掉最小的k个后，查看是否满足题意。当收敛时，即$L$近似为式子的最大值。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std; const double eps = 1e-9;const int maxn = 101000;int n, k, m;int s[maxn], c[maxn];double d[maxn]; bool ok(double L) &#123; for(int i = 1; i &lt;= n; i++) d[i] = (double)(s[i] * c[i]) - L * (double)s[i]; sort(d+1, d+n+1); double tot = .0; for(int i = k+1; i &lt;= n; i++) &#123; tot += d[i]; &#125; return tot &gt; 0;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;s[i]); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;c[i]); double lo = .0, hi = 1e3; double ret = .0; while(hi - lo &gt; eps) &#123; double mid = (lo + hi) / 2.0; if(ok(mid)) lo = mid; else hi = mid; &#125; printf(\"%.11f\\n\", lo); &#125; return 0;&#125;","categories":[{"name":"2018牛客多校","slug":"2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"},{"name":"01分数规划","slug":"01分数规划","permalink":"https://vincentxwd.github.io/blog/tags/01分数规划/"}]},{"title":"[Codeforces1006E] Military Problem(DFS)","slug":"Codeforces1006E-Military-Problem-DFS","date":"2018-08-01T15:40:55.000Z","updated":"2018-08-01T15:49:20.605Z","comments":true,"path":"2018/08/01/Codeforces1006E-Military-Problem-DFS/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1006E-Military-Problem-DFS/","excerpt":"链接：http://codeforces.com/contest/1006/problem/E 给一棵$n$个节点的树和$q$次询问，每次询问两个数$u、k$，表示第u个节点的第k个前序遍历的结果是谁。","text":"链接：http://codeforces.com/contest/1006/problem/E 给一棵$n$个节点的树和$q$次询问，每次询问两个数$u、k$，表示第u个节点的第k个前序遍历的结果是谁。 这么水的题竟然放在了E，可能这就是div 3吧… dfs一遍，维护出每个节点$i$的前序遍历的次序$ret_i$，以及该节点的子树中共计多少个节点$sz_i$，可以利用$ret_i$维护出第$j$号遍历的节点是$id_i$。当我们要求的某节点开始往后数$k$个数不存在时，输出-1；否则我们的答案就是$ret[id[u]+k-1]$。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200100;int n, q, tot;vector&lt;int&gt; G[maxn];int ret[maxn], sz[maxn], id[maxn];int dfs(int u, int p) &#123; ret[++tot] = u; int son = 1; for(int i = 0; i &lt; G[u].size(); i++) &#123; int &amp;v = G[u][i]; if(v == p) continue; son += dfs(v, u); &#125; return sz[u] = son;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); int u, k; while(~scanf(\"%d%d\",&amp;n,&amp;q)) &#123; tot = 0; memset(ret, -1, sizeof(ret)); memset(sz, 0, sizeof(sz)); for(int i = 1; i &lt;= n; i++) G[i].clear(); for(int i = 2; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;u); G[i].push_back(u); G[u].push_back(i); &#125; sz[1] = dfs(1, -1); for(int i = 1; i &lt;= n; i++) id[ret[i]] = i; while(q--) &#123; scanf(\"%d%d\",&amp;u,&amp;k); if(k - 1 &gt;= sz[u]) printf(\"-1\\n\"); else printf(\"%d\\n\", ret[id[u]+k-1]); &#125; &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://vincentxwd.github.io/blog/tags/DFS/"}]},{"title":"[Codeforces1006D] Two Strings Swaps(规律)","slug":"Codeforces1006D-Two-Strings-Swaps-规律","date":"2018-08-01T15:06:48.000Z","updated":"2018-08-01T15:16:43.209Z","comments":true,"path":"2018/08/01/Codeforces1006D-Two-Strings-Swaps-规律/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1006D-Two-Strings-Swaps-规律/","excerpt":"链接：http://codeforces.com/contest/1006/problem/D 给你两个字符串，定义三种操作。要求你事先给其中一个字符串替换某几个字符，然后再经过任一种上述操作变成两个一样的字符串，问预处理替换的字符最少要几个","text":"链接：http://codeforces.com/contest/1006/problem/D 给你两个字符串，定义三种操作。要求你事先给其中一个字符串替换某几个字符，然后再经过任一种上述操作变成两个一样的字符串，问预处理替换的字符最少要几个 一个很容易发现的规律就是每次处理的时候仅需要关心操作涉及的四个字符，然后再分类讨论一下就行了。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;char s[maxn], t[maxn];int n;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; scanf(\"%s%s\",s,t); int ret = 0; for(int i = 0; i &lt; n / 2; i++) &#123; map&lt;int, int&gt; a; a[s[i]]++; a[s[n-i-1]]++; a[t[i]]++; a[t[n-i-1]]++; if(a.size() == 4) ret += 2; else if(a.size() == 3) &#123; if(s[i] == s[n-i-1]) ret += 2; else ret++; &#125; else if(a.size() == 2) &#123; if(a[s[i]] != 2) ret++; &#125; &#125; if(n &amp; 1) &#123; if(s[n/2] != t[n/2]) ret++; &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"规律","slug":"规律","permalink":"https://vincentxwd.github.io/blog/tags/规律/"}]},{"title":"[Codeforces1015E(1,2)] Stars Drawing (贪心,暴力)","slug":"Codeforces1015E-1-2-Stars-Drawing-贪心-暴力","date":"2018-08-01T07:15:25.000Z","updated":"2018-08-01T15:11:36.401Z","comments":true,"path":"2018/08/01/Codeforces1015E-1-2-Stars-Drawing-贪心-暴力/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1015E-1-2-Stars-Drawing-贪心-暴力/","excerpt":"链接： http://codeforces.com/contest/1015/problem/E1 http://codeforces.com/contest/1015/problem/E2 给你一个$n×m$的矩阵，里面的*组成十字（至少要5个构成十字，比如5个的十字大小为1，一次类推），问这里面的*是否能都组成十字。并输出一个方案。","text":"链接： http://codeforces.com/contest/1015/problem/E1 http://codeforces.com/contest/1015/problem/E2 给你一个$n×m$的矩阵，里面的*组成十字（至少要5个构成十字，比如5个的十字大小为1，一次类推），问这里面的*是否能都组成十字。并输出一个方案。 这题暴力，贪心地让每一个*向四个方向延拓尽可能长的范围，并打好标记，存下所有可能的十字，看看这些标记里有没有是*但是为标记的就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1010;constexpr int dx[5] = &#123;0, 0, 1, -1&#125;;constexpr int dy[5] = &#123;1, -1, 0, 0&#125;;using Node = struct &#123; int x, y, v; &#125;;char G[maxn][maxn];bool vis[maxn][maxn];int n, m;vector&lt;Node&gt; p, ret;inline bool ok(int x, int y) &#123; return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;&#125;void gao(int x, int y) &#123; int tot = 1; bool flag = true; bool yes = false; while(flag) &#123; flag = false; int cnt = 0; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i] * tot; int ty = y + dy[i] * tot; if(ok(tx, ty) &amp;&amp; G[tx][ty] == '*') cnt++; &#125; if(cnt != 4) break; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i] * tot; int ty = y + dy[i] * tot; vis[tx][ty] = 1; &#125; flag = true; yes = true; tot++; &#125; if(yes) &#123; vis[x][y] = 1; ret.push_back(&#123;x+1, y+1, tot-1&#125;); &#125;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; p.clear(); ret.clear(); memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; i++) scanf(\"%s\", G[i]); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(G[i][j] == '*') p.push_back(&#123;i, j, 0&#125;); &#125; &#125; if(p.size() == 0) &#123; printf(\"0\\n\"); continue; &#125; for(auto t : p) gao(t.x, t.y); if(ret.size() == 0) &#123; printf(\"-1\\n\"); continue; &#125; bool flag = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(!vis[i][j] &amp;&amp; G[i][j] == '*') &#123; flag = 1; &#125; &#125; &#125; if(flag) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", ret.size()); for(auto t : ret) &#123; printf(\"%d %d %d\\n\", t.x, t.y, t.v); &#125; &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"}]},{"title":"[Codeforces1015D] Walking Between Houses (构造)","slug":"Codeforces1015D-Walking-Between-Houses-构造","date":"2018-08-01T03:50:49.000Z","updated":"2018-08-01T07:43:22.458Z","comments":true,"path":"2018/08/01/Codeforces1015D-Walking-Between-Houses-构造/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/08/01/Codeforces1015D-Walking-Between-Houses-构造/","excerpt":"链接：http://codeforces.com/contest/1015/problem/D 有$1~n$个房子，一个人从$1$出发，每次可以走任意步，现在希望走$k$次，求一个方案，这$k$次能走够$s$步（走到一个房子的地方，下一次再走的时候要以那个地方为起点）。","text":"链接：http://codeforces.com/contest/1015/problem/D 有$1~n$个房子，一个人从$1$出发，每次可以走任意步，现在希望走$k$次，求一个方案，这$k$次能走够$s$步（走到一个房子的地方，下一次再走的时候要以那个地方为起点）。 提供两种构造方法： 1：首先尽可能多地走$n-1$步，然后再走$s-(k-1)$步，最后剩下的都走$1$步。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const LL maxn = 100100;LL n, k, s;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;k,&amp;s)) &#123; LL tot = (n - 1) * k; if(tot &lt; s) &#123; printf(\"NO\\n\"); continue; &#125; if(k &gt; s) &#123; printf(\"NO\\n\"); continue; &#125; LL cur = 1; vector&lt;LL&gt; ret; while(k) &#123; LL t = min(n - 1, s - (k - 1)); cur = cur - t &gt; 0 ? cur - t : cur + t; s -= t; k--; ret.push_back(cur); &#125; printf(\"YES\\n\"); for(int i = 0; i &lt; ret.size(); i++) &#123; printf(\"%lld%c\", ret[i], \" \\n\"[i==ret.size()-1]); &#125; &#125; return 0;&#125; 2：$p=\\frac{s}{k}$，$q=s%k$，走$q$个$p+1$步，$k-q$个$p$步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;LL n, k, s;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;k,&amp;s)) &#123; LL tot = (n - 1) * k; if(tot &lt; s) &#123; printf(\"NO\\n\"); continue; &#125; if(k &gt; s) &#123; printf(\"NO\\n\"); continue; &#125; LL p = s / k; LL q = s % k; vector&lt;LL&gt; ret; LL cur = 1; for(int i = 0; i &lt; q; i++) &#123; ret.push_back((i % 2 == 0) ? p+2 : 1); cur = (i % 2 == 0) ? p+2 : 1; &#125; if(cur == 1) &#123; for(int i = 0; i &lt; k - q; i++) &#123; cur += (i % 2 == 0) ? p : -p; ret.push_back(cur); &#125; &#125; else &#123; for(int i = 0; i &lt; k - q; i++) &#123; cur += (i % 2 == 0) ? -p : p; ret.push_back(cur); &#125; &#125; printf(\"YES\\n\"); for(int i = 0; i &lt; ret.size(); i++) &#123; printf(\"%lld%c\", ret[i], \" \\n\"[i==ret.size()-1]); &#125; &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://vincentxwd.github.io/blog/tags/构造/"}]},{"title":"[Codeforces1013E] Hills(DP)","slug":"Codeforces1013E-Hills-DP","date":"2018-07-31T13:40:19.000Z","updated":"2018-08-01T07:43:12.633Z","comments":true,"path":"2018/07/31/Codeforces1013E-Hills-DP/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/31/Codeforces1013E-Hills-DP/","excerpt":"链接：http://codeforces.com/contest/1013/problem/E 给n个数，允许让每个数删减，现想要求k个严格的局部最大值，k取值为$[1,\\lceil\\frac{n}{2}\\rceil]$。","text":"链接：http://codeforces.com/contest/1013/problem/E 给n个数，允许让每个数删减，现想要求k个严格的局部最大值，k取值为$[1,\\lceil\\frac{n}{2}\\rceil]$。 这dp考的时候没想出来，可以这么做：$f(i,j,k)$表示前$i$个数里有$j$个最大值，此时还讨论第$i$个数是($k=1$)否($k=0$)是局部最大值。 状态转移如下： $k=0$时，$f(i,j,0)$可以更新到$f(i+1,j,0)$上，因为此时$i$和$i+1$都不是局部最大值，因此$j$不会变；或者更新到$f(i+1,j+1,1)$上，此时在$i+1$处为一个局部最大值。 $k=1$时，$f(i,k,1)$更新到$f(i+1,j,0)$上，但是相应地要有删减的代价；也可以更新到$f(i+2,j+1,1)$上，显然$i+1$处必然是一个极小值。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5050;const int inf = 0x7f7f7f7f;int n;int a[maxn];int f[maxn][maxn][2];int update(int x, int y) &#123; return x &gt; y ? 0 : y - x + 1;&#125;int main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; int K = (int)ceil(n / 2.0); memset(f, 0x7f, sizeof(f)); f[1][0][0] = 0; f[1][1][1] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= K; j++) &#123; for(int k = 0; k &lt;= 1; k++) &#123; if(f[i][j][k] == inf) continue; if(k == 0) &#123; f[i+1][j+1][1] = min(f[i+1][j+1][1], f[i][j][k] + update(a[i+1], a[i])); f[i+1][j][0] = min(f[i+1][j][0], f[i][j][k]); &#125; else &#123; f[i+2][j+1][1] = min(f[i+2][j+1][1], f[i][j][k] + update(min(a[i], a[i+2]), a[i+1])); f[i+1][j][0] = min(f[i+1][j][0], f[i][j][k] + update(a[i], a[i+1])); &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= K; i++) &#123; printf(\"%d%c\", min(f[n][i][0], f[n][i][1]), \" \\n\"[i==K]); &#125; &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://vincentxwd.github.io/blog/tags/DP/"}]},{"title":"[Codeforces1013] Round #500 (Div. 2) [based on EJOI]","slug":"CF1013-Codeforces-Round-500-Div-2-based-on-EJOI","date":"2018-07-30T12:54:12.000Z","updated":"2018-08-04T13:01:26.993Z","comments":true,"path":"2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/30/CF1013-Codeforces-Round-500-Div-2-based-on-EJOI/","excerpt":"链接：http://codeforces.com/contest/1013","text":"链接：http://codeforces.com/contest/1013 A：n堆贝壳，第一天每一堆有ai个，现在可以拿走也可以移动任意个，然后给出第二天每一堆的贝壳的数量，问有没有可能。 两天的贝壳求和，如果不等就不可能。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 1111;int a, b;int n;signed main() &#123; // freopen(\"in\", \"r\", stdin); int t; while(~scanf(\"%d\", &amp;n)) &#123; a = 0, b = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;t); a += t; &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\" , &amp;t); b += t; &#125; if(a &gt;= b) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; B：给n个数ai，以及一个数x，现在允许x和ai进行与（&amp;）操作后替换ai，问最少操作多少次，n个数中出现两个相同的数字。 由于和x进行与操作后的结果再和x进行操作的结果不会变，因此每一个数至多和x与1次。考虑到结果只可能是-1 0 1 2，因此存下与操作后的数字结果，讨论一下就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int maxn = 100100;int n, x;int a[maxn];int vis[maxn], vis1[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;x)) &#123; memset(vis, 0, sizeof(vis)); memset(vis1, 0, sizeof(vis1)); int maxx = -1; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); maxx = max(maxx, a[i]); vis[a[i]]++; vis1[a[i]&amp;x]++; maxx = max(maxx, a[i] &amp; x); &#125; int flag = 0; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis[i] &gt;= 2) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; puts(\"0\"); continue; &#125; flag = 0x7f7f7f7f; for(int i = 1; i &lt;= n; i++) &#123; if((a[i] &amp; x) == a[i]) &#123; if(vis1[a[i]] &gt;= 2) flag = min(flag, 1); &#125; else &#123; if(vis1[a[i]]) flag = min(flag, 1); &#125; &#125; for(int i = 0; i &lt;= maxx; i++) &#123; if(vis1[i] &gt;= 2 &amp;&amp; !vis[i]) &#123; flag = min(flag, 2); &#125; &#125; if(flag == 0x7f7f7f7f) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", flag); &#125; return 0;&#125; C：给2n个数字，让你用这2n个数字构成n个二维平面上的点，要求是构造一个平行于坐标轴的、包括所有点的矩形，并且矩形面积最小（面积可以为0）。 很容易想到的是对a进行排序，之后将2n个数分为x坐标和y坐标两个集合，然后依次结合构成点。画图后发现答案就是两个集合的极差乘积，我们希望让这两个集合的极差尽可能小，因此每次从两个集合中拿出最小的放到对方的集合里，这里滑动窗口模拟一下就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;using LL = unsigned long long;const int maxn = 200100;int n;LL a[maxn];pair&lt;LL, LL&gt; p[maxn];map&lt;LL, int&gt; vis;deque&lt;LL&gt; r, q;multiset&lt;LL&gt; rr, qq;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d\",&amp;n)) &#123; vis.clear(); for(int i = 1; i &lt;= 2 * n; i++) &#123; cin &gt;&gt; a[i]; vis[a[i]]++; &#125; sort(a+1, a+2*n+1); bool flag = 0; for(auto p : vis) &#123; if(p.second &gt;= n) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; printf(\"0\\n\"); continue; &#125; r.clear(); q.clear(); rr.clear(); qq.clear(); LL x, y; for(int i = 1; i &lt;= n; i++) &#123; r.push_back(a[i]); rr.insert(a[i]); &#125; for(int i = n+1; i &lt;= 2*n; i++) &#123; q.push_back(a[i]); qq.insert(a[i]); &#125; LL ret = 9223372036854775800LL; for(int i = 1; i &lt;= n; i++) &#123; ret = min(ret, ((*rr.rbegin())-(*rr.begin()))*((*qq.rbegin())-(*qq.begin()))); x = r.front(); y = q.front(); r.push_back(y); q.push_back(x); r.pop_front(); q.pop_front(); rr.erase(rr.lower_bound(x)), qq.erase(qq.lower_bound(y)); rr.insert(y); qq.insert(x); &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; return 0;&#125; D：要向一个n×m的矩阵里画叉，并且当三个叉构成如下图所示的操作： 当到左图的情况时，会如右图：①的位置会补上（也就是构成了一个矩形）。 现在给你一个n×m的矩阵，以及一些画了叉的位置，问你最少需要手动画多少个叉，能够利用上述操作将整个矩阵填满。 考虑一个叉都不画的情况，最少需要画n+m-1（就是画一个十字）就能利用上述操作将矩阵填满。 再来考虑这个操作的实质：比方说现在有了(x1,y1)、(x1,y2)、(x2,y1)三个点，那么第四个点(x2,y2)实际上是没有贡献的，如下图： 转换成森林上，希望把坐标这个森林连成一片，问最少要加多少条边。这样我们读入数据的时候，x和y连起来（为了区别x和y，y+n来做分层），当他们的父亲不一样的时候，说明这个连接是必须有的，记一次数。之后用n+m-1减掉这个必要的计数就行了。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;LL, LL&gt; pll;const int maxn = 4000100;int n, m, q;int pre[maxn];int find(int x) &#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;int unite(int x, int y) &#123; x = find(x); y = find(y); if(x != y) &#123; pre[x] = y; return 1; &#125; return 0;&#125;int main() &#123; // freopen(\"in\", \"r\", stdin); int x, y; while(~scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q)) &#123; for(int i = 1; i &lt;= n + m; i++) &#123; pre[i] = i; &#125; int cnt = 0; for(int i = 0; i &lt; q; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); if(unite(x, y+n)) cnt++; &#125; printf(\"%d\\n\", n+m-1-cnt); &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"并查集","slug":"并查集","permalink":"https://vincentxwd.github.io/blog/tags/并查集/"},{"name":"STL","slug":"STL","permalink":"https://vincentxwd.github.io/blog/tags/STL/"}]},{"title":"[Codeforces1011] Round #499 (Div. 2)","slug":"CF1011-Codeforces-Round-499-Div-2","date":"2018-07-29T13:01:44.000Z","updated":"2018-08-04T13:01:17.891Z","comments":true,"path":"2018/07/29/CF1011-Codeforces-Round-499-Div-2/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/29/CF1011-Codeforces-Round-499-Div-2/","excerpt":"用hexo搭了博客，以后就在这里写题解和随笔了。","text":"用hexo搭了博客，以后就在这里写题解和随笔了。 $$mathjax测试：C_i=\\sum_{j×k=i}A_j*B_k$$复健开了一场CF div2，感觉非常不好啊。。 比赛链接是http://codeforces.com/contest/1011 A：n个字符取k个，不能取字典序相邻的，也不能取相同的。就这样取，问最小的ascii-‘a’+1的和是多少。 贪心，给字符排个序，取第一个，然后后面的取最小的。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;char s[maxn];int n, k;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;k)) &#123; scanf(\"%s\", s); sort(s, s+n); int pre = 0, ret = s[0] - 'a' + 1, tot = 1; for(int i = 1; i &lt; n; i++) &#123; if(tot &gt;= k) break; if(s[i] - s[pre] &gt; 1) &#123; ret += s[i] - 'a' + 1; pre = i; tot++; &#125; &#125; if(tot &lt; k) &#123; printf(\"-1\\n\"); &#125; else printf(\"%d\\n\", ret); &#125; return 0;&#125; B：n个人吃东西，一共m个东西，每个东西都有一类。每个人每天只能吃一个同一类东西，问怎么分配这m个东西，让这n个人吃得时间最久。 m很小，直接遍历天数day，然后贪心地check就ok了（数据量大了套个二分就行）。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 111;int n, m;int a[maxn], vis[maxn];int ok(int day) &#123; int tot = 0; for(int i = 0; i &lt; 101; i++) &#123; if(vis[i] &gt;= day) tot += (int)(vis[i] / (double)day); &#125; return tot &gt;= n;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; int lo = 0, hi = 100000; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;a[i]); vis[a[i]]++; &#125; if(n &gt; m) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0; for(int mid = 0; mid &lt; 101; mid++) &#123; if(ok(mid)) ret = mid; &#125; printf(\"%d\\n\", ret); &#125; return 0;&#125; C：n个星球，一个人坐重量为m的飞船从1出发到n，需要走1-&gt;2-&gt;..-&gt;n-&gt;1这样的路径，从每个点起飞要消耗ai的燃油，在每个点降落要消耗bi的燃油，燃油只能从1上带，问这人要带多少燃油才能完成这个路径。 二分燃油的量，判断是否满足，或从1-&gt;n-&gt;n-1-&gt;…1逆推，上一次的燃油量是x*m/(x-1)，x为起飞or降落的消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const double eps = 1e-9;int n, m;double a[maxn], b[maxn];int ok(double fuel) &#123; double tot = fuel + m; for(int i = 1; i &lt;= n - 1; i++) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i+1]; &#125; for(int i = n; i &gt;= 2; i--) &#123; tot -= (double)tot / (double)a[i]; tot -= (double)tot / (double)b[i-1]; &#125; return tot - m &gt;= eps;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; &#125; double ret = m; for(int i = 1; i &lt; n; i++) &#123; ret = b[i] * ret / (b[i] - 1.0); ret = a[i+1] * ret / (a[i+1] - 1.0); &#125; ret = b[n] * ret / (b[n] - 1.0); ret = a[1] * ret / (a[1] - 1.0); ret -= m; if(ret &gt; 1e9) &#123; printf(\"-1\\n\"); &#125; else printf(\"%.10f\\n\", ret); &#125; return 0;&#125; D：猜一个1到m的数字x，可以询问最多60次。每次回答有可能是假的，假的情况那么会输出真答案判别的相反数（大于的时候返回1，如果假的情况就返回-1，小于同理），回答的真假情况序列p的长为n，回答按照这个序列循环返回结果。求这个数字x。 可以用数字1去试探n次（当然答案是1的时候可以直接结束程序了），把n次询问的真假情况预处理出来记下，之后就可以愉快地二分x，根据上面预处理出来的真假情况修改返回结果了。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;int p[maxn];int n, m;int query(int y) &#123; printf(\"%d\\n\", y); fflush(stdout); int t; scanf(\"%d\", &amp;t); if(t == 0 || t == 2) exit(0); return t;&#125;signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;m,&amp;n)) &#123; memset(p, 0, sizeof(p)); for(int i = 0; i &lt; n; i++) &#123; int t = query(1); p[i] = (t == 1); &#125; int lo = 2, hi = m; for(int q = 0; ; q++) &#123; int mid = (lo + hi) &gt;&gt; 1; int t = query(mid); if(!p[q%n]) t = -t; if(t == 1) lo = mid + 1; else hi = mid - 1; &#125; &#125; return 0;&#125; E：n个数，每个数可以取任意次，相加后对k取模。求模的结果的个数。 统计k和每个数的gcd，答案就是k/gcd，依次取0,k/gcd,2k/gcd…就行了。过阵子尝试证明一下，相关概念有：有限域，生成元，生成多项式，循环群，裴蜀定理。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;using LL = long long;const int maxn = 100100;int n;LL k;LL a[maxn];bool vis[maxn];signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%lld\",&amp;n,&amp;k)) &#123; memset(vis, 0, sizeof(vis)); LL x = k; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); x = __gcd(x, a[i]); &#125; printf(\"%lld\\n\", k / x); for(LL i = 0; i &lt; k; i+=x) &#123; printf(\"%lld \", i); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://vincentxwd.github.io/blog/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"},{"name":"二分","slug":"二分","permalink":"https://vincentxwd.github.io/blog/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://vincentxwd.github.io/blog/tags/贪心/"},{"name":"交互题","slug":"交互题","permalink":"https://vincentxwd.github.io/blog/tags/交互题/"}]},{"title":"2018牛客多校01 J Different Integers","slug":"2018牛客多校01-J-Different-Integers","date":"2018-07-20T04:17:33.000Z","updated":"2018-08-02T14:25:24.178Z","comments":true,"path":"2018/07/20/2018牛客多校01-J-Different-Integers/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-J-Different-Integers/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/J n个数，q次查询l,r。求[1,l]和[r,n]中不同数的个数。","text":"链接：https://www.nowcoder.com/acm/contest/139/J n个数，q次查询l,r。求[1,l]和[r,n]中不同数的个数。 这题首先开二倍数组，然后在后n个位置重新存一遍这n个数，这样就相当于查询[r, n+l]内不同数的个数，用莫队或者bit离线计数都能做（代码是莫队）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std; inline bool scan_d(int &amp;num) &#123; char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!='-'&amp;&amp;(in&lt;'0'||in&gt;'9')) in=getchar(); if(in=='-')&#123; IsN=true;num=0;&#125; else num=in-'0'; while(in=getchar(),in&gt;='0'&amp;&amp;in&lt;='9')&#123; num*=10,num+=in-'0'; &#125; if(IsN) num=-num; return true;&#125; const int maxn = 100100;using Query = struct &#123; int l, r, ret, id; &#125;;int n, m;int a[maxn&lt;&lt;1], be[maxn&lt;&lt;1], L, R;Query q[maxn];int vis[maxn], sz; inline void add(int x, int &amp;ret) &#123; vis[x]++; if(vis[x] == 1) ret++;&#125; inline void remove(int x, int &amp;ret) &#123; vis[x]--; if(vis[x] == 0) ret--;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; sz = static_cast&lt;int&gt;(sqrt(n)); memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i++) &#123; scan_d(a[i]); a[n+i] = a[i]; be[i] = static_cast&lt;int&gt;(i / sz); be[i+n] = static_cast&lt;int&gt;((i + n) / sz); &#125; for(int i = 1; i &lt;= m; i++) &#123; scan_d(q[i].r); scan_d(q[i].l); q[i].r += n; q[i].id = i; &#125; sort(q+1, q+m+1, [](Query a, Query b) &#123; return be[a.l] == be[b.l] ? a.r &lt; b.r : a.l &lt; b.l; &#125;); int ret = 0; L = 1, R = 0; for(int i = 1; i &lt;= m; i++) &#123; while(L &lt; q[i].l) &#123; remove(a[L], ret); L++; &#125; while(L &gt; q[i].l) &#123; L--; add(a[L], ret); &#125; while(R &lt; q[i].r) &#123; R++; add(a[R], ret); &#125; while(R &gt; q[i].r) &#123; remove(a[R], ret); R--; &#125; q[i].ret = ret; &#125; sort(q+1, q+m+1, [](Query a, Query b)&#123; return a.id &lt; b.id; &#125;); for(int i = 1; i &lt;= m; i++) &#123; printf(\"%d\\n\", q[i].ret); &#125; &#125; return 0;&#125;","categories":[{"name":"2018牛客多校","slug":"2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校/"}],"tags":[{"name":"莫队算法","slug":"莫队算法","permalink":"https://vincentxwd.github.io/blog/tags/莫队算法/"},{"name":"离线","slug":"离线","permalink":"https://vincentxwd.github.io/blog/tags/离线/"},{"name":"树状数组","slug":"树状数组","permalink":"https://vincentxwd.github.io/blog/tags/树状数组/"}]},{"title":"2018牛客多校01 D Two Graphs","slug":"2018牛客多校01-D-Two-Graphs","date":"2018-07-20T04:10:51.000Z","updated":"2018-08-02T14:25:32.988Z","comments":true,"path":"2018/07/20/2018牛客多校01-D-Two-Graphs/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-D-Two-Graphs/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/D 求G1的同构图，是G2的子图。","text":"链接：https://www.nowcoder.com/acm/contest/139/D 求G1的同构图，是G2的子图。 暴力枚举全排列，对于每一个排列，看看G2中是否每一条边都存在，然后再看看是否每一条边都在G1中存在（这里存在的话必然会重复计数），然后用上一个计数结果除以下一个即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn = 11;int n;int m1, m2;int id[maxn];int b[maxn][maxn], c[maxn][maxn];vector&lt;int&gt; a[maxn]; signed main() &#123; // freopen(\"in\", \"r\", stdin); int x, y; while(~scanf(\"%d%d%d\",&amp;n,&amp;m1,&amp;m2)) &#123; for(int i = 1; i &lt;= n; i++) &#123; a[i].clear(); &#125; memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); for(int i = 1; i &lt;= m1; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); a[x].push_back(y); a[y].push_back(x); c[x][y] = c[y][x] = 1; &#125; for(int i = 1; i &lt;= m2; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); b[x][y] = b[y][x] = 1; &#125; for(int i = 1; i &lt;= n; i++) &#123; id[i] = i; &#125; if(m1 &gt; m2) &#123; printf(\"0\\n\"); continue; &#125; int ret = 0, tot = 0; do &#123; int flag = 1; for(x = 1; x &lt;= n; x++) &#123; for(int j = 0; j &lt; a[x].size(); j++) &#123; y = a[x][j]; if(!b[id[x]][id[y]]) &#123; flag = 0; break; &#125; &#125; &#125; if(flag) ret++; flag = 1; for(x = 1; x &lt;= n; x++) &#123; for(int j = 0; j &lt; a[x].size(); j++) &#123; y = a[x][j]; if(!c[id[x]][id[y]]) &#123; flag = 0; break; &#125; &#125; &#125; if(flag) tot++; &#125;while(next_permutation(id+1, id+n+1)); printf(\"%d\\n\", ret / tot); &#125; return 0;&#125;","categories":[{"name":"2018牛客多校","slug":"2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"https://vincentxwd.github.io/blog/tags/暴力/"},{"name":"枚举","slug":"枚举","permalink":"https://vincentxwd.github.io/blog/tags/枚举/"}]},{"title":"2018牛客多校01 A Monotonic Matrix","slug":"2018牛客多校01-A-Monotonic-Matrix","date":"2018-07-20T03:54:47.000Z","updated":"2018-08-02T14:25:38.219Z","comments":true,"path":"2018/07/20/2018牛客多校01-A-Monotonic-Matrix/","link":"","permalink":"https://vincentxwd.github.io/blog/2018/07/20/2018牛客多校01-A-Monotonic-Matrix/","excerpt":"链接：https://www.nowcoder.com/acm/contest/139/A 求一个n*m的0、1、2矩阵（满足左上小于右下）的构造方案数。","text":"链接：https://www.nowcoder.com/acm/contest/139/A 求一个n*m的0、1、2矩阵（满足左上小于右下）的构造方案数。 方案数就等于这两条可以重合（不可相交）的分界线的种类数，如下图： 即：给定起点(n,0)、终点(0,m)，只能向上和向右走，问有多少种走法，其实就是向右走m步向上走n步的组合数：$$C_{n+m}^m或C_{n+m}^n$$这里给出Lindström–Gessel–Viennot引理的应用：给一张无权有向无环图，给定n个起点和对应的n个终点，求n条不相交路径的方案数，引理给出结果为： 其中$a_{i}$表示路径i的起点，$b_{i}$表示路径i的终点。答案就是M的行列式的值。 对于本两条线的起点和终点不能重叠而且得和原方案等价（方案数等价即可），这就需要变换一下。把起终点向左上平移一下，将其中的一对起终点平移到$(n-1,-1)$和$(-1,m-1)$去，就有$e(a_1,b_1)=e(a_2,b_2)=C_{n+m}^n$，$e(a_1,b_2)=C_{n+m}^{n+1}$，$e(a_2,b_1)=C_{n+m}^{m+1}$那么针对本题的答案就是：$${C_{n+m}^n}^2-C_{n+m}^{n+1}×C_{n+m}^{m+1}$$ 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std; using LL = long long;const LL mod = 1e9+7;const int maxn = 3010;int n, m;LL c[maxn][maxn]; void init() &#123; memset(c,0,sizeof(c)); c[0][0]=c[1][0]=c[1][1]=1; for(int i = 2; i &lt; maxn; i++) &#123; c[i][0] = c[i][i] = 1; for(int j = 1; j &lt; i; j++) &#123; c[i][j] = c[i-1][j] + c[i-1][j-1]; c[i][j] %= mod; &#125; &#125;&#125; signed main() &#123; // freopen(\"in\", \"r\", stdin); init(); while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; LL ret = c[n+m][n]*c[n+m][n]; ret %= mod; LL tmp = c[n+m][n+1]*c[n+m][m+1]; tmp %= mod; ret -= tmp; ret += mod; ret %= mod; printf(\"%lld\\n\", ret); &#125; return 0;&#125;","categories":[{"name":"2018牛客多校","slug":"2018牛客多校","permalink":"https://vincentxwd.github.io/blog/categories/2018牛客多校/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://vincentxwd.github.io/blog/tags/数学/"}]}]}